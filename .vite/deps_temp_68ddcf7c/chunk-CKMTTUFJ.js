import {
  createBatchScheduler
} from "./chunk-75KXWIUS.js";
import {
  $u,
  Ah,
  An,
  As,
  Bh,
  Bu,
  Ch,
  Cu,
  Du,
  Eh,
  Es,
  Eu,
  Fu,
  Is,
  Iu,
  Lt,
  Lu,
  Mh,
  Ms,
  Mu,
  Nr,
  Ns,
  Oo,
  Ou,
  Pe,
  Pn,
  Po,
  Pu,
  Rh,
  Ru,
  Sh,
  Sr,
  Ss,
  Su,
  To,
  Tu,
  Uu,
  Vi,
  Vr,
  Wf,
  Wr,
  Xr,
  Xu,
  Yt,
  Ze,
  Zu,
  _h,
  _s,
  _u,
  bh,
  bi,
  bs,
  ch,
  cs,
  decodeJWT,
  dh,
  encodeIss,
  er,
  fs,
  generateKeyPair,
  gh,
  gr,
  gs,
  gu,
  hh,
  init_tslib_es6,
  ju,
  ku,
  lh,
  ls,
  me,
  mh,
  ms,
  mu,
  ns,
  on,
  ph,
  pr,
  qu,
  require_cjs,
  rr,
  signJWT,
  so,
  ss,
  tn,
  toString,
  tslib_es6_exports,
  uh,
  vh,
  wh,
  ws,
  xe,
  xh,
  xo,
  xs,
  xu,
  yh,
  ys,
  zu
} from "./chunk-ZH7V6PZP.js";
import {
  A,
  AccountController,
  AlertController,
  ApiController,
  AssetController,
  AssetUtil,
  BlockchainApiController,
  ChainController,
  ConnectionController,
  ConnectorController,
  ConstantsUtil,
  ConstantsUtil2,
  CoreHelperUtil,
  DateUtil,
  E,
  EnsController,
  EventsController,
  InputUtil,
  LitElement,
  MathUtil,
  ModalController,
  NavigationUtil,
  NumberUtil,
  OnRampController,
  OptionsController,
  PublicStateController,
  RouterController,
  SafeLocalStorage,
  SafeLocalStorageKeys,
  SendController,
  SnackController,
  StorageUtil,
  SwapController,
  ThemeController,
  TooltipController,
  TransactionUtil,
  TransactionsController,
  UiHelperUtil,
  W3mFrameHelpers,
  W3mFrameProvider,
  W3mFrameRpcConstants,
  a,
  classMap,
  createRef,
  css,
  customElement,
  getW3mThemeVariables,
  html,
  ifDefined,
  import_pino,
  k,
  p,
  property,
  proxy,
  ref,
  ref2,
  safeJsonParse,
  safeJsonStringify,
  setColorTheme,
  setThemeVariables,
  snapshot,
  state,
  subscribe,
  subscribeKey,
  w,
  y
} from "./chunk-UFCBRU52.js";
import {
  solana,
  solanaDevnet
} from "./chunk-IAIWU4J6.js";
import {
  HashMD
} from "./chunk-DSWFES7F.js";
import {
  BaseError,
  ChainDisconnectedError,
  HttpRequestError,
  InternalRpcError,
  InvalidInputRpcError,
  InvalidParamsRpcError,
  InvalidRequestRpcError,
  JsonRpcVersionUnsupportedError,
  LimitExceededRpcError,
  LruMap,
  MethodNotFoundRpcError,
  MethodNotSupportedRpcError,
  ParseRpcError,
  ProviderDisconnectedError,
  ResourceNotFoundRpcError,
  ResourceUnavailableRpcError,
  RpcRequestError,
  SwitchChainError,
  TimeoutError,
  TransactionRejectedRpcError,
  UnauthorizedProviderError,
  UnknownRpcError,
  UnsupportedProviderMethodError,
  UserRejectedRequestError,
  hexToNumber,
  keccak256,
  numberToHex,
  stringToHex,
  stringify
} from "./chunk-ZQE76UJS.js";
import {
  rotl,
  wrapConstructor
} from "./chunk-ZTBOFYUR.js";
import {
  require_react
} from "./chunk-OJK6TXMW.js";
import {
  __commonJS,
  __export,
  __reExport,
  __toCommonJS,
  __toESM
} from "./chunk-256EKJAK.js";

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React = require_react();
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is2(x4, y6) {
          return x4 === y6 && (x4 !== 0 || 1 / x4 === 1 / y6) || x4 !== x4 && y6 !== y6;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is2;
        var useState = React.useState, useEffect2 = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue2 = React.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore2(subscribe2, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe2, value, getSnapshot]);
          useEffect2(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe2(handleStoreChange);
          }, [subscribe2]);
          useDebugValue2(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe2, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore2;
        var useSyncExternalStore$2 = React.useSyncExternalStore !== void 0 ? React.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R2 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R2 && typeof R2.ownKeys === "function") {
      ReflectOwnKeys = R2.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n4) {
      if (typeof n4 !== "number" || n4 < 0 || NumberIsNaN(n4)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n4 + ".");
      }
      this._maxListeners = n4;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i3 = 1; i3 < arguments.length; i3++) args.push(arguments[i3]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er3;
        if (args.length > 0)
          er3 = args[0];
        if (er3 instanceof Error) {
          throw er3;
        }
        var err = new Error("Unhandled error." + (er3 ? " (" + er3.message + ")" : ""));
        err.context = er3;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i3 = 0; i3 < len; ++i3)
          ReflectApply(listeners[i3], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m2;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m2 = _getMaxListeners(target);
        if (m2 > 0 && existing.length > m2 && !existing.warned) {
          existing.warned = true;
          var w5 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w5.name = "MaxListenersExceededWarning";
          w5.emitter = target;
          w5.type = type;
          w5.count = existing.length;
          ProcessEmitWarning(w5);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state3 = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state3);
      wrapped.listener = listener;
      state3.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i3, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i3 = list.length - 1; i3 >= 0; i3--) {
          if (list[i3] === listener || list[i3].listener === listener) {
            originalListener = list[i3].listener;
            position = i3;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i3;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        var key;
        for (i3 = 0; i3 < keys2.length; ++i3) {
          key = keys2[i3];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i3 = listeners.length - 1; i3 >= 0; i3--) {
          this.removeListener(type, listeners[i3]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n4) {
      var copy = new Array(n4);
      for (var i3 = 0; i3 < n4; ++i3)
        copy[i3] = arr[i3];
      return copy;
    }
    function spliceOne(list, index2) {
      for (; index2 + 1 < list.length; index2++)
        list[index2] = list[index2 + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i3 = 0; i3 < ret.length; ++i3) {
        ret[i3] = arr[i3].listener || arr[i3];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
    function getBrowerCrypto() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports.getBrowerCrypto = getBrowerCrypto;
    function getSubtleCrypto() {
      const browserCrypto = getBrowerCrypto();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports.getSubtleCrypto = getSubtleCrypto;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto() && !!getSubtleCrypto();
    }
    exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports.isReactNative = isReactNative;
    function isNode2() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports.isNode = isNode2;
    function isBrowser() {
      return !isReactNative() && !isNode2();
    }
    exports.isBrowser = isBrowser;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_crypto(), exports);
    tslib_1.__exportStar(require_env(), exports);
  }
});

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/lodash.isequal/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.isequal/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (predicate(value, index2, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index2 = -1, length = values.length, offset = array.length;
      while (++index2 < length) {
        array[offset + index2] = values[index2];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n4, iteratee) {
      var index2 = -1, result = Array(n4);
      while (++index2 < n4) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index2 = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data3 = this.__data__;
      if (nativeCreate) {
        var result = data3[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data3, key) ? data3[key] : void 0;
    }
    function hashHas(key) {
      var data3 = this.__data__;
      return nativeCreate ? data3[key] !== void 0 : hasOwnProperty.call(data3, key);
    }
    function hashSet(key, value) {
      var data3 = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data3[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data3 = this.__data__, index2 = assocIndexOf(data3, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data3.length - 1;
      if (index2 == lastIndex) {
        data3.pop();
      } else {
        splice.call(data3, index2, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data3 = this.__data__, index2 = assocIndexOf(data3, key);
      return index2 < 0 ? void 0 : data3[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data3 = this.__data__, index2 = assocIndexOf(data3, key);
      if (index2 < 0) {
        ++this.size;
        data3.push([key, value]);
      } else {
        data3[index2][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data3 = getMapData(this, key), size3 = data3.size;
      data3.set(key, value);
      this.size += data3.size == size3 ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index2 = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index2 < length) {
        this.add(values[index2]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data3 = this.__data__ = new ListCache(entries);
      this.size = data3.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data3 = this.__data__, result = data3["delete"](key);
      this.size = data3.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data3 = this.__data__;
      if (data3 instanceof ListCache) {
        var pairs = data3.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data3.size;
          return this;
        }
        data3 = this.__data__ = new MapCache(pairs);
      }
      data3.set(key, value);
      this.size = data3.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index2 < arrLength) {
        var arrValue = array[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys2, getSymbols);
    }
    function getMapData(map, key) {
      var data3 = map.__data__;
      return isKeyable(key) ? data3[typeof key == "string" ? "string" : "hash"] : data3.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys2(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var global2 = typeof self !== "undefined" ? self : exports;
    var __self__ = function() {
      function F3() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F3.prototype = global2;
      return new F3();
    }();
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e2) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i3 = 0; i3 < view.length; i3++) {
            chars[i3] = String.fromCharCode(view[i3]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request2(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request2) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request2.prototype.clone = function() {
          return new Request2(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request2.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request2(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch2;
          self2.Headers = Headers;
          self2.Request = Request2;
          self2.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request2;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/@reown/appkit/dist/esm/src/utils/ConstantsUtil.js
var WcConstantsUtil = {
  ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
  ERROR_CODE_DEFAULT: 5e3
};

// node_modules/@reown/appkit/dist/esm/src/utils/HelpersUtil.js
var WcHelpersUtil = {
  getMethodsByChainNamespace(chainNamespace) {
    switch (chainNamespace) {
      case "solana":
        return [
          "solana_signMessage",
          "solana_signTransaction",
          "solana_requestAccounts",
          "solana_getAccounts",
          "solana_signAllTransactions",
          "solana_signAndSendTransaction"
        ];
      case "eip155":
        return [
          "personal_sign",
          "eth_sign",
          "eth_signTransaction",
          "eth_signTypedData",
          "eth_signTypedData_v3",
          "eth_signTypedData_v4",
          "eth_sendRawTransaction",
          "eth_sendTransaction",
          "wallet_getCapabilities",
          "wallet_sendCalls",
          "wallet_showCallsStatus",
          "wallet_getCallsStatus",
          "wallet_grantPermissions",
          "wallet_revokePermissions",
          "wallet_switchEthereumChain"
        ];
      default:
        return [];
    }
  },
  createNamespaces(caipNetworks) {
    return caipNetworks.reduce((acc, chain) => {
      const { id, chainNamespace, rpcUrls } = chain;
      const rpcUrl = rpcUrls.default.http[0];
      const methods = this.getMethodsByChainNamespace(chainNamespace);
      if (!acc[chainNamespace]) {
        acc[chainNamespace] = {
          methods,
          events: ["accountsChanged", "chainChanged"],
          chains: [],
          rpcMap: {}
        };
      }
      const caipNetworkId = `${chainNamespace}:${id}`;
      const namespace = acc[chainNamespace];
      namespace.chains.push(caipNetworkId);
      switch (caipNetworkId) {
        case solana.caipNetworkId:
          namespace.chains.push(solana.deprecatedCaipNetworkId);
          break;
        case solanaDevnet.deprecatedCaipNetworkId:
          namespace.chains.push(solanaDevnet.deprecatedCaipNetworkId);
          break;
        default:
      }
      if ((namespace == null ? void 0 : namespace.rpcMap) && rpcUrl) {
        namespace.rpcMap[id] = rpcUrl;
      }
      return acc;
    }, {});
  },
  resolveReownName: async (name) => {
    var _a;
    const wcNameAddress = await EnsController.resolveName(name);
    const networkNameAddresses = Object.values(wcNameAddress == null ? void 0 : wcNameAddress.addresses) || [];
    return ((_a = networkNameAddresses[0]) == null ? void 0 : _a.address) || false;
  },
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const [chainNamespace, chainId] = account.split(":");
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  }
};

// node_modules/@reown/appkit-utils/dist/esm/src/ConstantsUtil.js
var ConstantsUtil3 = {
  WALLET_CONNECT_CONNECTOR_ID: "walletConnect",
  INJECTED_CONNECTOR_ID: "injected",
  WALLET_STANDARD_CONNECTOR_ID: "announced",
  COINBASE_CONNECTOR_ID: "coinbaseWallet",
  COINBASE_SDK_CONNECTOR_ID: "coinbaseWalletSDK",
  SAFE_CONNECTOR_ID: "safe",
  LEDGER_CONNECTOR_ID: "ledger",
  EIP6963_CONNECTOR_ID: "eip6963",
  AUTH_CONNECTOR_ID: "ID_AUTH",
  EIP155: "eip155",
  ADD_CHAIN_METHOD: "wallet_addEthereumChain",
  EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
  EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
  CONNECTOR_RDNS_MAP: {
    coinbaseWallet: "com.coinbase.wallet",
    coinbaseWalletSDK: "com.coinbase.wallet"
  },
  CONNECTOR_TYPE_EXTERNAL: "EXTERNAL",
  CONNECTOR_TYPE_WALLET_CONNECT: "WALLET_CONNECT",
  CONNECTOR_TYPE_INJECTED: "INJECTED",
  CONNECTOR_TYPE_ANNOUNCED: "ANNOUNCED",
  CONNECTOR_TYPE_AUTH: "AUTH",
  CONNECTOR_TYPE_MULTI_CHAIN: "MULTI_CHAIN",
  CONNECTOR_TYPE_W3M_AUTH: "ID_AUTH"
};

// node_modules/@reown/appkit-utils/dist/esm/src/PresetsUtil.js
var PresetsUtil = {
  ConnectorExplorerIds: {
    [ConstantsUtil3.COINBASE_CONNECTOR_ID]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    [ConstantsUtil3.COINBASE_SDK_CONNECTOR_ID]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    [ConstantsUtil3.SAFE_CONNECTOR_ID]: "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
    [ConstantsUtil3.LEDGER_CONNECTOR_ID]: "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927"
  },
  NetworkImageIds: {
    1: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
    42161: "3bff954d-5cb0-47a0-9a23-d20192e74600",
    43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
    56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
    250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
    10: "ab9c186a-c52f-464b-2906-ca59d760a400",
    137: "41d04d42-da3b-4453-8506-668cc0727900",
    100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
    9001: "f926ff41-260d-4028-635e-91913fc28e00",
    324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
    314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
    4689: "34e68754-e536-40da-c153-6ef2e7188a00",
    1088: "3897a66d-40b9-4833-162f-a2c90531c900",
    1284: "161038da-44ae-4ec7-1208-0ea569454b00",
    1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
    7777777: "845c60df-d429-4991-e687-91ae45791600",
    42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
    8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
    1313161554: "3ff73439-a619-4894-9262-4470c773a100",
    2020: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
    2021: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
    "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": "a1b58899-f671-4276-6a5e-56ca5bd59700",
    "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z": "a1b58899-f671-4276-6a5e-56ca5bd59700",
    EtWTRABZaYq6iMfeYKouRu166VU2xqa1: "a1b58899-f671-4276-6a5e-56ca5bd59700"
  },
  ConnectorImageIds: {
    [ConstantsUtil3.COINBASE_CONNECTOR_ID]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
    [ConstantsUtil3.COINBASE_SDK_CONNECTOR_ID]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
    [ConstantsUtil3.SAFE_CONNECTOR_ID]: "461db637-8616-43ce-035a-d89b8a1d5800",
    [ConstantsUtil3.LEDGER_CONNECTOR_ID]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
    [ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID]: "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
    [ConstantsUtil3.INJECTED_CONNECTOR_ID]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00"
  },
  ConnectorNamesMap: {
    [ConstantsUtil3.INJECTED_CONNECTOR_ID]: "Browser Wallet",
    [ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID]: "WalletConnect",
    [ConstantsUtil3.COINBASE_CONNECTOR_ID]: "Coinbase",
    [ConstantsUtil3.COINBASE_SDK_CONNECTOR_ID]: "Coinbase",
    [ConstantsUtil3.LEDGER_CONNECTOR_ID]: "Ledger",
    [ConstantsUtil3.SAFE_CONNECTOR_ID]: "Safe"
  },
  ConnectorTypesMap: {
    [ConstantsUtil3.INJECTED_CONNECTOR_ID]: "INJECTED",
    [ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID]: "WALLET_CONNECT",
    [ConstantsUtil3.EIP6963_CONNECTOR_ID]: "ANNOUNCED",
    [ConstantsUtil3.AUTH_CONNECTOR_ID]: "AUTH"
  },
  WalletConnectRpcChainIds: [
    1,
    5,
    11155111,
    10,
    420,
    42161,
    421613,
    137,
    80001,
    42220,
    1313161554,
    1313161555,
    56,
    97,
    43114,
    43113,
    100,
    8453,
    84531,
    7777777,
    999,
    324,
    280
  ]
};

// node_modules/@reown/appkit-utils/dist/esm/src/ErrorUtil.js
var ErrorUtil = {
  UniversalProviderErrors: {
    UNAUTHORIZED_DOMAIN_NOT_ALLOWED: {
      message: "Unauthorized: origin not allowed",
      alertErrorKey: "INVALID_APP_CONFIGURATION"
    },
    JWT_VALIDATION_ERROR: {
      message: "JWT validation error: JWT Token is not yet valid",
      alertErrorKey: "JWT_TOKEN_NOT_VALID"
    }
  },
  ALERT_ERRORS: {
    SWITCH_NETWORK_NOT_FOUND: {
      shortMessage: "Network Not Found",
      longMessage: "Network not found - please make sure it is included in 'networks' array in createAppKit function"
    },
    INVALID_APP_CONFIGURATION: {
      shortMessage: "Invalid App Configuration",
      longMessage: () => `Origin ${isSafe() ? window.origin : "unknown"} not found on Allowlist - update configuration on cloud.reown.com`
    },
    SOCIALS_TIMEOUT: {
      shortMessage: "Invalid App Configuration",
      longMessage: () => "There was an issue loading the embedded wallet. Please verify that your domain is allowed at cloud.reown.com"
    },
    JWT_TOKEN_NOT_VALID: {
      shortMessage: "Session Expired",
      longMessage: "Invalid session found on UniversalProvider - please check your time settings and connect again"
    },
    PROJECT_ID_NOT_CONFIGURED: {
      shortMessage: "Project ID Not Configured",
      longMessage: "Project ID Not Configured - update configuration on cloud.reown.com"
    }
  }
};
function isSafe() {
  return typeof window !== "undefined";
}

// node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
  }, { dedupe: Boolean(blockNumber) });
  return hexToNumber(count);
}

// node_modules/viem/_esm/utils/wait.js
async function wait(time) {
  return new Promise((res) => setTimeout(res, time));
}

// node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace = new LruMap(128);

// node_modules/viem/_esm/utils/uid.js
var size2 = 256;
var index = size2;
var buffer;
function uid(length = 11) {
  if (!buffer || index + length > size2 * 2) {
    buffer = "";
    index = 0;
    for (let i3 = 0; i3 < size2; i3++) {
      buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer.substring(index, index++ + length);
}

// node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache = new LruMap(8192);
function withDedupe(fn2, { enabled = true, id }) {
  if (!enabled || !id)
    return fn2();
  if (promiseCache.get(id))
    return promiseCache.get(id);
  const promise = fn2().finally(() => promiseCache.delete(id));
  promiseCache.set(id, promise);
  return promise;
}

// node_modules/viem/_esm/utils/promise/withRetry.js
function withRetry(fn2, { delay: delay_ = 100, retryCount = 2, shouldRetry: shouldRetry2 = () => true } = {}) {
  return new Promise((resolve, reject) => {
    const attemptRetry = async ({ count = 0 } = {}) => {
      const retry = async ({ error }) => {
        const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
        if (delay)
          await wait(delay);
        attemptRetry({ count: count + 1 });
      };
      try {
        const data3 = await fn2();
        resolve(data3);
      } catch (err) {
        if (count < retryCount && await shouldRetry2({ count, error: err }))
          return retry({ error: err });
        reject(err);
      }
    };
    attemptRetry();
  });
}

// node_modules/viem/_esm/utils/buildRequest.js
function buildRequest(request, options = {}) {
  return async (args, overrideOptions = {}) => {
    const { dedupe = false, retryDelay = 150, retryCount = 3, uid: uid2 } = {
      ...options,
      ...overrideOptions
    };
    const requestId = dedupe ? keccak256(stringToHex(`${uid2}.${stringify(args)}`)) : void 0;
    return withDedupe(() => withRetry(async () => {
      try {
        return await request(args);
      } catch (err_) {
        const err = err_;
        switch (err.code) {
          case ParseRpcError.code:
            throw new ParseRpcError(err);
          case InvalidRequestRpcError.code:
            throw new InvalidRequestRpcError(err);
          case MethodNotFoundRpcError.code:
            throw new MethodNotFoundRpcError(err, { method: args.method });
          case InvalidParamsRpcError.code:
            throw new InvalidParamsRpcError(err);
          case InternalRpcError.code:
            throw new InternalRpcError(err);
          case InvalidInputRpcError.code:
            throw new InvalidInputRpcError(err);
          case ResourceNotFoundRpcError.code:
            throw new ResourceNotFoundRpcError(err);
          case ResourceUnavailableRpcError.code:
            throw new ResourceUnavailableRpcError(err);
          case TransactionRejectedRpcError.code:
            throw new TransactionRejectedRpcError(err);
          case MethodNotSupportedRpcError.code:
            throw new MethodNotSupportedRpcError(err, {
              method: args.method
            });
          case LimitExceededRpcError.code:
            throw new LimitExceededRpcError(err);
          case JsonRpcVersionUnsupportedError.code:
            throw new JsonRpcVersionUnsupportedError(err);
          case UserRejectedRequestError.code:
            throw new UserRejectedRequestError(err);
          case UnauthorizedProviderError.code:
            throw new UnauthorizedProviderError(err);
          case UnsupportedProviderMethodError.code:
            throw new UnsupportedProviderMethodError(err);
          case ProviderDisconnectedError.code:
            throw new ProviderDisconnectedError(err);
          case ChainDisconnectedError.code:
            throw new ChainDisconnectedError(err);
          case SwitchChainError.code:
            throw new SwitchChainError(err);
          case 5e3:
            throw new UserRejectedRequestError(err);
          default:
            if (err_ instanceof BaseError)
              throw err_;
            throw new UnknownRpcError(err);
        }
      }
    }, {
      delay: ({ count, error }) => {
        var _a;
        if (error && error instanceof HttpRequestError) {
          const retryAfter = (_a = error == null ? void 0 : error.headers) == null ? void 0 : _a.get("Retry-After");
          if (retryAfter == null ? void 0 : retryAfter.match(/\d/))
            return Number.parseInt(retryAfter) * 1e3;
        }
        return ~~(1 << count) * retryDelay;
      },
      retryCount,
      shouldRetry: ({ error }) => shouldRetry(error)
    }), { enabled: dedupe, id: requestId });
  };
}
function shouldRetry(error) {
  if ("code" in error && typeof error.code === "number") {
    if (error.code === -1)
      return true;
    if (error.code === LimitExceededRpcError.code)
      return true;
    if (error.code === InternalRpcError.code)
      return true;
    return false;
  }
  if (error instanceof HttpRequestError && error.status) {
    if (error.status === 403)
      return true;
    if (error.status === 408)
      return true;
    if (error.status === 413)
      return true;
    if (error.status === 429)
      return true;
    if (error.status === 500)
      return true;
    if (error.status === 502)
      return true;
    if (error.status === 503)
      return true;
    if (error.status === 504)
      return true;
    return false;
  }
  return true;
}

// node_modules/viem/_esm/clients/transports/createTransport.js
function createTransport({ key, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
  const uid2 = uid();
  return {
    config: {
      key,
      name,
      request,
      retryCount,
      retryDelay,
      timeout,
      type
    },
    request: buildRequest(request, { retryCount, retryDelay, uid: uid2 }),
    value
  };
}

// node_modules/viem/_esm/clients/transports/fallback.js
function fallback(transports_, config = {}) {
  const { key = "fallback", name = "Fallback", rank = false, retryCount, retryDelay } = config;
  return ({ chain, pollingInterval = 4e3, timeout, ...rest }) => {
    let transports = transports_;
    let onResponse = () => {
    };
    const transport = createTransport({
      key,
      name,
      async request({ method, params }) {
        const fetch2 = async (i3 = 0) => {
          const transport2 = transports[i3]({
            ...rest,
            chain,
            retryCount: 0,
            timeout
          });
          try {
            const response = await transport2.request({
              method,
              params
            });
            onResponse({
              method,
              params,
              response,
              transport: transport2,
              status: "success"
            });
            return response;
          } catch (err) {
            onResponse({
              error: err,
              method,
              params,
              transport: transport2,
              status: "error"
            });
            if (shouldThrow(err))
              throw err;
            if (i3 === transports.length - 1)
              throw err;
            return fetch2(i3 + 1);
          }
        };
        return fetch2();
      },
      retryCount,
      retryDelay,
      type: "fallback"
    }, {
      onResponse: (fn2) => onResponse = fn2,
      transports: transports.map((fn2) => fn2({ chain, retryCount: 0 }))
    });
    if (rank) {
      const rankOptions = typeof rank === "object" ? rank : {};
      rankTransports({
        chain,
        interval: rankOptions.interval ?? pollingInterval,
        onTransports: (transports_2) => transports = transports_2,
        sampleCount: rankOptions.sampleCount,
        timeout: rankOptions.timeout,
        transports,
        weights: rankOptions.weights
      });
    }
    return transport;
  };
}
function shouldThrow(error) {
  if ("code" in error && typeof error.code === "number") {
    if (error.code === TransactionRejectedRpcError.code || error.code === UserRejectedRequestError.code || error.code === 5e3)
      return true;
  }
  return false;
}
function rankTransports({ chain, interval = 4e3, onTransports, sampleCount = 10, timeout = 1e3, transports, weights = {} }) {
  const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
  const samples = [];
  const rankTransports_ = async () => {
    const sample = await Promise.all(transports.map(async (transport) => {
      const transport_ = transport({ chain, retryCount: 0, timeout });
      const start = Date.now();
      let end;
      let success;
      try {
        await transport_.request({ method: "net_listening" });
        success = 1;
      } catch {
        success = 0;
      } finally {
        end = Date.now();
      }
      const latency = end - start;
      return { latency, success };
    }));
    samples.push(sample);
    if (samples.length > sampleCount)
      samples.shift();
    const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
    const scores = transports.map((_3, i3) => {
      const latencies = samples.map((sample2) => sample2[i3].latency);
      const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
      const latencyScore = 1 - meanLatency / maxLatency;
      const successes = samples.map((sample2) => sample2[i3].success);
      const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
      if (stabilityScore === 0)
        return [0, i3];
      return [
        latencyWeight * latencyScore + stabilityWeight * stabilityScore,
        i3
      ];
    }).sort((a5, b3) => b3[0] - a5[0]);
    onTransports(scores.map(([, i3]) => transports[i3]));
    await wait(interval);
    rankTransports_();
  };
  rankTransports_();
}

// node_modules/viem/_esm/errors/transport.js
var UrlRequiredError = class extends BaseError {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro",
      name: "UrlRequiredError"
    });
  }
};

// node_modules/viem/_esm/utils/promise/withTimeout.js
function withTimeout(fn2, { errorInstance = new Error("timed out"), timeout, signal }) {
  return new Promise((resolve, reject) => {
    ;
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        }
        resolve(await fn2({ signal: (controller == null ? void 0 : controller.signal) || null }));
      } catch (err) {
        if ((err == null ? void 0 : err.name) === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}

// node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = createIdStore();

// node_modules/viem/_esm/utils/rpc/http.js
function getHttpRpcClient(url, options = {}) {
  return {
    async request(params) {
      var _a;
      const { body, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 1e4 } = params;
      const fetchOptions = {
        ...options.fetchOptions ?? {},
        ...params.fetchOptions ?? {}
      };
      const { headers, method, signal: signal_ } = fetchOptions;
      try {
        const response = await withTimeout(async ({ signal }) => {
          const init = {
            ...fetchOptions,
            body: Array.isArray(body) ? stringify(body.map((body2) => ({
              jsonrpc: "2.0",
              id: body2.id ?? idCache.take(),
              ...body2
            }))) : stringify({
              jsonrpc: "2.0",
              id: body.id ?? idCache.take(),
              ...body
            }),
            headers: {
              "Content-Type": "application/json",
              ...headers
            },
            method: method || "POST",
            signal: signal_ || (timeout > 0 ? signal : null)
          };
          const request = new Request(url, init);
          const args = await (onRequest == null ? void 0 : onRequest(request, init)) ?? { ...init, url };
          const response2 = await fetch(args.url ?? url, args);
          return response2;
        }, {
          errorInstance: new TimeoutError({ body, url }),
          timeout,
          signal: true
        });
        if (onResponse)
          await onResponse(response);
        let data3;
        if ((_a = response.headers.get("Content-Type")) == null ? void 0 : _a.startsWith("application/json"))
          data3 = await response.json();
        else {
          data3 = await response.text();
          try {
            data3 = JSON.parse(data3 || "{}");
          } catch (err) {
            if (response.ok)
              throw err;
            data3 = { error: data3 };
          }
        }
        if (!response.ok) {
          throw new HttpRequestError({
            body,
            details: stringify(data3.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
        }
        return data3;
      } catch (err) {
        if (err instanceof HttpRequestError)
          throw err;
        if (err instanceof TimeoutError)
          throw err;
        throw new HttpRequestError({
          body,
          cause: err,
          url
        });
      }
    }
  };
}

// node_modules/viem/_esm/clients/transports/http.js
function http(url, config = {}) {
  const { batch, fetchOptions, key = "http", name = "HTTP JSON-RPC", onFetchRequest, onFetchResponse, retryDelay } = config;
  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
    const { batchSize = 1e3, wait: wait2 = 0 } = typeof batch === "object" ? batch : {};
    const retryCount = config.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config.timeout ?? 1e4;
    const url_ = url || (chain == null ? void 0 : chain.rpcUrls.default.http[0]);
    if (!url_)
      throw new UrlRequiredError();
    const rpcClient = getHttpRpcClient(url_, {
      fetchOptions,
      onRequest: onFetchRequest,
      onResponse: onFetchResponse,
      timeout
    });
    return createTransport({
      key,
      name,
      async request({ method, params }) {
        const body = { method, params };
        const { schedule } = createBatchScheduler({
          id: url_,
          wait: wait2,
          shouldSplitBatch(requests) {
            return requests.length > batchSize;
          },
          fn: (body2) => rpcClient.request({
            body: body2
          }),
          sort: (a5, b3) => a5.id - b3.id
        });
        const fn2 = async (body2) => batch ? schedule(body2) : [
          await rpcClient.request({
            body: body2
          })
        ];
        const [{ error, result }] = await fn2(body);
        if (error)
          throw new RpcRequestError({
            body,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "http"
    }, {
      fetchOptions,
      url: url_
    });
  };
}

// node_modules/viem/node_modules/@noble/hashes/esm/ripemd160.js
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = new Uint8Array(new Array(16).fill(0).map((_3, i3) => i3));
var Pi = Id.map((i3) => (9 * i3 + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i3 = 0; i3 < 4; i3++)
  for (let j4 of [idxL, idxR])
    j4.push(j4[i3].map((k3) => Rho[k3]));
var shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i3) => new Uint8Array(i3));
var shiftsL = idxL.map((idx, i3) => idx.map((j4) => shifts[i3][j4]));
var shiftsR = idxR.map((idx, i3) => idx.map((j4) => shifts[i3][j4]));
var Kl = new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr = new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f(group, x4, y6, z4) {
  if (group === 0)
    return x4 ^ y6 ^ z4;
  else if (group === 1)
    return x4 & y6 | ~x4 & z4;
  else if (group === 2)
    return (x4 | ~y6) ^ z4;
  else if (group === 3)
    return x4 & z4 | y6 & ~z4;
  else
    return x4 ^ (y6 | ~z4);
}
var R_BUF = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2: h22, h3: h32, h4 } = this;
    return [h0, h1, h22, h32, h4];
  }
  set(h0, h1, h22, h32, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h22 | 0;
    this.h3 = h32 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i3 = 0; i3 < 16; i3++, offset += 4)
      R_BUF[i3] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar2 = al, bl = this.h1 | 0, br2 = bl, cl = this.h2 | 0, cr2 = cl, dl = this.h3 | 0, dr3 = dl, el = this.h4 | 0, er3 = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr3 = idxR[group];
      const sl = shiftsL[group], sr2 = shiftsR[group];
      for (let i3 = 0; i3 < 16; i3++) {
        const tl = rotl(al + f(group, bl, cl, dl) + R_BUF[rl[i3]] + hbl, sl[i3]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i3 = 0; i3 < 16; i3++) {
        const tr2 = rotl(ar2 + f(rGroup, br2, cr2, dr3) + R_BUF[rr3[i3]] + hbr, sr2[i3]) + er3 | 0;
        ar2 = er3, er3 = dr3, dr3 = rotl(cr2, 10) | 0, cr2 = br2, br2 = tr2;
      }
    }
    this.set(this.h1 + cl + dr3 | 0, this.h2 + dl + er3 | 0, this.h3 + el + ar2 | 0, this.h4 + al + br2 | 0, this.h0 + bl + cr2 | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = wrapConstructor(() => new RIPEMD160());

// node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager = createNonceManager({
  source: jsonRpc()
});

// node_modules/@reown/appkit-utils/dist/esm/src/CaipNetworkUtil.js
var RPC_URL_HOST = "rpc.walletconnect.org";
function getBlockchainApiRpcUrl(caipNetworkId, projectId) {
  const url = new URL("https://rpc.walletconnect.org/v1/");
  url.searchParams.set("chainId", caipNetworkId);
  url.searchParams.set("projectId", projectId);
  return url.toString();
}
var WC_HTTP_RPC_SUPPORTED_CHAINS = [
  "near:mainnet",
  "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  "eip155:1101",
  "eip155:56",
  "eip155:42161",
  "eip155:7777777",
  "eip155:59144",
  "eip155:324",
  "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  "eip155:5000",
  "solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz",
  "eip155:80084",
  "eip155:5003",
  "eip155:100",
  "eip155:8453",
  "eip155:42220",
  "eip155:1313161555",
  "eip155:17000",
  "eip155:1",
  "eip155:300",
  "eip155:1313161554",
  "eip155:1329",
  "eip155:84532",
  "eip155:421614",
  "eip155:11155111",
  "eip155:8217",
  "eip155:43114",
  "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  "eip155:999999999",
  "eip155:11155420",
  "eip155:80002",
  "eip155:97",
  "eip155:43113",
  "eip155:137",
  "eip155:10",
  "eip155:1301"
];
var CaipNetworksUtil = {
  extendRpcUrlWithProjectId(rpcUrl, projectId) {
    let isReownUrl = false;
    try {
      const url = new URL(rpcUrl);
      isReownUrl = url.host === RPC_URL_HOST;
    } catch (e2) {
      isReownUrl = false;
    }
    if (isReownUrl) {
      const url = new URL(rpcUrl);
      if (!url.searchParams.has("projectId")) {
        url.searchParams.set("projectId", projectId);
      }
      return url.toString();
    }
    return rpcUrl;
  },
  isCaipNetwork(network) {
    return "chainNamespace" in network && "caipNetworkId" in network;
  },
  getChainNamespace(network) {
    if (this.isCaipNetwork(network)) {
      return network.chainNamespace;
    }
    return ConstantsUtil.CHAIN.EVM;
  },
  getCaipNetworkId(network) {
    if (this.isCaipNetwork(network)) {
      return network.caipNetworkId;
    }
    return `${ConstantsUtil.CHAIN.EVM}:${network.id}`;
  },
  getRpcUrl(caipNetwork, caipNetworkId, projectId) {
    var _a, _b, _c;
    const defaultRpcUrl = (_c = (_b = (_a = caipNetwork.rpcUrls) == null ? void 0 : _a.default) == null ? void 0 : _b.http) == null ? void 0 : _c[0];
    if (WC_HTTP_RPC_SUPPORTED_CHAINS.includes(caipNetworkId)) {
      return getBlockchainApiRpcUrl(caipNetworkId, projectId);
    }
    return defaultRpcUrl || "";
  },
  extendCaipNetwork(caipNetwork, { customNetworkImageUrls, projectId }) {
    const caipNetworkId = this.getCaipNetworkId(caipNetwork);
    const chainNamespace = this.getChainNamespace(caipNetwork);
    const rpcUrl = this.getRpcUrl(caipNetwork, caipNetworkId, projectId);
    return {
      ...caipNetwork,
      chainNamespace,
      caipNetworkId,
      assets: {
        imageId: PresetsUtil.NetworkImageIds[caipNetwork.id],
        imageUrl: customNetworkImageUrls == null ? void 0 : customNetworkImageUrls[caipNetwork.id]
      },
      rpcUrls: {
        ...caipNetwork.rpcUrls,
        default: {
          http: [rpcUrl]
        }
      }
    };
  },
  extendCaipNetworks(caipNetworks, { customNetworkImageUrls, projectId }) {
    return caipNetworks.map((caipNetwork) => CaipNetworksUtil.extendCaipNetwork(caipNetwork, {
      customNetworkImageUrls,
      projectId
    }));
  },
  getViemTransport(caipNetwork) {
    var _a;
    const chainDefaultUrl = (_a = caipNetwork.rpcUrls.default.http) == null ? void 0 : _a[0];
    if (!WC_HTTP_RPC_SUPPORTED_CHAINS.includes(caipNetwork.caipNetworkId)) {
      return http(chainDefaultUrl);
    }
    return fallback([
      http(chainDefaultUrl, {
        fetchOptions: {
          headers: {
            "Content-Type": "text/plain"
          }
        }
      }),
      http(chainDefaultUrl)
    ]);
  }
};

// node_modules/@reown/appkit-utils/dist/esm/src/TypeUtil.js
var SocialProviderEnum;
(function(SocialProviderEnum2) {
  SocialProviderEnum2["Google"] = "google";
  SocialProviderEnum2["Github"] = "github";
  SocialProviderEnum2["Apple"] = "apple";
  SocialProviderEnum2["Facebook"] = "facebook";
  SocialProviderEnum2["X"] = "x";
  SocialProviderEnum2["Discord"] = "discord";
  SocialProviderEnum2["Farcaster"] = "farcaster";
})(SocialProviderEnum || (SocialProviderEnum = {}));

// node_modules/valtio/esm/react.mjs
var import_react = __toESM(require_react(), 1);
var import_shim = __toESM(require_shim(), 1);
var { use } = import_react.default;
var { useSyncExternalStore } = import_shim.default;
var useAffectedDebugValue = (state3, affected) => {
  const pathList = (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    pathList.current = w(state3, affected, true);
  });
  (0, import_react.useDebugValue)(pathList.current);
};
var targetCache = /* @__PURE__ */ new WeakMap();
function useSnapshot(proxyObject, options) {
  const notifyInSync = options == null ? void 0 : options.sync;
  const lastSnapshot = (0, import_react.useRef)();
  const lastAffected = (0, import_react.useRef)();
  let inRender = true;
  const currSnapshot = useSyncExternalStore(
    (0, import_react.useCallback)(
      (callback) => {
        const unsub = subscribe(proxyObject, callback, notifyInSync);
        callback();
        return unsub;
      },
      [proxyObject, notifyInSync]
    ),
    () => {
      const nextSnapshot = snapshot(proxyObject, use);
      try {
        if (!inRender && lastSnapshot.current && lastAffected.current && !p(
          lastSnapshot.current,
          nextSnapshot,
          lastAffected.current,
          /* @__PURE__ */ new WeakMap()
        )) {
          return lastSnapshot.current;
        }
      } catch (e2) {
      }
      return nextSnapshot;
    },
    () => snapshot(proxyObject, use)
  );
  inRender = false;
  const currAffected = /* @__PURE__ */ new WeakMap();
  (0, import_react.useEffect)(() => {
    lastSnapshot.current = currSnapshot;
    lastAffected.current = currAffected;
  });
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
    useAffectedDebugValue(currSnapshot, currAffected);
  }
  const proxyCache = (0, import_react.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);
  return a(
    currSnapshot,
    currAffected,
    proxyCache,
    targetCache
  );
}

// node_modules/@reown/appkit/dist/esm/src/adapters/ChainAdapterBlueprint.js
var AdapterBlueprint = class {
  /**
   * Creates an instance of AdapterBlueprint.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  constructor(params) {
    this.availableConnectors = [];
    this.eventListeners = /* @__PURE__ */ new Map();
    if (params) {
      this.construct(params);
    }
  }
  /**
   * Initializes the adapter with the given parameters.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  construct(params) {
    this.caipNetworks = params.networks;
    this.projectId = params.projectId;
    this.namespace = params.namespace;
  }
  /**
   * Gets the available connectors.
   * @returns {Connector[]} An array of available connectors
   */
  get connectors() {
    return this.availableConnectors;
  }
  /**
   * Gets the supported networks.
   * @returns {CaipNetwork[]} An array of supported networks
   */
  get networks() {
    return this.caipNetworks || [];
  }
  /**
   * Sets the universal provider for WalletConnect.
   * @param {UniversalProvider} universalProvider - The universal provider instance
   */
  setUniversalProvider(universalProvider) {
    this.addConnector({
      id: ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID,
      type: "WALLET_CONNECT",
      name: PresetsUtil.ConnectorNamesMap[ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID],
      provider: universalProvider,
      imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID],
      chain: this.namespace,
      chains: []
    });
  }
  /**
   * Sets the auth provider.
   * @param {W3mFrameProvider} authProvider - The auth provider instance
   */
  setAuthProvider(authProvider) {
    this.addConnector({
      id: ConstantsUtil3.AUTH_CONNECTOR_ID,
      type: "AUTH",
      name: "Auth",
      provider: authProvider,
      imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil3.AUTH_CONNECTOR_ID],
      chain: this.namespace,
      chains: []
    });
  }
  /**
   * Adds one or more connectors to the available connectors list.
   * @param {...Connector} connectors - The connectors to add
   */
  addConnector(...connectors) {
    var _a, _b;
    if (connectors.some((connector) => connector.id === "ID_AUTH")) {
      const authConnector = connectors.find((connector) => connector.id === "ID_AUTH");
      const optionsState = snapshot(OptionsController.state);
      const themeMode = ThemeController.getSnapshot().themeMode;
      const themeVariables = ThemeController.getSnapshot().themeVariables;
      (_b = (_a = authConnector == null ? void 0 : authConnector.provider) == null ? void 0 : _a.syncDappData) == null ? void 0 : _b.call(_a, {
        metadata: optionsState.metadata,
        sdkVersion: optionsState.sdkVersion,
        projectId: optionsState.projectId,
        sdkType: optionsState.sdkType
      });
      authConnector.provider.syncTheme({
        themeMode,
        themeVariables,
        w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
      });
    }
    this.availableConnectors = [
      ...this.availableConnectors.filter((existing) => !connectors.some((newConnector) => newConnector.id === existing.id)),
      ...connectors
    ];
  }
  /**
   * Adds an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be called when the event is emitted
   */
  on(eventName, callback) {
    var _a;
    if (!this.eventListeners.has(eventName)) {
      this.eventListeners.set(eventName, /* @__PURE__ */ new Set());
    }
    (_a = this.eventListeners.get(eventName)) == null ? void 0 : _a.add(callback);
  }
  /**
   * Removes an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be removed
   */
  off(eventName, callback) {
    const listeners = this.eventListeners.get(eventName);
    if (listeners) {
      listeners.delete(callback);
    }
  }
  /**
   * Emits an event with the given name and optional data.
   * @template T
   * @param {T} eventName - The name of the event to emit
   * @param {EventData[T]} [data] - The optional data to be passed to the event listeners
   */
  emit(eventName, data3) {
    const listeners = this.eventListeners.get(eventName);
    if (listeners) {
      listeners.forEach((callback) => callback(data3));
    }
  }
};

// node_modules/@reown/appkit/dist/esm/src/universal-adapter/client.js
var UniversalAdapter = class extends AdapterBlueprint {
  async connectWalletConnect(onUri) {
    const connector = this.connectors.find((c5) => c5.type === "WALLET_CONNECT");
    const provider = connector == null ? void 0 : connector.provider;
    if (!this.caipNetworks || !provider) {
      throw new Error("UniversalAdapter:connectWalletConnect - caipNetworks or provider is undefined");
    }
    provider.on("display_uri", (uri) => {
      onUri(uri);
    });
    const namespaces = WcHelpersUtil.createNamespaces(this.caipNetworks);
    await provider.connect({ optionalNamespaces: namespaces });
  }
  async connect(params) {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: Number(params.chainId),
      provider: this.provider,
      address: ""
    });
  }
  async disconnect() {
    const connector = this.connectors.find((c5) => c5.id === "WALLET_CONNECT");
    const provider = connector == null ? void 0 : connector.provider;
    await (provider == null ? void 0 : provider.disconnect());
  }
  async syncConnectors() {
    return Promise.resolve();
  }
  async getBalance() {
    return Promise.resolve({
      balance: "0",
      decimals: 0,
      symbol: ""
    });
  }
  async signMessage(params) {
    const { provider, message, address } = params;
    if (!provider) {
      throw new Error("UniversalAdapter:signMessage - provider is undefined");
    }
    const signature = await provider.request({
      method: "personal_sign",
      params: [message, address]
    });
    return { signature };
  }
  // -- Transaction methods ---------------------------------------------------
  /**
   *
   * These methods are supported only on `wagmi` and `ethers` since the Solana SDK does not support them in the same way.
   * These function definition is to have a type parity between the clients. Currently not in use.
   */
  async estimateGas() {
    return Promise.resolve({
      gas: BigInt(0)
    });
  }
  async getProfile() {
    return Promise.resolve({
      profileImage: "",
      profileName: ""
    });
  }
  async sendTransaction() {
    return Promise.resolve({
      hash: ""
    });
  }
  async writeContract() {
    return Promise.resolve({
      hash: ""
    });
  }
  async getEnsAddress() {
    return Promise.resolve({
      address: false
    });
  }
  parseUnits() {
    return 0n;
  }
  formatUnits() {
    return "0";
  }
  async getCapabilities() {
    return Promise.resolve({});
  }
  async grantPermissions() {
    return Promise.resolve({});
  }
  async revokePermissions() {
    return Promise.resolve("0x");
  }
  async syncConnection() {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: 1,
      provider: this.provider,
      address: ""
    });
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async switchNetwork(params) {
    const { caipNetwork } = params;
    const connector = this.connectors.find((c5) => c5.type === "WALLET_CONNECT");
    const provider = connector == null ? void 0 : connector.provider;
    if (!provider) {
      throw new Error("UniversalAdapter:switchNetwork - provider is undefined");
    }
    provider.setDefaultChain(`${caipNetwork.chainNamespace}:${String(caipNetwork.id)}`);
  }
  getWalletConnectProvider() {
    const connector = this.connectors.find((c5) => c5.type === "WALLET_CONNECT");
    const provider = connector == null ? void 0 : connector.provider;
    return provider;
  }
};

// node_modules/@reown/appkit/dist/esm/src/store/ProviderUtil.js
var state2 = proxy({
  providers: { eip155: void 0, solana: void 0, polkadot: void 0 },
  providerIds: { eip155: void 0, solana: void 0, polkadot: void 0 }
});
var ProviderUtil = {
  state: state2,
  subscribeKey(key, callback) {
    return subscribeKey(state2, key, callback);
  },
  subscribeProviders(callback) {
    return subscribe(state2.providers, () => callback(state2.providers));
  },
  setProvider(chainNamespace, provider) {
    if (provider) {
      state2.providers[chainNamespace] = ref(provider);
    }
  },
  getProvider(chainNamespace) {
    return state2.providers[chainNamespace];
  },
  setProviderId(chainNamespace, providerId) {
    if (providerId) {
      state2.providerIds[chainNamespace] = providerId;
    }
  },
  getProviderId(chainNamespace) {
    return state2.providerIds[chainNamespace];
  },
  reset() {
    state2.providers = { eip155: void 0, solana: void 0, polkadot: void 0 };
    state2.providerIds = { eip155: void 0, solana: void 0, polkadot: void 0 };
  },
  resetChain(chainNamespace) {
    state2.providers[chainNamespace] = void 0;
    state2.providerIds[chainNamespace] = void 0;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_events7 = __toESM(require_events());

// node_modules/@walletconnect/heartbeat/dist/index.es.js
var import_events = __toESM(require_events());
var import_time = __toESM(require_cjs());

// node_modules/@walletconnect/events/dist/esm/events.js
var IEvents = class {
};

// node_modules/@walletconnect/heartbeat/dist/index.es.js
var n = class extends IEvents {
  constructor(e2) {
    super();
  }
};
var s = import_time.FIVE_SECONDS;
var r = { pulse: "heartbeat_pulse" };
var i = class _i2 extends n {
  constructor(e2) {
    super(e2), this.events = new import_events.EventEmitter(), this.interval = s, this.interval = (e2 == null ? void 0 : e2.interval) || s;
  }
  static async init(e2) {
    const t = new _i2(e2);
    return await t.init(), t;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e2, t) {
    this.events.on(e2, t);
  }
  once(e2, t) {
    this.events.once(e2, t);
  }
  off(e2, t) {
    this.events.off(e2, t);
  }
  removeListener(e2, t) {
    this.events.removeListener(e2, t);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), (0, import_time.toMiliseconds)(this.interval));
  }
  pulse() {
    this.events.emit(r.pulse);
  }
};

// node_modules/destr/dist/index.mjs
var suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
var JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  const _value = value.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    value[0] === '"' && value.endsWith('"') && !value.includes("\\")
  ) {
    return _value.slice(1, -1);
  }
  if (_value.length <= 9) {
    const _lval = _value.toLowerCase();
    if (_lval === "true") {
      return true;
    }
    if (_lval === "false") {
      return false;
    }
    if (_lval === "undefined") {
      return void 0;
    }
    if (_lval === "null") {
      return null;
    }
    if (_lval === "nan") {
      return Number.NaN;
    }
    if (_lval === "infinity") {
      return Number.POSITIVE_INFINITY;
    }
    if (_lval === "-infinity") {
      return Number.NEGATIVE_INFINITY;
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

// node_modules/unstorage/dist/shared/unstorage.d569726e.mjs
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify2(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify2(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
function checkBufferSupport() {
  if (typeof Buffer === "undefined") {
    throw new TypeError("[unstorage] Buffer is not supported!");
  }
}
var BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  checkBufferSupport();
  const base64 = Buffer.from(value).toString("base64");
  return BASE64_PREFIX + base64;
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  checkBufferSupport();
  return Buffer.from(value.slice(BASE64_PREFIX.length), "base64");
}
function normalizeKey(key) {
  if (!key) {
    return "";
  }
  return key.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "");
}
function joinKeys(...keys2) {
  return normalizeKey(keys2.join(":"));
}
function normalizeBaseKey(base) {
  base = normalizeKey(base);
  return base ? base + ":" : "";
}

// node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data3 = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => data3,
    hasItem(key) {
      return data3.has(key);
    },
    getItem(key) {
      return data3.get(key) ?? null;
    },
    getItemRaw(key) {
      return data3.get(key) ?? null;
    },
    setItem(key, value) {
      data3.set(key, value);
    },
    setItemRaw(key, value) {
      data3.set(key, value);
    },
    removeItem(key) {
      data3.delete(key);
    },
    getKeys() {
      return [...data3.keys()];
    },
    clear() {
      data3.clear();
    },
    dispose() {
      data3.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base of context.mountpoints) {
      if (key.startsWith(base)) {
        return {
          base,
          relativeKey: key.slice(base.length),
          driver: context.mounts[base]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r3) => r3.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r3) => r3.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify2(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify2(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify2(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base, opts = {}) {
      base = normalizeBaseKey(base);
      const mounts = getMounts(base, true);
      let maskedMounts = [];
      const allKeys = [];
      for (const mount of mounts) {
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey(key);
          if (!maskedMounts.some((p4) => fullKey.startsWith(p4))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p4) => !p4.startsWith(mount.mountpoint))
        ];
      }
      return base ? allKeys.filter(
        (key) => key.startsWith(base) && key[key.length - 1] !== "$"
      ) : allKeys.filter((key) => key[key.length - 1] !== "$");
    },
    // Utils
    async clear(base, opts = {}) {
      base = normalizeBaseKey(base);
      await Promise.all(
        getMounts(base, false).map(async (m2) => {
          if (m2.driver.clear) {
            return asyncCall(m2.driver.clear, m2.relativeBase, opts);
          }
          if (m2.driver.removeItem) {
            const keys2 = await m2.driver.getKeys(m2.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key) => m2.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base, driver) {
      base = normalizeBaseKey(base);
      if (base && context.mounts[base]) {
        throw new Error(`already mounted at ${base}`);
      }
      if (base) {
        context.mountpoints.push(base);
        context.mountpoints.sort((a5, b3) => b3.length - a5.length);
      }
      context.mounts[base] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {
          context.unwatch[base] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base, _dispose = true) {
      base = normalizeBaseKey(base);
      if (!base || !context.mounts[base]) {
        return;
      }
      if (context.watching && base in context.unwatch) {
        context.unwatch[base]();
        delete context.unwatch[base];
      }
      if (_dispose) {
        await dispose(context.mounts[base]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base);
      delete context.mounts[base];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m2 = getMount(key);
      return {
        driver: m2.driver,
        base: m2.base
      };
    },
    getMounts(base = "", opts = {}) {
      base = normalizeKey(base);
      const mounts = getMounts(base, opts.parents);
      return mounts.map((m2) => ({
        driver: m2.driver,
        base: m2.mountpoint
      }));
    },
    // Aliases
    keys: (base, opts = {}) => storage.getKeys(base, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch(driver, onChange, base) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

// node_modules/idb-keyval/dist/index.js
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  const request = indexedDB.open(dbName);
  request.onupgradeneeded = () => request.result.createObjectStore(storeName);
  const dbp = promisifyRequest(request);
  return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
function eachCursor(store, callback) {
  store.openCursor().onsuccess = function() {
    if (!this.result)
      return;
    callback(this.result);
    this.result.continue();
  };
  return promisifyRequest(store.transaction);
}
function keys(customStore = defaultGetStore()) {
  return customStore("readonly", (store) => {
    if (store.getAllKeys) {
      return promisifyRequest(store.getAllKeys());
    }
    const items = [];
    return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
  });
}

// node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x = "idb-keyval";
var z = (i3 = {}) => {
  const t = i3.base && i3.base.length > 0 ? `${i3.base}:` : "", e2 = (s2) => t + s2;
  let n4;
  return i3.dbName && i3.storeName && (n4 = createStore(i3.dbName, i3.storeName)), { name: x, options: i3, async hasItem(s2) {
    return !(typeof await get(e2(s2), n4) > "u");
  }, async getItem(s2) {
    return await get(e2(s2), n4) ?? null;
  }, setItem(s2, a5) {
    return set(e2(s2), a5, n4);
  }, removeItem(s2) {
    return del(e2(s2), n4);
  }, getKeys() {
    return keys(n4);
  }, clear() {
    return clear(n4);
  } };
};
var D = "WALLET_CONNECT_V2_INDEXED_DB";
var E2 = "keyvaluestorage";
var _ = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z({ dbName: D, storeName: E2 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const e2 = await this.indexedDb.getItem(t);
    if (e2 !== null) return e2;
  }
  async setItem(t, e2) {
    await this.indexedDb.setItem(t, safeJsonStringify(e2));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c = { exports: {} };
(function() {
  let i3;
  function t() {
  }
  i3 = t, i3.prototype.getItem = function(e2) {
    return this.hasOwnProperty(e2) ? String(this[e2]) : null;
  }, i3.prototype.setItem = function(e2, n4) {
    this[e2] = String(n4);
  }, i3.prototype.removeItem = function(e2) {
    delete this[e2];
  }, i3.prototype.clear = function() {
    const e2 = this;
    Object.keys(e2).forEach(function(n4) {
      e2[n4] = void 0, delete e2[n4];
    });
  }, i3.prototype.key = function(e2) {
    return e2 = e2 || 0, Object.keys(this)[e2];
  }, i3.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l2 < "u" && l2.localStorage ? c.exports = l2.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t();
})();
function k2(i3) {
  var t;
  return [i3[0], safeJsonParse((t = i3[1]) != null ? t : "")];
}
var K = class {
  constructor() {
    this.localStorage = c.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k2);
  }
  async getItem(t) {
    const e2 = this.localStorage.getItem(t);
    if (e2 !== null) return safeJsonParse(e2);
  }
  async setItem(t, e2) {
    this.localStorage.setItem(t, safeJsonStringify(e2));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
var N = "wc_storage_version";
var y2 = 1;
var O = async (i3, t, e2) => {
  const n4 = N, s2 = await t.getItem(n4);
  if (s2 && s2 >= y2) {
    e2(t);
    return;
  }
  const a5 = await i3.getKeys();
  if (!a5.length) {
    e2(t);
    return;
  }
  const m2 = [];
  for (; a5.length; ) {
    const r3 = a5.shift();
    if (!r3) continue;
    const o5 = r3.toLowerCase();
    if (o5.includes("wc@") || o5.includes("walletconnect") || o5.includes("wc_") || o5.includes("wallet_connect")) {
      const f4 = await i3.getItem(r3);
      await t.setItem(r3, f4), m2.push(r3);
    }
  }
  await t.setItem(n4, y2), e2(t), j(i3, m2);
};
var j = async (i3, t) => {
  t.length && t.forEach(async (e2) => {
    await i3.removeItem(e2);
  });
};
var h = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e2) => {
      this.storage = e2, this.initialized = true;
    };
    const t = new K();
    this.storage = t;
    try {
      const e2 = new _();
      O(t, e2, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, e2) {
    return await this.initialize(), this.storage.setItem(t, e2);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const e2 = setInterval(() => {
        this.initialized && (clearInterval(e2), t());
      }, 20);
    });
  }
};

// node_modules/@walletconnect/types/dist/index.es.js
var import_events4 = __toESM(require_events());
var n2 = class extends IEvents {
  constructor(s2) {
    super(), this.opts = s2, this.protocol = "wc", this.version = 2;
  }
};
var h2 = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a3 = class {
  constructor(s2, t) {
    this.logger = s2, this.core = t;
  }
};
var g = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var u = class extends IEvents {
  constructor(s2) {
    super();
  }
};
var p2 = class {
  constructor(s2, t, e2, f4) {
    this.core = s2, this.logger = t, this.name = e2;
  }
};
var d = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var x2 = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t;
  }
};
var y3 = class {
  constructor(s2, t, e2) {
    this.core = s2, this.logger = t, this.store = e2;
  }
};
var v = class {
  constructor(s2, t) {
    this.projectId = s2, this.logger = t;
  }
};
var C = class {
  constructor(s2, t, e2) {
    this.core = s2, this.logger = t, this.telemetryEnabled = e2;
  }
};
var S = class {
  constructor(s2) {
    this.opts = s2, this.protocol = "wc", this.version = 2;
  }
};
var M = class {
  constructor(s2) {
    this.client = s2;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs());

// node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
var import_events5 = __toESM(require_events());

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DEFAULT_ERROR: () => DEFAULT_ERROR,
  IBaseJsonRpcProvider: () => n3,
  IEvents: () => e,
  IJsonRpcConnection: () => o2,
  IJsonRpcProvider: () => r2,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getBigIntRpcId: () => getBigIntRpcId,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
var PARSE_ERROR = "PARSE_ERROR";
var INVALID_REQUEST = "INVALID_REQUEST";
var METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
var INVALID_PARAMS = "INVALID_PARAMS";
var INTERNAL_ERROR = "INTERNAL_ERROR";
var SERVER_ERROR = "SERVER_ERROR";
var RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
var SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
var STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
};
var DEFAULT_ERROR = SERVER_ERROR;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
function isServerErrorCode(code) {
  return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code) {
  return RESERVED_ERROR_CODES.includes(code);
}
function isValidErrorCode(code) {
  return typeof code === "number";
}
function getError(type) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type];
}
function getErrorByCode(code) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e2) => e2.code === code);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error = getErrorByCode(response.error.code);
    if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e2, url, type) {
  return e2.message.includes("getaddrinfo ENOTFOUND") || e2.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e2;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
var import_environment = __toESM(require_cjs2());
__reExport(env_exports, __toESM(require_cjs2()));
var isNodeJs = import_environment.isNode;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
__reExport(esm_exports, env_exports);

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
function payloadId(entropy = 3) {
  const date = Date.now() * Math.pow(10, entropy);
  const extra = Math.floor(Math.random() * Math.pow(10, entropy));
  return date + extra;
}
function getBigIntRpcId(entropy = 6) {
  return BigInt(payloadId(entropy));
}
function formatJsonRpcRequest(method, params, id) {
  return {
    id: id || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id, result) {
  return {
    id,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id, error, data3) {
  return {
    id,
    jsonrpc: "2.0",
    error: formatErrorMessage(error, data3)
  };
}
function formatErrorMessage(error, data3) {
  if (typeof error === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
  }
  if (typeof data3 !== "undefined") {
    error.data = data3;
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x4) => x4.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}

// node_modules/@walletconnect/jsonrpc-types/dist/index.es.js
var e = class {
};
var o2 = class extends e {
  constructor(c5) {
    super();
  }
};
var n3 = class extends e {
  constructor() {
    super();
  }
};
var r2 = class extends n3 {
  constructor(c5) {
    super();
  }
};

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
var HTTP_REGEX = "^https?:";
var WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}

// node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
var o3 = class extends r2 {
  constructor(t) {
    super(t), this.events = new import_events5.EventEmitter(), this.hasRegisteredEventListeners = false, this.connection = this.setConnection(t), this.connection.connected && this.registerEventListeners();
  }
  async connect(t = this.connection) {
    await this.open(t);
  }
  async disconnect() {
    await this.close();
  }
  on(t, e2) {
    this.events.on(t, e2);
  }
  once(t, e2) {
    this.events.once(t, e2);
  }
  off(t, e2) {
    this.events.off(t, e2);
  }
  removeListener(t, e2) {
    this.events.removeListener(t, e2);
  }
  async request(t, e2) {
    return this.requestStrict(formatJsonRpcRequest(t.method, t.params || [], t.id || getBigIntRpcId().toString()), e2);
  }
  async requestStrict(t, e2) {
    return new Promise(async (i3, s2) => {
      if (!this.connection.connected) try {
        await this.open();
      } catch (n4) {
        s2(n4);
      }
      this.events.on(`${t.id}`, (n4) => {
        isJsonRpcError(n4) ? s2(n4.error) : i3(n4.result);
      });
      try {
        await this.connection.send(t, e2);
      } catch (n4) {
        s2(n4);
      }
    });
  }
  setConnection(t = this.connection) {
    return t;
  }
  onPayload(t) {
    this.events.emit("payload", t), isJsonRpcResponse(t) ? this.events.emit(`${t.id}`, t) : this.events.emit("message", { type: t.method, data: t.params });
  }
  onClose(t) {
    t && t.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t.code} ${t.reason ? `(${t.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(t = this.connection) {
    this.connection === t && this.connection.connected || (this.connection.connected && this.close(), typeof t == "string" && (await this.connection.open(t), t = this.connection), this.connection = this.setConnection(t), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (t) => this.onPayload(t)), this.connection.on("close", (t) => this.onClose(t)), this.connection.on("error", (t) => this.events.emit("error", t)), this.connection.on("register_error", (t) => this.onClose()), this.hasRegisteredEventListeners = true);
  }
};

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
var import_events6 = __toESM(require_events());
var w2 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser();
var b = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
var a4 = (c5) => c5.split("?")[0];
var h3 = 10;
var S2 = w2();
var f2 = class {
  constructor(e2) {
    if (this.url = e2, this.events = new import_events6.EventEmitter(), this.registering = false, !isWsUrl(e2)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e2}`);
    this.url = e2;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e2, t) {
    this.events.on(e2, t);
  }
  once(e2, t) {
    this.events.once(e2, t);
  }
  off(e2, t) {
    this.events.off(e2, t);
  }
  removeListener(e2, t) {
    this.events.removeListener(e2, t);
  }
  async open(e2 = this.url) {
    await this.register(e2);
  }
  async close() {
    return new Promise((e2, t) => {
      if (typeof this.socket > "u") {
        t(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n4) => {
        this.onClose(n4), e2();
      }, this.socket.close();
    });
  }
  async send(e2) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e2));
    } catch (t) {
      this.onError(e2.id, t);
    }
  }
  register(e2 = this.url) {
    if (!isWsUrl(e2)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e2}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n4, o5) => {
        this.events.once("register_error", (s2) => {
          this.resetMaxListeners(), o5(s2);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return o5(new Error("WebSocket connection is missing or invalid"));
          n4(this.socket);
        });
      });
    }
    return this.url = e2, this.registering = true, new Promise((t, n4) => {
      const o5 = new URLSearchParams(e2).get("origin"), s2 = (0, esm_exports.isReactNative)() ? { headers: { origin: o5 } } : { rejectUnauthorized: !isLocalhostUrl(e2) }, i3 = new S2(e2, [], s2);
      b() ? i3.onerror = (r3) => {
        const l4 = r3;
        n4(this.emitError(l4.error));
      } : i3.on("error", (r3) => {
        n4(this.emitError(r3));
      }), i3.onopen = () => {
        this.onOpen(i3), t(i3);
      };
    });
  }
  onOpen(e2) {
    e2.onmessage = (t) => this.onPayload(t), e2.onclose = (t) => this.onClose(t), this.socket = e2, this.registering = false, this.events.emit("open");
  }
  onClose(e2) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e2);
  }
  onPayload(e2) {
    if (typeof e2.data > "u") return;
    const t = typeof e2.data == "string" ? safeJsonParse(e2.data) : e2.data;
    this.events.emit("payload", t);
  }
  onError(e2, t) {
    const n4 = this.parseError(t), o5 = n4.message || n4.toString(), s2 = formatJsonRpcError(e2, o5);
    this.events.emit("payload", s2);
  }
  parseError(e2, t = this.url) {
    return parseConnectionError(e2, a4(t), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h3 && this.events.setMaxListeners(h3);
  }
  emitError(e2) {
    const t = this.parseError(new Error((e2 == null ? void 0 : e2.message) || `WebSocket connection failed for host: ${a4(this.url)}`));
    return this.events.emit("register_error", t), t;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_lodash = __toESM(require_lodash());
var be = "wc";
var fe = 2;
var ne = "core";
var O2 = `${be}@2:${ne}:`;
var Xe = { name: ne, logger: "error" };
var Ze2 = { database: ":memory:" };
var Qe = "crypto";
var _e = "client_ed25519_seed";
var et = import_time2.ONE_DAY;
var tt = "keychain";
var it = "0.3";
var st = "messages";
var rt = "0.3";
var nt = import_time2.SIX_HOURS;
var ot = "publisher";
var at = "irn";
var ct = "error";
var Ee = "wss://relay.walletconnect.org";
var ht = "relayer";
var w3 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var lt = "_subscription";
var T = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var ut = 0.1;
var oe = "2.17.0";
var F = { link_mode: "link_mode", relay: "relay" };
var dt = "0.3";
var gt = "WALLETCONNECT_CLIENT_ID";
var ve = "WALLETCONNECT_LINK_MODE_APPS";
var A2 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var pt = "subscription";
var yt = "0.3";
var Dt = import_time2.FIVE_SECONDS * 1e3;
var mt = "pairing";
var bt = "0.3";
var j2 = { wc_pairingDelete: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 } } };
var q = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var P = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var ft = "history";
var _t = "0.3";
var Et = "expirer";
var R = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var vt = "0.3";
var wt = "verify-api";
var Is2 = "https://verify.walletconnect.com";
var It = "https://verify.walletconnect.org";
var Z = It;
var Tt = `${Z}/v3`;
var Ct = [Is2, It];
var St = "echo";
var Pt = "https://echo.walletconnect.com";
var z2 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var M2 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var Cs = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var Ss2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var Ps = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var Rs = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var Rt = 0.1;
var xt = "event-client";
var Ot = 86400;
var At = "https://pulse.walletconnect.org/batch";
function xs2(o5, e2) {
  if (o5.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), s2 = 0; s2 < t.length; s2++) t[s2] = 255;
  for (var i3 = 0; i3 < o5.length; i3++) {
    var r3 = o5.charAt(i3), n4 = r3.charCodeAt(0);
    if (t[n4] !== 255) throw new TypeError(r3 + " is ambiguous");
    t[n4] = i3;
  }
  var a5 = o5.length, c5 = o5.charAt(0), h4 = Math.log(a5) / Math.log(256), d3 = Math.log(256) / Math.log(a5);
  function g3(l4) {
    if (l4 instanceof Uint8Array || (ArrayBuffer.isView(l4) ? l4 = new Uint8Array(l4.buffer, l4.byteOffset, l4.byteLength) : Array.isArray(l4) && (l4 = Uint8Array.from(l4))), !(l4 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (l4.length === 0) return "";
    for (var p4 = 0, E4 = 0, D3 = 0, f4 = l4.length; D3 !== f4 && l4[D3] === 0; ) D3++, p4++;
    for (var N2 = (f4 - D3) * d3 + 1 >>> 0, C2 = new Uint8Array(N2); D3 !== f4; ) {
      for (var L2 = l4[D3], $2 = 0, x4 = N2 - 1; (L2 !== 0 || $2 < E4) && x4 !== -1; x4--, $2++) L2 += 256 * C2[x4] >>> 0, C2[x4] = L2 % a5 >>> 0, L2 = L2 / a5 >>> 0;
      if (L2 !== 0) throw new Error("Non-zero carry");
      E4 = $2, D3++;
    }
    for (var k3 = N2 - E4; k3 !== N2 && C2[k3] === 0; ) k3++;
    for (var ie = c5.repeat(p4); k3 < N2; ++k3) ie += o5.charAt(C2[k3]);
    return ie;
  }
  function m2(l4) {
    if (typeof l4 != "string") throw new TypeError("Expected String");
    if (l4.length === 0) return new Uint8Array();
    var p4 = 0;
    if (l4[p4] !== " ") {
      for (var E4 = 0, D3 = 0; l4[p4] === c5; ) E4++, p4++;
      for (var f4 = (l4.length - p4) * h4 + 1 >>> 0, N2 = new Uint8Array(f4); l4[p4]; ) {
        var C2 = t[l4.charCodeAt(p4)];
        if (C2 === 255) return;
        for (var L2 = 0, $2 = f4 - 1; (C2 !== 0 || L2 < D3) && $2 !== -1; $2--, L2++) C2 += a5 * N2[$2] >>> 0, N2[$2] = C2 % 256 >>> 0, C2 = C2 / 256 >>> 0;
        if (C2 !== 0) throw new Error("Non-zero carry");
        D3 = L2, p4++;
      }
      if (l4[p4] !== " ") {
        for (var x4 = f4 - D3; x4 !== f4 && N2[x4] === 0; ) x4++;
        for (var k3 = new Uint8Array(E4 + (f4 - x4)), ie = E4; x4 !== f4; ) k3[ie++] = N2[x4++];
        return k3;
      }
    }
  }
  function b3(l4) {
    var p4 = m2(l4);
    if (p4) return p4;
    throw new Error(`Non-${e2} character`);
  }
  return { encode: g3, decodeUnsafe: m2, decode: b3 };
}
var Os = xs2;
var As2 = Os;
var Nt = (o5) => {
  if (o5 instanceof Uint8Array && o5.constructor.name === "Uint8Array") return o5;
  if (o5 instanceof ArrayBuffer) return new Uint8Array(o5);
  if (ArrayBuffer.isView(o5)) return new Uint8Array(o5.buffer, o5.byteOffset, o5.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Ns2 = (o5) => new TextEncoder().encode(o5);
var Ls = (o5) => new TextDecoder().decode(o5);
var zs = class {
  constructor(e2, t, s2) {
    this.name = e2, this.prefix = t, this.baseEncode = s2;
  }
  encode(e2) {
    if (e2 instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e2)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var ks = class {
  constructor(e2, t, s2) {
    if (this.name = e2, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s2;
  }
  decode(e2) {
    if (typeof e2 == "string") {
      if (e2.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e2.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e2) {
    return Lt2(this, e2);
  }
};
var Ms2 = class {
  constructor(e2) {
    this.decoders = e2;
  }
  or(e2) {
    return Lt2(this, e2);
  }
  decode(e2) {
    const t = e2[0], s2 = this.decoders[t];
    if (s2) return s2.decode(e2);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e2)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var Lt2 = (o5, e2) => new Ms2({ ...o5.decoders || { [o5.prefix]: o5 }, ...e2.decoders || { [e2.prefix]: e2 } });
var $s = class {
  constructor(e2, t, s2, i3) {
    this.name = e2, this.prefix = t, this.baseEncode = s2, this.baseDecode = i3, this.encoder = new zs(e2, t, s2), this.decoder = new ks(e2, t, i3);
  }
  encode(e2) {
    return this.encoder.encode(e2);
  }
  decode(e2) {
    return this.decoder.decode(e2);
  }
};
var ae = ({ name: o5, prefix: e2, encode: t, decode: s2 }) => new $s(o5, e2, t, s2);
var Q = ({ prefix: o5, name: e2, alphabet: t }) => {
  const { encode: s2, decode: i3 } = As2(t, e2);
  return ae({ prefix: o5, name: e2, encode: s2, decode: (r3) => Nt(i3(r3)) });
};
var Fs = (o5, e2, t, s2) => {
  const i3 = {};
  for (let d3 = 0; d3 < e2.length; ++d3) i3[e2[d3]] = d3;
  let r3 = o5.length;
  for (; o5[r3 - 1] === "="; ) --r3;
  const n4 = new Uint8Array(r3 * t / 8 | 0);
  let a5 = 0, c5 = 0, h4 = 0;
  for (let d3 = 0; d3 < r3; ++d3) {
    const g3 = i3[o5[d3]];
    if (g3 === void 0) throw new SyntaxError(`Non-${s2} character`);
    c5 = c5 << t | g3, a5 += t, a5 >= 8 && (a5 -= 8, n4[h4++] = 255 & c5 >> a5);
  }
  if (a5 >= t || 255 & c5 << 8 - a5) throw new SyntaxError("Unexpected end of data");
  return n4;
};
var Us = (o5, e2, t) => {
  const s2 = e2[e2.length - 1] === "=", i3 = (1 << t) - 1;
  let r3 = "", n4 = 0, a5 = 0;
  for (let c5 = 0; c5 < o5.length; ++c5) for (a5 = a5 << 8 | o5[c5], n4 += 8; n4 > t; ) n4 -= t, r3 += e2[i3 & a5 >> n4];
  if (n4 && (r3 += e2[i3 & a5 << t - n4]), s2) for (; r3.length * t & 7; ) r3 += "=";
  return r3;
};
var _2 = ({ name: o5, prefix: e2, bitsPerChar: t, alphabet: s2 }) => ae({ prefix: e2, name: o5, encode(i3) {
  return Us(i3, s2, t);
}, decode(i3) {
  return Fs(i3, s2, t, o5);
} });
var Ks = ae({ prefix: "\0", name: "identity", encode: (o5) => Ls(o5), decode: (o5) => Ns2(o5) });
var Bs = Object.freeze({ __proto__: null, identity: Ks });
var Vs = _2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var js = Object.freeze({ __proto__: null, base2: Vs });
var qs = _2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Gs = Object.freeze({ __proto__: null, base8: qs });
var Hs = Q({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Ys = Object.freeze({ __proto__: null, base10: Hs });
var Js = _2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Ws = _2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Xs = Object.freeze({ __proto__: null, base16: Js, base16upper: Ws });
var Zs = _2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Qs = _2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var er2 = _2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var tr = _2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var ir = _2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var sr = _2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var rr2 = _2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var nr = _2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var or = _2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var ar = Object.freeze({ __proto__: null, base32: Zs, base32upper: Qs, base32pad: er2, base32padupper: tr, base32hex: ir, base32hexupper: sr, base32hexpad: rr2, base32hexpadupper: nr, base32z: or });
var cr = Q({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var hr = Q({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var lr = Object.freeze({ __proto__: null, base36: cr, base36upper: hr });
var ur = Q({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var dr = Q({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var gr2 = Object.freeze({ __proto__: null, base58btc: ur, base58flickr: dr });
var pr2 = _2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var yr = _2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Dr = _2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var mr = _2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var br = Object.freeze({ __proto__: null, base64: pr2, base64pad: yr, base64url: Dr, base64urlpad: mr });
var zt = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var fr = zt.reduce((o5, e2, t) => (o5[t] = e2, o5), []);
var _r = zt.reduce((o5, e2, t) => (o5[e2.codePointAt(0)] = t, o5), []);
function Er(o5) {
  return o5.reduce((e2, t) => (e2 += fr[t], e2), "");
}
function vr(o5) {
  const e2 = [];
  for (const t of o5) {
    const s2 = _r[t.codePointAt(0)];
    if (s2 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e2.push(s2);
  }
  return new Uint8Array(e2);
}
var wr = ae({ prefix: "🚀", name: "base256emoji", encode: Er, decode: vr });
var Ir = Object.freeze({ __proto__: null, base256emoji: wr });
var Tr = Mt;
var kt = 128;
var Cr = 127;
var Sr2 = ~Cr;
var Pr = Math.pow(2, 31);
function Mt(o5, e2, t) {
  e2 = e2 || [], t = t || 0;
  for (var s2 = t; o5 >= Pr; ) e2[t++] = o5 & 255 | kt, o5 /= 128;
  for (; o5 & Sr2; ) e2[t++] = o5 & 255 | kt, o5 >>>= 7;
  return e2[t] = o5 | 0, Mt.bytes = t - s2 + 1, e2;
}
var Rr = we;
var xr = 128;
var $t = 127;
function we(o5, s2) {
  var t = 0, s2 = s2 || 0, i3 = 0, r3 = s2, n4, a5 = o5.length;
  do {
    if (r3 >= a5) throw we.bytes = 0, new RangeError("Could not decode varint");
    n4 = o5[r3++], t += i3 < 28 ? (n4 & $t) << i3 : (n4 & $t) * Math.pow(2, i3), i3 += 7;
  } while (n4 >= xr);
  return we.bytes = r3 - s2, t;
}
var Or = Math.pow(2, 7);
var Ar = Math.pow(2, 14);
var Nr2 = Math.pow(2, 21);
var Lr = Math.pow(2, 28);
var zr = Math.pow(2, 35);
var kr = Math.pow(2, 42);
var Mr = Math.pow(2, 49);
var $r = Math.pow(2, 56);
var Fr = Math.pow(2, 63);
var Ur = function(o5) {
  return o5 < Or ? 1 : o5 < Ar ? 2 : o5 < Nr2 ? 3 : o5 < Lr ? 4 : o5 < zr ? 5 : o5 < kr ? 6 : o5 < Mr ? 7 : o5 < $r ? 8 : o5 < Fr ? 9 : 10;
};
var Kr2 = { encode: Tr, decode: Rr, encodingLength: Ur };
var Ft = Kr2;
var Ut = (o5, e2, t = 0) => (Ft.encode(o5, e2, t), e2);
var Kt = (o5) => Ft.encodingLength(o5);
var Ie = (o5, e2) => {
  const t = e2.byteLength, s2 = Kt(o5), i3 = s2 + Kt(t), r3 = new Uint8Array(i3 + t);
  return Ut(o5, r3, 0), Ut(t, r3, s2), r3.set(e2, i3), new Br(o5, t, e2, r3);
};
var Br = class {
  constructor(e2, t, s2, i3) {
    this.code = e2, this.size = t, this.digest = s2, this.bytes = i3;
  }
};
var Bt = ({ name: o5, code: e2, encode: t }) => new Vr2(o5, e2, t);
var Vr2 = class {
  constructor(e2, t, s2) {
    this.name = e2, this.code = t, this.encode = s2;
  }
  digest(e2) {
    if (e2 instanceof Uint8Array) {
      const t = this.encode(e2);
      return t instanceof Uint8Array ? Ie(this.code, t) : t.then((s2) => Ie(this.code, s2));
    } else throw Error("Unknown type, must be binary type");
  }
};
var Vt = (o5) => async (e2) => new Uint8Array(await crypto.subtle.digest(o5, e2));
var jr = Bt({ name: "sha2-256", code: 18, encode: Vt("SHA-256") });
var qr = Bt({ name: "sha2-512", code: 19, encode: Vt("SHA-512") });
var Gr = Object.freeze({ __proto__: null, sha256: jr, sha512: qr });
var jt = 0;
var Hr = "identity";
var qt = Nt;
var Yr = (o5) => Ie(jt, qt(o5));
var Jr = { code: jt, name: Hr, encode: qt, digest: Yr };
var Wr2 = Object.freeze({ __proto__: null, identity: Jr });
new TextEncoder(), new TextDecoder();
var Gt = { ...Bs, ...js, ...Gs, ...Ys, ...Xs, ...ar, ...lr, ...gr2, ...br, ...Ir };
({ ...Gr, ...Wr2 });
function Xr2(o5 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(o5) : new Uint8Array(o5);
}
function Ht(o5, e2, t, s2) {
  return { name: o5, prefix: e2, encoder: { name: o5, prefix: e2, encode: t }, decoder: { decode: s2 } };
}
var Yt2 = Ht("utf8", "u", (o5) => "u" + new TextDecoder("utf8").decode(o5), (o5) => new TextEncoder().encode(o5.substring(1)));
var Te = Ht("ascii", "a", (o5) => {
  let e2 = "a";
  for (let t = 0; t < o5.length; t++) e2 += String.fromCharCode(o5[t]);
  return e2;
}, (o5) => {
  o5 = o5.substring(1);
  const e2 = Xr2(o5.length);
  for (let t = 0; t < o5.length; t++) e2[t] = o5.charCodeAt(t);
  return e2;
});
var Zr = { utf8: Yt2, "utf-8": Yt2, hex: Gt.base16, latin1: Te, ascii: Te, binary: Te, ...Gt };
function Qr(o5, e2 = "utf8") {
  const t = Zr[e2];
  if (!t) throw new Error(`Unsupported encoding "${e2}"`);
  return (e2 === "utf8" || e2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(o5, "utf8") : t.decoder.decode(`${t.prefix}${o5}`);
}
var Jt = class {
  constructor(e2, t) {
    this.core = e2, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = tt, this.version = it, this.initialized = false, this.storagePrefix = O2, this.init = async () => {
      if (!this.initialized) {
        const s2 = await this.getKeyChain();
        typeof s2 < "u" && (this.keychain = s2), this.initialized = true;
      }
    }, this.has = (s2) => (this.isInitialized(), this.keychain.has(s2)), this.set = async (s2, i3) => {
      this.isInitialized(), this.keychain.set(s2, i3), await this.persist();
    }, this.get = (s2) => {
      this.isInitialized();
      const i3 = this.keychain.get(s2);
      if (typeof i3 > "u") {
        const { message: r3 } = xe("NO_MATCHING_KEY", `${this.name}: ${s2}`);
        throw new Error(r3);
      }
      return i3;
    }, this.del = async (s2) => {
      this.isInitialized(), this.keychain.delete(s2), await this.persist();
    }, this.core = e2, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e2) {
    await this.core.storage.setItem(this.storageKey, cs(e2));
  }
  async getKeyChain() {
    const e2 = await this.core.storage.getItem(this.storageKey);
    return typeof e2 < "u" ? ls(e2) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Wt = class {
  constructor(e2, t, s2) {
    this.core = e2, this.logger = t, this.name = Qe, this.randomSessionIdentifier = Bu(), this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (i3) => (this.isInitialized(), this.keychain.has(i3)), this.getClientId = async () => {
      this.isInitialized();
      const i3 = await this.getClientSeed(), r3 = generateKeyPair(i3);
      return encodeIss(r3.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const i3 = _u();
      return this.setPrivateKey(i3.publicKey, i3.privateKey);
    }, this.signJWT = async (i3) => {
      this.isInitialized();
      const r3 = await this.getClientSeed(), n4 = generateKeyPair(r3), a5 = this.randomSessionIdentifier, c5 = et;
      return await signJWT(a5, i3, c5, n4);
    }, this.generateSharedKey = (i3, r3, n4) => {
      this.isInitialized();
      const a5 = this.getPrivateKey(i3), c5 = Cu(a5, r3);
      return this.setSymKey(c5, n4);
    }, this.setSymKey = async (i3, r3) => {
      this.isInitialized();
      const n4 = r3 || Ru(i3);
      return await this.keychain.set(n4, i3), n4;
    }, this.deleteKeyPair = async (i3) => {
      this.isInitialized(), await this.keychain.del(i3);
    }, this.deleteSymKey = async (i3) => {
      this.isInitialized(), await this.keychain.del(i3);
    }, this.encode = async (i3, r3, n4) => {
      this.isInitialized();
      const a5 = so(n4), c5 = safeJsonStringify(r3);
      if (qu(a5)) return Tu(c5, n4 == null ? void 0 : n4.encoding);
      if (ku(a5)) {
        const m2 = a5.senderPublicKey, b3 = a5.receiverPublicKey;
        i3 = await this.generateSharedKey(m2, b3);
      }
      const h4 = this.getSymKey(i3), { type: d3, senderPublicKey: g3 } = a5;
      return Pu({ type: d3, symKey: h4, message: c5, senderPublicKey: g3, encoding: n4 == null ? void 0 : n4.encoding });
    }, this.decode = async (i3, r3, n4) => {
      this.isInitialized();
      const a5 = Uu(r3, n4);
      if (qu(a5)) {
        const c5 = Fu(r3, n4 == null ? void 0 : n4.encoding);
        return safeJsonParse(c5);
      }
      if (ku(a5)) {
        const c5 = a5.receiverPublicKey, h4 = a5.senderPublicKey;
        i3 = await this.generateSharedKey(c5, h4);
      }
      try {
        const c5 = this.getSymKey(i3), h4 = Du({ symKey: c5, encoded: r3, encoding: n4 == null ? void 0 : n4.encoding });
        return safeJsonParse(h4);
      } catch (c5) {
        this.logger.error(`Failed to decode message from topic: '${i3}', clientId: '${await this.getClientId()}'`), this.logger.error(c5);
      }
    }, this.getPayloadType = (i3, r3 = tn) => {
      const n4 = Wr({ encoded: i3, encoding: r3 });
      return Ze(n4.type);
    }, this.getPayloadSenderPublicKey = (i3, r3 = tn) => {
      const n4 = Wr({ encoded: i3, encoding: r3 });
      return n4.senderPublicKey ? toString(n4.senderPublicKey, Lt) : void 0;
    }, this.core = e2, this.logger = E(t, this.name), this.keychain = s2 || new Jt(this.core, this.logger);
  }
  get context() {
    return y(this.logger);
  }
  async setPrivateKey(e2, t) {
    return await this.keychain.set(e2, t), e2;
  }
  getPrivateKey(e2) {
    return this.keychain.get(e2);
  }
  async getClientSeed() {
    let e2 = "";
    try {
      e2 = this.keychain.get(_e);
    } catch {
      e2 = Bu(), await this.keychain.set(_e, e2);
    }
    return Qr(e2, "base16");
  }
  getSymKey(e2) {
    return this.keychain.get(e2);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Xt = class extends a3 {
  constructor(e2, t) {
    super(e2, t), this.logger = e2, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = st, this.version = rt, this.initialized = false, this.storagePrefix = O2, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const s2 = await this.getRelayerMessages();
          typeof s2 < "u" && (this.messages = s2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (s2) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s2);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (s2, i3) => {
      this.isInitialized();
      const r3 = Ou(i3);
      let n4 = this.messages.get(s2);
      return typeof n4 > "u" && (n4 = {}), typeof n4[r3] < "u" || (n4[r3] = i3, this.messages.set(s2, n4), await this.persist()), r3;
    }, this.get = (s2) => {
      this.isInitialized();
      let i3 = this.messages.get(s2);
      return typeof i3 > "u" && (i3 = {}), i3;
    }, this.has = (s2, i3) => {
      this.isInitialized();
      const r3 = this.get(s2), n4 = Ou(i3);
      return typeof r3[n4] < "u";
    }, this.del = async (s2) => {
      this.isInitialized(), this.messages.delete(s2), await this.persist();
    }, this.logger = E(e2, this.name), this.core = t;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e2) {
    await this.core.storage.setItem(this.storageKey, cs(e2));
  }
  async getRelayerMessages() {
    const e2 = await this.core.storage.getItem(this.storageKey);
    return typeof e2 < "u" ? ls(e2) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var en = class extends g {
  constructor(e2, t) {
    super(e2, t), this.relayer = e2, this.logger = t, this.events = new import_events7.EventEmitter(), this.name = ot, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE), this.failedPublishTimeout = (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND), this.needsTransportRestart = false, this.publish = async (s2, i3, r3) => {
      var n4;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: s2, message: i3, opts: r3 } });
      const a5 = (r3 == null ? void 0 : r3.ttl) || nt, c5 = zu(r3), h4 = (r3 == null ? void 0 : r3.prompt) || false, d3 = (r3 == null ? void 0 : r3.tag) || 0, g3 = (r3 == null ? void 0 : r3.id) || getBigIntRpcId().toString(), m2 = { topic: s2, message: i3, opts: { ttl: a5, relay: c5, prompt: h4, tag: d3, id: g3, attestation: r3 == null ? void 0 : r3.attestation } }, b3 = `Failed to publish payload, please try again. id:${g3} tag:${d3}`, l4 = Date.now();
      let p4, E4 = 1;
      try {
        for (; p4 === void 0; ) {
          if (Date.now() - l4 > this.publishTimeout) throw new Error(b3);
          this.logger.trace({ id: g3, attempts: E4 }, `publisher.publish - attempt ${E4}`), p4 = await await ms(this.rpcPublish(s2, i3, a5, c5, h4, d3, g3, r3 == null ? void 0 : r3.attestation).catch((D3) => this.logger.warn(D3)), this.publishTimeout, b3), E4++, p4 || await new Promise((D3) => setTimeout(D3, this.failedPublishTimeout));
        }
        this.relayer.events.emit(w3.publish, m2), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { id: g3, topic: s2, message: i3, opts: r3 } });
      } catch (D3) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(D3), (n4 = r3 == null ? void 0 : r3.internal) != null && n4.throwOnFailedPublish) throw D3;
        this.queue.set(g3, m2);
      }
    }, this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.relayer = e2, this.logger = E(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y(this.logger);
  }
  rpcPublish(e2, t, s2, i3, r3, n4, a5, c5) {
    var h4, d3, g3, m2;
    const b3 = { method: ju(i3.protocol).publish, params: { topic: e2, message: t, ttl: s2, prompt: r3, tag: n4, attestation: c5 }, id: a5 };
    return Pe((h4 = b3.params) == null ? void 0 : h4.prompt) && ((d3 = b3.params) == null || delete d3.prompt), Pe((g3 = b3.params) == null ? void 0 : g3.tag) && ((m2 = b3.params) == null || delete m2.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: b3 }), this.relayer.request(b3);
  }
  removeRequestFromQueue(e2) {
    this.queue.delete(e2);
  }
  checkQueue() {
    this.queue.forEach(async (e2) => {
      const { topic: t, message: s2, opts: i3 } = e2;
      await this.publish(t, s2, i3);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(w3.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(w3.message_ack, (e2) => {
      this.removeRequestFromQueue(e2.id.toString());
    });
  }
};
var tn2 = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e2, t) => {
      const s2 = this.get(e2);
      this.exists(e2, t) || this.map.set(e2, [...s2, t]);
    }, this.get = (e2) => this.map.get(e2) || [], this.exists = (e2, t) => this.get(e2).includes(t), this.delete = (e2, t) => {
      if (typeof t > "u") {
        this.map.delete(e2);
        return;
      }
      if (!this.map.has(e2)) return;
      const s2 = this.get(e2);
      if (!this.exists(e2, t)) return;
      const i3 = s2.filter((r3) => r3 !== t);
      if (!i3.length) {
        this.map.delete(e2);
        return;
      }
      this.map.set(e2, i3);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var sn = Object.defineProperty;
var rn = Object.defineProperties;
var nn = Object.getOwnPropertyDescriptors;
var Zt = Object.getOwnPropertySymbols;
var on2 = Object.prototype.hasOwnProperty;
var an = Object.prototype.propertyIsEnumerable;
var Qt = (o5, e2, t) => e2 in o5 ? sn(o5, e2, { enumerable: true, configurable: true, writable: true, value: t }) : o5[e2] = t;
var ee = (o5, e2) => {
  for (var t in e2 || (e2 = {})) on2.call(e2, t) && Qt(o5, t, e2[t]);
  if (Zt) for (var t of Zt(e2)) an.call(e2, t) && Qt(o5, t, e2[t]);
  return o5;
};
var Ce = (o5, e2) => rn(o5, nn(e2));
var ei = class extends d {
  constructor(e2, t) {
    super(e2, t), this.relayer = e2, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new tn2(), this.events = new import_events7.EventEmitter(), this.name = pt, this.version = yt, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = O2, this.subscribeTimeout = (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE), this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.pendingBatchMessages = [], this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = true;
    }, this.subscribe = async (s2, i3) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i3 } });
      try {
        const r3 = zu(i3), n4 = { topic: s2, relay: r3, transportType: i3 == null ? void 0 : i3.transportType };
        this.pending.set(s2, n4);
        const a5 = await this.rpcSubscribe(s2, r3, i3 == null ? void 0 : i3.transportType);
        return typeof a5 == "string" && (this.onSubscribe(a5, n4), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i3 } })), a5;
      } catch (r3) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r3), r3;
      }
    }, this.unsubscribe = async (s2, i3) => {
      await this.restartToComplete(), this.isInitialized(), typeof (i3 == null ? void 0 : i3.id) < "u" ? await this.unsubscribeById(s2, i3.id, i3) : await this.unsubscribeByTopic(s2, i3);
    }, this.isSubscribed = async (s2) => {
      if (this.topics.includes(s2)) return true;
      const i3 = `${this.pendingSubscriptionWatchLabel}_${s2}`;
      return await new Promise((r3, n4) => {
        const a5 = new import_time2.Watch();
        a5.start(i3);
        const c5 = setInterval(() => {
          !this.pending.has(s2) && this.topics.includes(s2) && (clearInterval(c5), a5.stop(i3), r3(true)), a5.elapsed(i3) >= Dt && (clearInterval(c5), a5.stop(i3), n4(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => false);
    }, this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e2, this.logger = E(t, this.name), this.clientId = "";
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e2, t) {
    let s2 = false;
    try {
      s2 = this.getSubscription(e2).topic === t;
    } catch {
    }
    return s2;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e2, t) {
    const s2 = this.topicMap.get(e2);
    await Promise.all(s2.map(async (i3) => await this.unsubscribeById(e2, i3, t)));
  }
  async unsubscribeById(e2, t, s2) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e2, id: t, opts: s2 } });
    try {
      const i3 = zu(s2);
      await this.rpcUnsubscribe(e2, t, i3);
      const r3 = er("USER_DISCONNECTED", `${this.name}, ${e2}`);
      await this.onUnsubscribe(e2, t, r3), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e2, id: t, opts: s2 } });
    } catch (i3) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i3), i3;
    }
  }
  async rpcSubscribe(e2, t, s2 = F.relay) {
    s2 === F.relay && await this.restartToComplete();
    const i3 = { method: ju(t.protocol).subscribe, params: { topic: e2 } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      const r3 = Ou(e2 + this.clientId);
      return s2 === F.link_mode ? (setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(i3).catch((n4) => this.logger.warn(n4));
      }, (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND)), r3) : await await ms(this.relayer.request(i3).catch((n4) => this.logger.warn(n4)), this.subscribeTimeout) ? r3 : null;
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(w3.connection_stalled);
    }
    return null;
  }
  async rpcBatchSubscribe(e2) {
    if (!e2.length) return;
    const t = e2[0].relay, s2 = { method: ju(t.protocol).batchSubscribe, params: { topics: e2.map((i3) => i3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    try {
      return await await ms(this.relayer.request(s2).catch((i3) => this.logger.warn(i3)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(w3.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e2) {
    if (!e2.length) return;
    const t = e2[0].relay, s2 = { method: ju(t.protocol).batchFetchMessages, params: { topics: e2.map((r3) => r3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    let i3;
    try {
      i3 = await await ms(this.relayer.request(s2).catch((r3) => this.logger.warn(r3)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(w3.connection_stalled);
    }
    return i3;
  }
  rpcUnsubscribe(e2, t, s2) {
    const i3 = { method: ju(s2.protocol).unsubscribe, params: { topic: e2, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 }), this.relayer.request(i3);
  }
  onSubscribe(e2, t) {
    this.setSubscription(e2, Ce(ee({}, t), { id: e2 })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e2) {
    e2.length && e2.forEach((t) => {
      this.setSubscription(t.id, ee({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e2, t, s2) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e2) && this.deleteSubscription(t, s2), await this.relayer.messages.del(e2);
  }
  async setRelayerSubscriptions(e2) {
    await this.relayer.core.storage.setItem(this.storageKey, e2);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e2, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e2, subscription: t }), this.addSubscription(e2, t);
  }
  addSubscription(e2, t) {
    this.subscriptions.set(e2, ee({}, t)), this.topicMap.set(t.topic, e2), this.events.emit(A2.created, t);
  }
  getSubscription(e2) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e2 });
    const t = this.subscriptions.get(e2);
    if (!t) {
      const { message: s2 } = xe("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw new Error(s2);
    }
    return t;
  }
  deleteSubscription(e2, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e2, reason: t });
    const s2 = this.getSubscription(e2);
    this.subscriptions.delete(e2), this.topicMap.delete(s2.topic, e2), this.events.emit(A2.deleted, Ce(ee({}, s2), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(A2.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e2 = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e2; t++) {
        const s2 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchFetchMessages(s2), await this.batchSubscribe(s2);
      }
    }
    this.events.emit(A2.resubscribed);
  }
  async restore() {
    try {
      const e2 = await this.getRelayerSubscriptions();
      if (typeof e2 > "u" || !e2.length) return;
      if (this.subscriptions.size) {
        const { message: t } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e2);
    }
  }
  async batchSubscribe(e2) {
    if (!e2.length) return;
    const t = await this.rpcBatchSubscribe(e2);
    Nr(t) && this.onBatchSubscribe(t.map((s2, i3) => Ce(ee({}, e2[i3]), { id: s2 })));
  }
  async batchFetchMessages(e2) {
    if (!e2.length) return;
    this.logger.trace(`Fetching batch messages for ${e2.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e2);
    t && t.messages && (this.pendingBatchMessages = this.pendingBatchMessages.concat(t.messages));
  }
  async onConnect() {
    await this.restart(), this.onEnable();
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || !this.relayer.connected) return;
    const e2 = [];
    this.pending.forEach((t) => {
      e2.push(t);
    }), await this.batchSubscribe(e2), this.pendingBatchMessages.length && (await this.relayer.handleBatchMessageEvents(this.pendingBatchMessages), this.pendingBatchMessages = []);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r.pulse, async () => {
      await this.checkPending();
    }), this.events.on(A2.created, async (e2) => {
      const t = A2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), await this.persist();
    }), this.events.on(A2.deleted, async (e2) => {
      const t = A2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen(), this.restartInProgress && await new Promise((e2) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e2());
      }, this.pollingInterval);
    });
  }
};
var cn = Object.defineProperty;
var ti = Object.getOwnPropertySymbols;
var hn = Object.prototype.hasOwnProperty;
var ln = Object.prototype.propertyIsEnumerable;
var ii = (o5, e2, t) => e2 in o5 ? cn(o5, e2, { enumerable: true, configurable: true, writable: true, value: t }) : o5[e2] = t;
var un = (o5, e2) => {
  for (var t in e2 || (e2 = {})) hn.call(e2, t) && ii(o5, t, e2[t]);
  if (ti) for (var t of ti(e2)) ln.call(e2, t) && ii(o5, t, e2[t]);
  return o5;
};
var si = class extends u {
  constructor(e2) {
    super(e2), this.protocol = "wc", this.version = 2, this.events = new import_events7.EventEmitter(), this.name = ht, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "stalled", "interrupted"], this.hasExperiencedNetworkDisruption = false, this.requestsInFlight = /* @__PURE__ */ new Map(), this.heartBeatTimeout = (0, import_time2.toMiliseconds)(import_time2.THIRTY_SECONDS + import_time2.ONE_SECOND), this.request = async (t) => {
      var s2, i3;
      this.logger.debug("Publishing Request Payload");
      const r3 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        const n4 = this.provider.request(t);
        this.requestsInFlight.set(r3, { promise: n4, request: t }), this.logger.trace({ id: r3, method: t.method, topic: (s2 = t.params) == null ? void 0 : s2.topic }, "relayer.request - attempt to publish...");
        const a5 = await new Promise(async (c5, h4) => {
          const d3 = () => {
            h4(new Error(`relayer.request - publish interrupted, id: ${r3}`));
          };
          this.provider.on(T.disconnect, d3);
          const g3 = await n4;
          this.provider.off(T.disconnect, d3), c5(g3);
        });
        return this.logger.trace({ id: r3, method: t.method, topic: (i3 = t.params) == null ? void 0 : i3.topic }, "relayer.request - published"), a5;
      } catch (n4) {
        throw this.logger.debug(`Failed to Publish Request: ${r3}`), n4;
      } finally {
        this.requestsInFlight.delete(r3);
      }
    }, this.resetPingTimeout = () => {
      if (bi()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var t, s2, i3;
          (i3 = (s2 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : s2.socket) == null || i3.terminate();
        }, this.heartBeatTimeout);
      } catch (t) {
        this.logger.warn(t);
      }
    }, this.onPayloadHandler = (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.logger.trace("relayer connected"), this.startPingTimeout(), this.events.emit(w3.connect);
    }, this.onDisconnectHandler = () => {
      this.logger.trace("relayer disconnected"), this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t) => {
      this.logger.error(t), this.events.emit(w3.error, t), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(T.payload, this.onPayloadHandler), this.provider.on(T.connect, this.onConnectHandler), this.provider.on(T.disconnect, this.onDisconnectHandler), this.provider.on(T.error, this.onProviderErrorHandler);
    }, this.core = e2.core, this.logger = typeof e2.logger < "u" && typeof e2.logger != "string" ? E(e2.logger, this.name) : (0, import_pino.default)(k({ level: e2.logger || ct })), this.messages = new Xt(this.logger, e2.core), this.subscriber = new ei(this, this.logger), this.publisher = new en(this, this.logger), this.relayUrl = (e2 == null ? void 0 : e2.relayUrl) || Ee, this.projectId = e2.projectId, this.bundleId = ns(), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.cached.length > 0) try {
      await this.transportOpen();
    } catch (e2) {
      this.logger.warn(e2);
    }
  }
  get context() {
    return y(this.logger);
  }
  get connected() {
    var e2, t, s2;
    return ((s2 = (t = (e2 = this.provider) == null ? void 0 : e2.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 1;
  }
  get connecting() {
    var e2, t, s2;
    return ((s2 = (t = (e2 = this.provider) == null ? void 0 : e2.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 0;
  }
  async publish(e2, t, s2) {
    this.isInitialized(), await this.publisher.publish(e2, t, s2), await this.recordMessageEvent({ topic: e2, message: t, publishedAt: Date.now(), transportType: F.relay });
  }
  async subscribe(e2, t) {
    var s2;
    this.isInitialized(), (t == null ? void 0 : t.transportType) === "relay" && await this.toEstablishConnection();
    let i3 = ((s2 = this.subscriber.topicMap.get(e2)) == null ? void 0 : s2[0]) || "", r3;
    const n4 = (a5) => {
      a5.topic === e2 && (this.subscriber.off(A2.created, n4), r3());
    };
    return await Promise.all([new Promise((a5) => {
      r3 = a5, this.subscriber.on(A2.created, n4);
    }), new Promise(async (a5) => {
      i3 = await this.subscriber.subscribe(e2, t) || i3, a5();
    })]), i3;
  }
  async unsubscribe(e2, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e2, t);
  }
  on(e2, t) {
    this.events.on(e2, t);
  }
  once(e2, t) {
    this.events.once(e2, t);
  }
  off(e2, t) {
    this.events.off(e2, t);
  }
  removeListener(e2, t) {
    this.events.removeListener(e2, t);
  }
  async transportDisconnect() {
    if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0) try {
      await Promise.all(Array.from(this.requestsInFlight.values()).map((e2) => e2.promise));
    } catch (e2) {
      this.logger.warn(e2);
    }
    this.hasExperiencedNetworkDisruption || this.connected ? await ms(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e2) {
    await this.confirmOnlineStateOrThrow(), e2 && e2 !== this.relayUrl && (this.relayUrl = e2, await this.transportDisconnect()), await this.createProvider(), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    try {
      await new Promise(async (t, s2) => {
        const i3 = () => {
          this.provider.off(T.disconnect, i3), s2(new Error("Connection interrupted while trying to subscribe"));
        };
        this.provider.on(T.disconnect, i3), await ms(this.provider.connect(), (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch((r3) => {
          s2(r3);
        }).finally(() => {
          clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
        }), this.subscriber.start().catch((r3) => {
          this.logger.error(r3), this.onDisconnectHandler();
        }), this.hasExperiencedNetworkDisruption = false, t();
      });
    } catch (t) {
      this.logger.error(t);
      const s2 = t;
      if (this.hasExperiencedNetworkDisruption = true, !this.isConnectionStalled(s2.message)) throw t;
    } finally {
      this.connectionAttemptInProgress = false;
    }
  }
  async restartTransport(e2) {
    this.connectionAttemptInProgress || (this.relayUrl = e2 || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Bh()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e2) {
    if ((e2 == null ? void 0 : e2.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e2.sort((s2, i3) => s2.publishedAt - i3.publishedAt);
    this.logger.trace(`Batch of ${t.length} message events sorted`);
    for (const s2 of t) try {
      await this.onMessageEvent(s2);
    } catch (i3) {
      this.logger.warn(i3);
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e2, t) {
    const { topic: s2 } = e2;
    if (!t.sessionExists) {
      const i3 = ws(import_time2.FIVE_MINUTES), r3 = { topic: s2, expiry: i3, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(s2, r3);
    }
    this.events.emit(w3.message, e2), await this.recordMessageEvent(e2);
  }
  startPingTimeout() {
    var e2, t, s2, i3, r3;
    if (bi()) try {
      (t = (e2 = this.provider) == null ? void 0 : e2.connection) != null && t.socket && ((r3 = (i3 = (s2 = this.provider) == null ? void 0 : s2.connection) == null ? void 0 : i3.socket) == null || r3.once("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (n4) {
      this.logger.warn(n4);
    }
  }
  isConnectionStalled(e2) {
    return this.staleConnectionErrors.some((t) => e2.includes(t));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e2 = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o3(new f2(ss({ sdkVersion: oe, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e2, useOnCloseEvent: true, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e2) {
    const { topic: t, message: s2 } = e2;
    await this.messages.set(t, s2);
  }
  async shouldIgnoreMessageEvent(e2) {
    const { topic: t, message: s2 } = e2;
    if (!s2 || s2.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${s2}`), true;
    if (!await this.subscriber.isSubscribed(t)) return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), true;
    const i3 = this.messages.has(t, s2);
    return i3 && this.logger.debug(`Ignoring duplicate message: ${s2}`), i3;
  }
  async onProviderPayload(e2) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e2 }), isJsonRpcRequest(e2)) {
      if (!e2.method.endsWith(lt)) return;
      const t = e2.params, { topic: s2, message: i3, publishedAt: r3, attestation: n4 } = t.data, a5 = { topic: s2, message: i3, publishedAt: r3, transportType: F.relay, attestation: n4 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(un({ type: "event", event: t.id }, a5)), this.events.emit(t.id, a5), await this.acknowledgePayload(e2), await this.onMessageEvent(a5);
    } else isJsonRpcResponse(e2) && this.events.emit(w3.message_ack, e2);
  }
  async onMessageEvent(e2) {
    await this.shouldIgnoreMessageEvent(e2) || (this.events.emit(w3.message, e2), await this.recordMessageEvent(e2));
  }
  async acknowledgePayload(e2) {
    const t = formatJsonRpcResult(e2.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(T.payload, this.onPayloadHandler), this.provider.off(T.connect, this.onConnectHandler), this.provider.off(T.disconnect, this.onDisconnectHandler), this.provider.off(T.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e2 = await Bh();
    Ch(async (t) => {
      e2 !== t && (e2 = t, t ? await this.restartTransport().catch((s2) => this.logger.error(s2)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), this.requestsInFlight.clear(), clearTimeout(this.pingTimeout), this.events.emit(w3.disconnect), this.connectionAttemptInProgress = false, !this.transportExplicitlyClosed && (this.reconnectTimeout || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e2) => this.logger.error(e2));
    }, (0, import_time2.toMiliseconds)(ut))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connectionAttemptInProgress && await new Promise((e2) => {
      const t = setInterval(() => {
        this.connected && (clearInterval(t), e2());
      }, this.connectionStatusPollingInterval);
    }), await this.transportOpen());
  }
};
var dn = Object.defineProperty;
var ri = Object.getOwnPropertySymbols;
var gn = Object.prototype.hasOwnProperty;
var pn = Object.prototype.propertyIsEnumerable;
var ni = (o5, e2, t) => e2 in o5 ? dn(o5, e2, { enumerable: true, configurable: true, writable: true, value: t }) : o5[e2] = t;
var oi = (o5, e2) => {
  for (var t in e2 || (e2 = {})) gn.call(e2, t) && ni(o5, t, e2[t]);
  if (ri) for (var t of ri(e2)) pn.call(e2, t) && ni(o5, t, e2[t]);
  return o5;
};
var ai = class extends p2 {
  constructor(e2, t, s2, i3 = O2, r3 = void 0) {
    super(e2, t, s2, i3), this.core = e2, this.logger = t, this.name = s2, this.map = /* @__PURE__ */ new Map(), this.version = dt, this.cached = [], this.initialized = false, this.storagePrefix = O2, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n4) => {
        this.getKey && n4 !== null && !Pe(n4) ? this.map.set(this.getKey(n4), n4) : lh(n4) ? this.map.set(n4.id, n4) : dh(n4) && this.map.set(n4.topic, n4);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (n4, a5) => {
      this.isInitialized(), this.map.has(n4) ? await this.update(n4, a5) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: n4, value: a5 }), this.map.set(n4, a5), await this.persist());
    }, this.get = (n4) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: n4 }), this.getData(n4)), this.getAll = (n4) => (this.isInitialized(), n4 ? this.values.filter((a5) => Object.keys(n4).every((c5) => (0, import_lodash.default)(a5[c5], n4[c5]))) : this.values), this.update = async (n4, a5) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: n4, update: a5 });
      const c5 = oi(oi({}, this.getData(n4)), a5);
      this.map.set(n4, c5), await this.persist();
    }, this.delete = async (n4, a5) => {
      this.isInitialized(), this.map.has(n4) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: n4, reason: a5 }), this.map.delete(n4), this.addToRecentlyDeleted(n4), await this.persist());
    }, this.logger = E(t, this.name), this.storagePrefix = i3, this.getKey = r3;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e2) {
    this.recentlyDeleted.push(e2), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e2) {
    const t = this.map.get(e2);
    if (!t) {
      if (this.recentlyDeleted.includes(e2)) {
        const { message: i3 } = xe("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e2}`);
        throw this.logger.error(i3), new Error(i3);
      }
      const { message: s2 } = xe("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw this.logger.error(s2), new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e2 = await this.getDataStore();
      if (typeof e2 > "u" || !e2.length) return;
      if (this.map.size) {
        const { message: t } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var ci = class {
  constructor(e2, t) {
    this.core = e2, this.logger = t, this.name = mt, this.version = bt, this.events = new import_events7.default(), this.initialized = false, this.storagePrefix = O2, this.ignoredPayloadTypes = [pr], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: s2 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s2])];
    }, this.create = async (s2) => {
      this.isInitialized();
      const i3 = Bu(), r3 = await this.core.crypto.setSymKey(i3), n4 = ws(import_time2.FIVE_MINUTES), a5 = { protocol: at }, c5 = { topic: r3, expiry: n4, relay: a5, active: false, methods: s2 == null ? void 0 : s2.methods }, h4 = $u({ protocol: this.core.protocol, version: this.core.version, topic: r3, symKey: i3, relay: a5, expiryTimestamp: n4, methods: s2 == null ? void 0 : s2.methods });
      return this.events.emit(q.create, c5), this.core.expirer.set(r3, n4), await this.pairings.set(r3, c5), await this.core.relayer.subscribe(r3, { transportType: s2 == null ? void 0 : s2.transportType }), { topic: r3, uri: h4 };
    }, this.pair = async (s2) => {
      this.isInitialized();
      const i3 = this.core.eventClient.createEvent({ properties: { topic: s2 == null ? void 0 : s2.uri, trace: [z2.pairing_started] } });
      this.isValidPair(s2, i3);
      const { topic: r3, symKey: n4, relay: a5, expiryTimestamp: c5, methods: h4 } = Xu(s2.uri);
      i3.props.properties.topic = r3, i3.addTrace(z2.pairing_uri_validation_success), i3.addTrace(z2.pairing_uri_not_expired);
      let d3;
      if (this.pairings.keys.includes(r3)) {
        if (d3 = this.pairings.get(r3), i3.addTrace(z2.existing_pairing), d3.active) throw i3.setError(M2.active_pairing_already_exists), new Error(`Pairing already exists: ${r3}. Please try again with a new connection URI.`);
        i3.addTrace(z2.pairing_not_expired);
      }
      const g3 = c5 || ws(import_time2.FIVE_MINUTES), m2 = { topic: r3, relay: a5, expiry: g3, active: false, methods: h4 };
      this.core.expirer.set(r3, g3), await this.pairings.set(r3, m2), i3.addTrace(z2.store_new_pairing), s2.activatePairing && await this.activate({ topic: r3 }), this.events.emit(q.create, m2), i3.addTrace(z2.emit_inactive_pairing), this.core.crypto.keychain.has(r3) || await this.core.crypto.setSymKey(n4, r3), i3.addTrace(z2.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i3.setError(M2.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(r3, { relay: a5 });
      } catch (b3) {
        throw i3.setError(M2.subscribe_pairing_topic_failure), b3;
      }
      return i3.addTrace(z2.subscribe_pairing_topic_success), m2;
    }, this.activate = async ({ topic: s2 }) => {
      this.isInitialized();
      const i3 = ws(import_time2.THIRTY_DAYS);
      this.core.expirer.set(s2, i3), await this.pairings.update(s2, { active: true, expiry: i3 });
    }, this.ping = async (s2) => {
      this.isInitialized(), await this.isValidPing(s2);
      const { topic: i3 } = s2;
      if (this.pairings.keys.includes(i3)) {
        const r3 = await this.sendRequest(i3, "wc_pairingPing", {}), { done: n4, resolve: a5, reject: c5 } = gs();
        this.events.once(Ms("pairing_ping", r3), ({ error: h4 }) => {
          h4 ? c5(h4) : a5();
        }), await n4();
      }
    }, this.updateExpiry = async ({ topic: s2, expiry: i3 }) => {
      this.isInitialized(), await this.pairings.update(s2, { expiry: i3 });
    }, this.updateMetadata = async ({ topic: s2, metadata: i3 }) => {
      this.isInitialized(), await this.pairings.update(s2, { peerMetadata: i3 });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (s2) => {
      this.isInitialized(), await this.isValidDisconnect(s2);
      const { topic: i3 } = s2;
      this.pairings.keys.includes(i3) && (await this.sendRequest(i3, "wc_pairingDelete", er("USER_DISCONNECTED")), await this.deletePairing(i3));
    }, this.formatUriFromPairing = (s2) => {
      this.isInitialized();
      const { topic: i3, relay: r3, expiry: n4, methods: a5 } = s2, c5 = this.core.crypto.keychain.get(i3);
      return $u({ protocol: this.core.protocol, version: this.core.version, topic: i3, symKey: c5, relay: r3, expiryTimestamp: n4, methods: a5 });
    }, this.sendRequest = async (s2, i3, r3) => {
      const n4 = formatJsonRpcRequest(i3, r3), a5 = await this.core.crypto.encode(s2, n4), c5 = j2[i3].req;
      return this.core.history.set(s2, n4), this.core.relayer.publish(s2, a5, c5), n4.id;
    }, this.sendResult = async (s2, i3, r3) => {
      const n4 = formatJsonRpcResult(s2, r3), a5 = await this.core.crypto.encode(i3, n4), c5 = await this.core.history.get(i3, s2), h4 = j2[c5.request.method].res;
      await this.core.relayer.publish(i3, a5, h4), await this.core.history.resolve(n4);
    }, this.sendError = async (s2, i3, r3) => {
      const n4 = formatJsonRpcError(s2, r3), a5 = await this.core.crypto.encode(i3, n4), c5 = await this.core.history.get(i3, s2), h4 = j2[c5.request.method] ? j2[c5.request.method].res : j2.unregistered_method.res;
      await this.core.relayer.publish(i3, a5, h4), await this.core.history.resolve(n4);
    }, this.deletePairing = async (s2, i3) => {
      await this.core.relayer.unsubscribe(s2), await Promise.all([this.pairings.delete(s2, er("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(s2), i3 ? Promise.resolve() : this.core.expirer.del(s2)]);
    }, this.cleanup = async () => {
      const s2 = this.pairings.getAll().filter((i3) => xs(i3.expiry));
      await Promise.all(s2.map((i3) => this.deletePairing(i3.topic)));
    }, this.onRelayEventRequest = (s2) => {
      const { topic: i3, payload: r3 } = s2;
      switch (r3.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i3, r3);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i3, r3);
        default:
          return this.onUnknownRpcMethodRequest(i3, r3);
      }
    }, this.onRelayEventResponse = async (s2) => {
      const { topic: i3, payload: r3 } = s2, n4 = (await this.core.history.get(i3, r3.id)).request.method;
      switch (n4) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i3, r3);
        default:
          return this.onUnknownRpcMethodResponse(n4);
      }
    }, this.onPairingPingRequest = async (s2, i3) => {
      const { id: r3 } = i3;
      try {
        this.isValidPing({ topic: s2 }), await this.sendResult(r3, s2, true), this.events.emit(q.ping, { id: r3, topic: s2 });
      } catch (n4) {
        await this.sendError(r3, s2, n4), this.logger.error(n4);
      }
    }, this.onPairingPingResponse = (s2, i3) => {
      const { id: r3 } = i3;
      setTimeout(() => {
        isJsonRpcResult(i3) ? this.events.emit(Ms("pairing_ping", r3), {}) : isJsonRpcError(i3) && this.events.emit(Ms("pairing_ping", r3), { error: i3.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (s2, i3) => {
      const { id: r3 } = i3;
      try {
        this.isValidDisconnect({ topic: s2 }), await this.deletePairing(s2), this.events.emit(q.delete, { id: r3, topic: s2 });
      } catch (n4) {
        await this.sendError(r3, s2, n4), this.logger.error(n4);
      }
    }, this.onUnknownRpcMethodRequest = async (s2, i3) => {
      const { id: r3, method: n4 } = i3;
      try {
        if (this.registeredMethods.includes(n4)) return;
        const a5 = er("WC_METHOD_UNSUPPORTED", n4);
        await this.sendError(r3, s2, a5), this.logger.error(a5);
      } catch (a5) {
        await this.sendError(r3, s2, a5), this.logger.error(a5);
      }
    }, this.onUnknownRpcMethodResponse = (s2) => {
      this.registeredMethods.includes(s2) || this.logger.error(er("WC_METHOD_UNSUPPORTED", s2));
    }, this.isValidPair = (s2, i3) => {
      var r3;
      if (!Ah(s2)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `pair() params: ${s2}`);
        throw i3.setError(M2.malformed_pairing_uri), new Error(a5);
      }
      if (!ch(s2.uri)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `pair() uri: ${s2.uri}`);
        throw i3.setError(M2.malformed_pairing_uri), new Error(a5);
      }
      const n4 = Xu(s2 == null ? void 0 : s2.uri);
      if (!((r3 = n4 == null ? void 0 : n4.relay) != null && r3.protocol)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i3.setError(M2.malformed_pairing_uri), new Error(a5);
      }
      if (!(n4 != null && n4.symKey)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i3.setError(M2.malformed_pairing_uri), new Error(a5);
      }
      if (n4 != null && n4.expiryTimestamp && (0, import_time2.toMiliseconds)(n4 == null ? void 0 : n4.expiryTimestamp) < Date.now()) {
        i3.setError(M2.pairing_expired);
        const { message: a5 } = xe("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a5);
      }
    }, this.isValidPing = async (s2) => {
      if (!Ah(s2)) {
        const { message: r3 } = xe("MISSING_OR_INVALID", `ping() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i3 } = s2;
      await this.isValidPairingTopic(i3);
    }, this.isValidDisconnect = async (s2) => {
      if (!Ah(s2)) {
        const { message: r3 } = xe("MISSING_OR_INVALID", `disconnect() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i3 } = s2;
      await this.isValidPairingTopic(i3);
    }, this.isValidPairingTopic = async (s2) => {
      if (!Yt(s2, false)) {
        const { message: i3 } = xe("MISSING_OR_INVALID", `pairing topic should be a string: ${s2}`);
        throw new Error(i3);
      }
      if (!this.pairings.keys.includes(s2)) {
        const { message: i3 } = xe("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s2}`);
        throw new Error(i3);
      }
      if (xs(this.pairings.get(s2).expiry)) {
        await this.deletePairing(s2);
        const { message: i3 } = xe("EXPIRED", `pairing topic: ${s2}`);
        throw new Error(i3);
      }
    }, this.core = e2, this.logger = E(t, this.name), this.pairings = new ai(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(w3.message, async (e2) => {
      const { topic: t, message: s2, transportType: i3 } = e2;
      if (!this.pairings.keys.includes(t) || i3 === F.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s2))) return;
      const r3 = await this.core.crypto.decode(t, s2);
      try {
        isJsonRpcRequest(r3) ? (this.core.history.set(t, r3), this.onRelayEventRequest({ topic: t, payload: r3 })) : isJsonRpcResponse(r3) && (await this.core.history.resolve(r3), await this.onRelayEventResponse({ topic: t, payload: r3 }), this.core.history.delete(t, r3.id));
      } catch (n4) {
        this.logger.error(n4);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(R.expired, async (e2) => {
      const { topic: t } = ys(e2.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(q.expire, { topic: t }));
    });
  }
};
var hi = class extends h2 {
  constructor(e2, t) {
    super(e2, t), this.core = e2, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events7.EventEmitter(), this.name = ft, this.version = _t, this.cached = [], this.initialized = false, this.storagePrefix = O2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.records.set(s2.id, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (s2, i3, r3) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: s2, request: i3, chainId: r3 }), this.records.has(i3.id)) return;
      const n4 = { id: i3.id, topic: s2, request: { method: i3.method, params: i3.params || null }, chainId: r3, expiry: ws(import_time2.THIRTY_DAYS) };
      this.records.set(n4.id, n4), this.persist(), this.events.emit(P.created, n4);
    }, this.resolve = async (s2) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: s2 }), !this.records.has(s2.id)) return;
      const i3 = await this.getRecord(s2.id);
      typeof i3.response > "u" && (i3.response = isJsonRpcError(s2) ? { error: s2.error } : { result: s2.result }, this.records.set(i3.id, i3), this.persist(), this.events.emit(P.updated, i3));
    }, this.get = async (s2, i3) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: s2, id: i3 }), await this.getRecord(i3)), this.delete = (s2, i3) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i3 }), this.values.forEach((r3) => {
        if (r3.topic === s2) {
          if (typeof i3 < "u" && r3.id !== i3) return;
          this.records.delete(r3.id), this.events.emit(P.deleted, r3);
        }
      }), this.persist();
    }, this.exists = async (s2, i3) => (this.isInitialized(), this.records.has(i3) ? (await this.getRecord(i3)).topic === s2 : false), this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e2 = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const s2 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e2.push(s2);
    }), e2;
  }
  async setJsonRpcRecords(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e2) {
    this.isInitialized();
    const t = this.records.get(e2);
    if (!t) {
      const { message: s2 } = xe("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(P.sync);
  }
  async restore() {
    try {
      const e2 = await this.getJsonRpcRecords();
      if (typeof e2 > "u" || !e2.length) return;
      if (this.records.size) {
        const { message: t } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e2);
    }
  }
  registerEventListeners() {
    this.events.on(P.created, (e2) => {
      const t = P.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 });
    }), this.events.on(P.updated, (e2) => {
      const t = P.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 });
    }), this.events.on(P.deleted, (e2) => {
      const t = P.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 });
    }), this.core.heartbeat.on(r.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e2 = false;
      this.records.forEach((t) => {
        (0, import_time2.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(P.deleted, t, false), e2 = true);
      }), e2 && this.persist();
    } catch (e2) {
      this.logger.warn(e2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var li = class extends x2 {
  constructor(e2, t) {
    super(e2, t), this.core = e2, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events7.EventEmitter(), this.name = Et, this.version = vt, this.cached = [], this.initialized = false, this.storagePrefix = O2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.expirations.set(s2.target, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (s2) => {
      try {
        const i3 = this.formatTarget(s2);
        return typeof this.getExpiration(i3) < "u";
      } catch {
        return false;
      }
    }, this.set = (s2, i3) => {
      this.isInitialized();
      const r3 = this.formatTarget(s2), n4 = { target: r3, expiry: i3 };
      this.expirations.set(r3, n4), this.checkExpiry(r3, n4), this.events.emit(R.created, { target: r3, expiration: n4 });
    }, this.get = (s2) => {
      this.isInitialized();
      const i3 = this.formatTarget(s2);
      return this.getExpiration(i3);
    }, this.del = (s2) => {
      if (this.isInitialized(), this.has(s2)) {
        const i3 = this.formatTarget(s2), r3 = this.getExpiration(i3);
        this.expirations.delete(i3), this.events.emit(R.deleted, { target: i3, expiration: r3 });
      }
    }, this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e2) {
    if (typeof e2 == "string") return As(e2);
    if (typeof e2 == "number") return bs(e2);
    const { message: t } = xe("UNKNOWN_TYPE", `Target type: ${typeof e2}`);
    throw new Error(t);
  }
  async setExpirations(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(R.sync);
  }
  async restore() {
    try {
      const e2 = await this.getExpirations();
      if (typeof e2 > "u" || !e2.length) return;
      if (this.expirations.size) {
        const { message: t } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e2);
    }
  }
  getExpiration(e2) {
    const t = this.expirations.get(e2);
    if (!t) {
      const { message: s2 } = xe("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw this.logger.warn(s2), new Error(s2);
    }
    return t;
  }
  checkExpiry(e2, t) {
    const { expiry: s2 } = t;
    (0, import_time2.toMiliseconds)(s2) - Date.now() <= 0 && this.expire(e2, t);
  }
  expire(e2, t) {
    this.expirations.delete(e2), this.events.emit(R.expired, { target: e2, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e2, t) => this.checkExpiry(t, e2));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r.pulse, () => this.checkExpirations()), this.events.on(R.created, (e2) => {
      const t = R.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
    }), this.events.on(R.expired, (e2) => {
      const t = R.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
    }), this.events.on(R.deleted, (e2) => {
      const t = R.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var y5 = {};
Object.defineProperty(y5, "__esModule", { value: true }), y5.getLocalStorage = y5.getLocalStorageOrThrow = y5.getCrypto = y5.getCryptoOrThrow = y5.getLocation = y5.getLocationOrThrow = y5.getNavigator = y5.getNavigatorOrThrow = ui = y5.getDocument = y5.getDocumentOrThrow = y5.getFromWindowOrThrow = y5.getFromWindow = void 0;
function U2(o5) {
  let e2;
  return typeof window < "u" && typeof window[o5] < "u" && (e2 = window[o5]), e2;
}
y5.getFromWindow = U2;
function G(o5) {
  const e2 = U2(o5);
  if (!e2) throw new Error(`${o5} is not defined in Window`);
  return e2;
}
y5.getFromWindowOrThrow = G;
function yn() {
  return G("document");
}
y5.getDocumentOrThrow = yn;
function Dn() {
  return U2("document");
}
var ui = y5.getDocument = Dn;
function mn() {
  return G("navigator");
}
y5.getNavigatorOrThrow = mn;
function bn() {
  return U2("navigator");
}
y5.getNavigator = bn;
function fn() {
  return G("location");
}
y5.getLocationOrThrow = fn;
function _n() {
  return U2("location");
}
y5.getLocation = _n;
function En() {
  return G("crypto");
}
y5.getCryptoOrThrow = En;
function vn() {
  return U2("crypto");
}
y5.getCrypto = vn;
function wn() {
  return G("localStorage");
}
y5.getLocalStorageOrThrow = wn;
function In() {
  return U2("localStorage");
}
y5.getLocalStorage = In;
var di = class extends y3 {
  constructor(e2, t, s2) {
    super(e2, t, s2), this.core = e2, this.logger = t, this.store = s2, this.name = wt, this.verifyUrlV3 = Tt, this.storagePrefix = O2, this.version = fe, this.init = async () => {
      var i3;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time2.toMiliseconds)((i3 = this.publicKey) == null ? void 0 : i3.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }, this.register = async (i3) => {
      if (!gr() || this.isDevEnv) return;
      const r3 = window.location.origin, { id: n4, decryptedId: a5 } = i3, c5 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r3}&id=${n4}&decryptedId=${a5}`;
      try {
        const h4 = ui(), d3 = this.startAbortTimer(import_time2.ONE_SECOND * 5), g3 = await new Promise((m2, b3) => {
          const l4 = () => {
            window.removeEventListener("message", E4), h4.body.removeChild(p4), b3("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", l4);
          const p4 = h4.createElement("iframe");
          p4.src = c5, p4.style.display = "none", p4.addEventListener("error", l4, { signal: this.abortController.signal });
          const E4 = (D3) => {
            if (D3.data && typeof D3.data == "string") try {
              const f4 = JSON.parse(D3.data);
              if (f4.type === "verify_attestation") {
                if (decodeJWT(f4.attestation).payload.id !== n4) return;
                clearInterval(d3), h4.body.removeChild(p4), this.abortController.signal.removeEventListener("abort", l4), window.removeEventListener("message", E4), m2(f4.attestation === null ? "" : f4.attestation);
              }
            } catch (f4) {
              this.logger.warn(f4);
            }
          };
          h4.body.appendChild(p4), window.addEventListener("message", E4, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", g3), g3;
      } catch (h4) {
        this.logger.warn(h4);
      }
      return "";
    }, this.resolve = async (i3) => {
      if (this.isDevEnv) return "";
      const { attestationId: r3, hash: n4, encryptedId: a5 } = i3;
      if (r3 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (r3) {
        if (decodeJWT(r3).payload.id !== a5) return;
        const h4 = await this.isValidJwtAttestation(r3);
        if (h4) {
          if (!h4.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h4;
        }
      }
      if (!n4) return;
      const c5 = this.getVerifyUrl(i3 == null ? void 0 : i3.verifyUrl);
      return this.fetchAttestation(n4, c5);
    }, this.fetchAttestation = async (i3, r3) => {
      this.logger.debug(`resolving attestation: ${i3} from url: ${r3}`);
      const n4 = this.startAbortTimer(import_time2.ONE_SECOND * 5), a5 = await fetch(`${r3}/attestation/${i3}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(n4), a5.status === 200 ? await a5.json() : void 0;
    }, this.getVerifyUrl = (i3) => {
      let r3 = i3 || Z;
      return Ct.includes(r3) || (this.logger.info(`verify url: ${r3}, not included in trusted list, assigning default: ${Z}`), r3 = Z), r3;
    }, this.fetchPublicKey = async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i3 = this.startAbortTimer(import_time2.FIVE_SECONDS), r3 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i3), await r3.json();
      } catch (i3) {
        this.logger.warn(i3);
      }
    }, this.persistPublicKey = async (i3) => {
      this.logger.debug("persisting public key to local storage", i3), await this.store.setItem(this.storeKey, i3), this.publicKey = i3;
    }, this.removePublicKey = async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }, this.isValidJwtAttestation = async (i3) => {
      const r3 = await this.getPublicKey();
      try {
        if (r3) return this.validateAttestation(i3, r3);
      } catch (a5) {
        this.logger.error(a5), this.logger.warn("error validating attestation");
      }
      const n4 = await this.fetchAndPersistPublicKey();
      try {
        if (n4) return this.validateAttestation(i3, n4);
      } catch (a5) {
        this.logger.error(a5), this.logger.warn("error validating attestation");
      }
    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (r3) => {
        const n4 = await this.fetchPublicKey();
        n4 && (await this.persistPublicKey(n4), r3(n4));
      });
      const i3 = await this.fetchPromise;
      return this.fetchPromise = void 0, i3;
    }, this.validateAttestation = (i3, r3) => {
      const n4 = Lu(i3, r3.publicKey), a5 = { hasExpired: (0, import_time2.toMiliseconds)(n4.exp) < Date.now(), payload: n4 };
      if (a5.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a5.payload.origin, isScam: a5.payload.isScam, isVerified: a5.payload.isVerified };
    }, this.logger = E(t, this.name), this.abortController = new AbortController(), this.isDevEnv = _s(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y(this.logger);
  }
  startAbortTimer(e2) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time2.toMiliseconds)(e2));
  }
};
var gi = class extends v {
  constructor(e2, t) {
    super(e2, t), this.projectId = e2, this.logger = t, this.context = St, this.registerDeviceToken = async (s2) => {
      const { clientId: i3, token: r3, notificationType: n4, enableEncrypted: a5 = false } = s2, c5 = `${Pt}/${this.projectId}/clients`;
      await fetch(c5, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i3, type: n4, token: r3, always_raw: a5 }) });
    }, this.logger = E(t, this.context);
  }
};
var Tn = Object.defineProperty;
var pi = Object.getOwnPropertySymbols;
var Cn = Object.prototype.hasOwnProperty;
var Sn = Object.prototype.propertyIsEnumerable;
var yi = (o5, e2, t) => e2 in o5 ? Tn(o5, e2, { enumerable: true, configurable: true, writable: true, value: t }) : o5[e2] = t;
var te = (o5, e2) => {
  for (var t in e2 || (e2 = {})) Cn.call(e2, t) && yi(o5, t, e2[t]);
  if (pi) for (var t of pi(e2)) Sn.call(e2, t) && yi(o5, t, e2[t]);
  return o5;
};
var Di = class extends C {
  constructor(e2, t, s2 = true) {
    super(e2, t, s2), this.core = e2, this.logger = t, this.context = xt, this.storagePrefix = O2, this.storageVersion = Rt, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = false, this.init = async () => {
      if (!_s()) try {
        const i3 = { eventId: Ns(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Pn(this.core.relayer.protocol, this.core.relayer.version, oe) } } };
        await this.sendEvent([i3]);
      } catch (i3) {
        this.logger.warn(i3);
      }
    }, this.createEvent = (i3) => {
      const { event: r3 = "ERROR", type: n4 = "", properties: { topic: a5, trace: c5 } } = i3, h4 = Ns(), d3 = this.core.projectId || "", g3 = Date.now(), m2 = te({ eventId: h4, timestamp: g3, props: { event: r3, type: n4, properties: { topic: a5, trace: c5 } }, bundleId: d3, domain: this.getAppDomain() }, this.setMethods(h4));
      return this.telemetryEnabled && (this.events.set(h4, m2), this.shouldPersist = true), m2;
    }, this.getEvent = (i3) => {
      const { eventId: r3, topic: n4 } = i3;
      if (r3) return this.events.get(r3);
      const a5 = Array.from(this.events.values()).find((c5) => c5.props.properties.topic === n4);
      if (a5) return te(te({}, a5), this.setMethods(a5.eventId));
    }, this.deleteEvent = (i3) => {
      const { eventId: r3 } = i3;
      this.events.delete(r3), this.shouldPersist = true;
    }, this.setEventListeners = () => {
      this.core.heartbeat.on(r.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i3) => {
          (0, import_time2.fromMiliseconds)(Date.now()) - (0, import_time2.fromMiliseconds)(i3.timestamp) > Ot && (this.events.delete(i3.eventId), this.shouldPersist = true);
        });
      });
    }, this.setMethods = (i3) => ({ addTrace: (r3) => this.addTrace(i3, r3), setError: (r3) => this.setError(i3, r3) }), this.addTrace = (i3, r3) => {
      const n4 = this.events.get(i3);
      n4 && (n4.props.properties.trace.push(r3), this.events.set(i3, n4), this.shouldPersist = true);
    }, this.setError = (i3, r3) => {
      const n4 = this.events.get(i3);
      n4 && (n4.props.type = r3, n4.timestamp = Date.now(), this.events.set(i3, n4), this.shouldPersist = true);
    }, this.persist = async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }, this.restore = async () => {
      try {
        const i3 = await this.core.storage.getItem(this.storageKey) || [];
        if (!i3.length) return;
        i3.forEach((r3) => {
          this.events.set(r3.eventId, te(te({}, r3), this.setMethods(r3.eventId)));
        });
      } catch (i3) {
        this.logger.warn(i3);
      }
    }, this.submit = async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const i3 = [];
      for (const [r3, n4] of this.events) n4.props.type && i3.push(n4);
      if (i3.length !== 0) try {
        if ((await this.sendEvent(i3)).ok) for (const r3 of i3) this.events.delete(r3.eventId), this.shouldPersist = true;
      } catch (r3) {
        this.logger.warn(r3);
      }
    }, this.sendEvent = async (i3) => {
      const r3 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${At}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${oe}${r3}`, { method: "POST", body: JSON.stringify(i3) });
    }, this.getAppDomain = () => fs().url, this.logger = E(t, this.context), this.telemetryEnabled = s2, s2 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var Pn2 = Object.defineProperty;
var mi = Object.getOwnPropertySymbols;
var Rn = Object.prototype.hasOwnProperty;
var xn = Object.prototype.propertyIsEnumerable;
var bi2 = (o5, e2, t) => e2 in o5 ? Pn2(o5, e2, { enumerable: true, configurable: true, writable: true, value: t }) : o5[e2] = t;
var fi = (o5, e2) => {
  for (var t in e2 || (e2 = {})) Rn.call(e2, t) && bi2(o5, t, e2[t]);
  if (mi) for (var t of mi(e2)) xn.call(e2, t) && bi2(o5, t, e2[t]);
  return o5;
};
var ce = class _ce extends n2 {
  constructor(e2) {
    var t;
    super(e2), this.protocol = be, this.version = fe, this.name = ne, this.events = new import_events7.EventEmitter(), this.initialized = false, this.on = (n4, a5) => this.events.on(n4, a5), this.once = (n4, a5) => this.events.once(n4, a5), this.off = (n4, a5) => this.events.off(n4, a5), this.removeListener = (n4, a5) => this.events.removeListener(n4, a5), this.dispatchEnvelope = ({ topic: n4, message: a5, sessionExists: c5 }) => {
      if (!n4 || !a5) return;
      const h4 = { topic: n4, message: a5, publishedAt: Date.now(), transportType: F.link_mode };
      this.relayer.onLinkMessageEvent(h4, { sessionExists: c5 });
    }, this.projectId = e2 == null ? void 0 : e2.projectId, this.relayUrl = (e2 == null ? void 0 : e2.relayUrl) || Ee, this.customStoragePrefix = e2 != null && e2.customStoragePrefix ? `:${e2.customStoragePrefix}` : "";
    const s2 = k({ level: typeof (e2 == null ? void 0 : e2.logger) == "string" && e2.logger ? e2.logger : Xe.logger }), { logger: i3, chunkLoggerController: r3 } = A({ opts: s2, maxSizeInBytes: e2 == null ? void 0 : e2.maxLogBlobSizeInBytes, loggerOverride: e2 == null ? void 0 : e2.logger });
    this.logChunkController = r3, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var n4, a5;
      (n4 = this.logChunkController) != null && n4.downloadLogsBlobInBrowser && ((a5 = this.logChunkController) == null || a5.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E(i3, this.name), this.heartbeat = new i(), this.crypto = new Wt(this, this.logger, e2 == null ? void 0 : e2.keychain), this.history = new hi(this, this.logger), this.expirer = new li(this, this.logger), this.storage = e2 != null && e2.storage ? e2.storage : new h(fi(fi({}, Ze2), e2 == null ? void 0 : e2.storageOptions)), this.relayer = new si({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new ci(this, this.logger), this.verify = new di(this, this.logger, this.storage), this.echoClient = new gi(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Di(this, this.logger, e2 == null ? void 0 : e2.telemetryEnabled);
  }
  static async init(e2) {
    const t = new _ce(e2);
    await t.initialize();
    const s2 = await t.crypto.getClientId();
    return await t.storage.setItem(gt, s2), t;
  }
  get context() {
    return y(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e2;
    return (e2 = this.logChunkController) == null ? void 0 : e2.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e2) {
    this.linkModeSupportedApps.includes(e2) || (this.linkModeSupportedApps.push(e2), await this.storage.setItem(ve, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.eventClient.init(), this.linkModeSupportedApps = await this.storage.getItem(ve) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e2) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e2), this.logger.error(e2.message), e2;
    }
  }
};
var On = ce;

// node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events8 = __toESM(require_events());
var import_time3 = __toESM(require_cjs());
var be2 = "wc";
var Ce2 = 2;
var Le = "client";
var ye = `${be2}@${Ce2}:${Le}:`;
var we2 = { name: Le, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var xe2 = "WALLETCONNECT_DEEPLINK_CHOICE";
var st2 = "proposal";
var it2 = "Proposal expired";
var rt2 = "session";
var z3 = import_time3.SEVEN_DAYS;
var nt2 = "engine";
var v2 = { wc_sessionPropose: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time3.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time3.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var me2 = { min: import_time3.FIVE_MINUTES, max: import_time3.SEVEN_DAYS };
var x3 = { idle: "IDLE", active: "ACTIVE" };
var ot2 = "request";
var at2 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var ct2 = "wc";
var lt2 = "auth";
var pt2 = "authKeys";
var ht2 = "pairingTopics";
var dt2 = "requests";
var oe2 = `${ct2}@${1.5}:${lt2}:`;
var ae2 = `${oe2}:PUB_KEY`;
var ys2 = Object.defineProperty;
var ws2 = Object.defineProperties;
var ms2 = Object.getOwnPropertyDescriptors;
var ut2 = Object.getOwnPropertySymbols;
var _s2 = Object.prototype.hasOwnProperty;
var Es2 = Object.prototype.propertyIsEnumerable;
var gt2 = (q2, o5, e2) => o5 in q2 ? ys2(q2, o5, { enumerable: true, configurable: true, writable: true, value: e2 }) : q2[o5] = e2;
var I2 = (q2, o5) => {
  for (var e2 in o5 || (o5 = {})) _s2.call(o5, e2) && gt2(q2, e2, o5[e2]);
  if (ut2) for (var e2 of ut2(o5)) Es2.call(o5, e2) && gt2(q2, e2, o5[e2]);
  return q2;
};
var D2 = (q2, o5) => ws2(q2, ms2(o5));
var Rs2 = class extends M {
  constructor(o5) {
    super(o5), this.name = nt2, this.events = new import_events8.default(), this.initialized = false, this.requestQueue = { state: x3.idle, queue: [] }, this.sessionRequestQueue = { state: x3.idle, queue: [] }, this.requestQueueDelay = import_time3.ONE_SECOND, this.expectedPairingMethodMap = /* @__PURE__ */ new Map(), this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(v2) }), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay)));
    }, this.connect = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const t = D2(I2({}, e2), { requiredNamespaces: e2.requiredNamespaces || {}, optionalNamespaces: e2.optionalNamespaces || {} });
      await this.isValidConnect(t);
      const { pairingTopic: s2, requiredNamespaces: i3, optionalNamespaces: r3, sessionProperties: n4, relays: a5 } = t;
      let c5 = s2, h4, p4 = false;
      try {
        c5 && (p4 = this.client.core.pairing.pairings.get(c5).active);
      } catch (E4) {
        throw this.client.logger.error(`connect() -> pairing.get(${c5}) failed`), E4;
      }
      if (!c5 || !p4) {
        const { topic: E4, uri: S3 } = await this.client.core.pairing.create();
        c5 = E4, h4 = S3;
      }
      if (!c5) {
        const { message: E4 } = xe("NO_MATCHING_KEY", `connect() pairing topic: ${c5}`);
        throw new Error(E4);
      }
      const d3 = await this.client.core.crypto.generateKeyPair(), l4 = v2.wc_sessionPropose.req.ttl || import_time3.FIVE_MINUTES, w5 = ws(l4), m2 = I2({ requiredNamespaces: i3, optionalNamespaces: r3, relays: a5 ?? [{ protocol: at }], proposer: { publicKey: d3, metadata: this.client.metadata }, expiryTimestamp: w5, pairingTopic: c5 }, n4 && { sessionProperties: n4 }), { reject: y6, resolve: _3, done: R2 } = gs(l4, it2);
      this.events.once(Ms("session_connect"), async ({ error: E4, session: S3 }) => {
        if (E4) y6(E4);
        else if (S3) {
          S3.self.publicKey = d3;
          const M3 = D2(I2({}, S3), { pairingTopic: m2.pairingTopic, requiredNamespaces: m2.requiredNamespaces, optionalNamespaces: m2.optionalNamespaces, transportType: F.relay });
          await this.client.session.set(S3.topic, M3), await this.setExpiry(S3.topic, S3.expiry), c5 && await this.client.core.pairing.updateMetadata({ topic: c5, metadata: S3.peer.metadata }), this.cleanupDuplicatePairings(M3), _3(M3);
        }
      });
      const V = await this.sendRequest({ topic: c5, method: "wc_sessionPropose", params: m2, throwOnFailedPublish: true });
      return await this.setProposal(V, I2({ id: V }, m2)), { uri: h4, approval: R2 };
    }, this.pair = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(e2);
      } catch (t) {
        throw this.client.logger.error("pair() failed"), t;
      }
    }, this.approve = async (e2) => {
      var t, s2, i3;
      const r3 = this.client.core.eventClient.createEvent({ properties: { topic: (t = e2 == null ? void 0 : e2.id) == null ? void 0 : t.toString(), trace: [Cs.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (N2) {
        throw r3.setError(Ss2.no_internet_connection), N2;
      }
      try {
        await this.isValidProposalId(e2 == null ? void 0 : e2.id);
      } catch (N2) {
        throw this.client.logger.error(`approve() -> proposal.get(${e2 == null ? void 0 : e2.id}) failed`), r3.setError(Ss2.proposal_not_found), N2;
      }
      try {
        await this.isValidApprove(e2);
      } catch (N2) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r3.setError(Ss2.session_approve_namespace_validation_failure), N2;
      }
      const { id: n4, relayProtocol: a5, namespaces: c5, sessionProperties: h4, sessionConfig: p4 } = e2, d3 = this.client.proposal.get(n4);
      this.client.core.eventClient.deleteEvent({ eventId: r3.eventId });
      const { pairingTopic: l4, proposer: w5, requiredNamespaces: m2, optionalNamespaces: y6 } = d3;
      let _3 = (s2 = this.client.core.eventClient) == null ? void 0 : s2.getEvent({ topic: l4 });
      _3 || (_3 = (i3 = this.client.core.eventClient) == null ? void 0 : i3.createEvent({ type: Cs.session_approve_started, properties: { topic: l4, trace: [Cs.session_approve_started, Cs.session_namespaces_validation_success] } }));
      const R2 = await this.client.core.crypto.generateKeyPair(), V = w5.publicKey, E4 = await this.client.core.crypto.generateSharedKey(R2, V), S3 = I2(I2({ relay: { protocol: a5 ?? "irn" }, namespaces: c5, controller: { publicKey: R2, metadata: this.client.metadata }, expiry: ws(z3) }, h4 && { sessionProperties: h4 }), p4 && { sessionConfig: p4 }), M3 = F.relay;
      _3.addTrace(Cs.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(E4, { transportType: M3 });
      } catch (N2) {
        throw _3.setError(Ss2.subscribe_session_topic_failure), N2;
      }
      _3.addTrace(Cs.subscribe_session_topic_success);
      const W = D2(I2({}, S3), { topic: E4, requiredNamespaces: m2, optionalNamespaces: y6, pairingTopic: l4, acknowledged: false, self: S3.controller, peer: { publicKey: w5.publicKey, metadata: w5.metadata }, controller: R2, transportType: F.relay });
      await this.client.session.set(E4, W), _3.addTrace(Cs.store_session);
      try {
        _3.addTrace(Cs.publishing_session_settle), await this.sendRequest({ topic: E4, method: "wc_sessionSettle", params: S3, throwOnFailedPublish: true }).catch((N2) => {
          throw _3 == null ? void 0 : _3.setError(Ss2.session_settle_publish_failure), N2;
        }), _3.addTrace(Cs.session_settle_publish_success), _3.addTrace(Cs.publishing_session_approve), await this.sendResult({ id: n4, topic: l4, result: { relay: { protocol: a5 ?? "irn" }, responderPublicKey: R2 }, throwOnFailedPublish: true }).catch((N2) => {
          throw _3 == null ? void 0 : _3.setError(Ss2.session_approve_publish_failure), N2;
        }), _3.addTrace(Cs.session_approve_publish_success);
      } catch (N2) {
        throw this.client.logger.error(N2), this.client.session.delete(E4, er("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(E4), N2;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: _3.eventId }), await this.client.core.pairing.updateMetadata({ topic: l4, metadata: w5.metadata }), await this.client.proposal.delete(n4, er("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: l4 }), await this.setExpiry(E4, ws(z3)), { topic: E4, acknowledged: () => Promise.resolve(this.client.session.get(E4)) };
    }, this.reject = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(e2);
      } catch (r3) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r3;
      }
      const { id: t, reason: s2 } = e2;
      let i3;
      try {
        i3 = this.client.proposal.get(t).pairingTopic;
      } catch (r3) {
        throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r3;
      }
      i3 && (await this.sendError({ id: t, topic: i3, error: s2, rpcOpts: v2.wc_sessionPropose.reject }), await this.client.proposal.delete(t, er("USER_DISCONNECTED")));
    }, this.update = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(e2);
      } catch (p4) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), p4;
      }
      const { topic: t, namespaces: s2 } = e2, { done: i3, resolve: r3, reject: n4 } = gs(), a5 = payloadId(), c5 = getBigIntRpcId().toString(), h4 = this.client.session.get(t).namespaces;
      return this.events.once(Ms("session_update", a5), ({ error: p4 }) => {
        p4 ? n4(p4) : r3();
      }), await this.client.session.update(t, { namespaces: s2 }), await this.sendRequest({ topic: t, method: "wc_sessionUpdate", params: { namespaces: s2 }, throwOnFailedPublish: true, clientRpcId: a5, relayRpcId: c5 }).catch((p4) => {
        this.client.logger.error(p4), this.client.session.update(t, { namespaces: h4 }), n4(p4);
      }), { acknowledged: i3 };
    }, this.extend = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(e2);
      } catch (a5) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a5;
      }
      const { topic: t } = e2, s2 = payloadId(), { done: i3, resolve: r3, reject: n4 } = gs();
      return this.events.once(Ms("session_extend", s2), ({ error: a5 }) => {
        a5 ? n4(a5) : r3();
      }), await this.setExpiry(t, ws(z3)), this.sendRequest({ topic: t, method: "wc_sessionExtend", params: {}, clientRpcId: s2, throwOnFailedPublish: true }).catch((a5) => {
        n4(a5);
      }), { acknowledged: i3 };
    }, this.request = async (e2) => {
      this.isInitialized();
      try {
        await this.isValidRequest(e2);
      } catch (w5) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), w5;
      }
      const { chainId: t, request: s2, topic: i3, expiry: r3 = v2.wc_sessionRequest.req.ttl } = e2, n4 = this.client.session.get(i3);
      (n4 == null ? void 0 : n4.transportType) === F.relay && await this.confirmOnlineStateOrThrow();
      const a5 = payloadId(), c5 = getBigIntRpcId().toString(), { done: h4, resolve: p4, reject: d3 } = gs(r3, "Request expired. Please try again.");
      this.events.once(Ms("session_request", a5), ({ error: w5, result: m2 }) => {
        w5 ? d3(w5) : p4(m2);
      });
      const l4 = this.getAppLinkIfEnabled(n4.peer.metadata, n4.transportType);
      return l4 ? (await this.sendRequest({ clientRpcId: a5, relayRpcId: c5, topic: i3, method: "wc_sessionRequest", params: { request: D2(I2({}, s2), { expiryTimestamp: ws(r3) }), chainId: t }, expiry: r3, throwOnFailedPublish: true, appLink: l4 }).catch((w5) => d3(w5)), this.client.events.emit("session_request_sent", { topic: i3, request: s2, chainId: t, id: a5 }), await h4()) : await Promise.all([new Promise(async (w5) => {
        await this.sendRequest({ clientRpcId: a5, relayRpcId: c5, topic: i3, method: "wc_sessionRequest", params: { request: D2(I2({}, s2), { expiryTimestamp: ws(r3) }), chainId: t }, expiry: r3, throwOnFailedPublish: true }).catch((m2) => d3(m2)), this.client.events.emit("session_request_sent", { topic: i3, request: s2, chainId: t, id: a5 }), w5();
      }), new Promise(async (w5) => {
        var m2;
        if (!((m2 = n4.sessionConfig) != null && m2.disableDeepLink)) {
          const y6 = await Ss(this.client.core.storage, xe2);
          await Es({ id: a5, topic: i3, wcDeepLink: y6 });
        }
        w5();
      }), h4()]).then((w5) => w5[2]);
    }, this.respond = async (e2) => {
      this.isInitialized(), await this.isValidRespond(e2);
      const { topic: t, response: s2 } = e2, { id: i3 } = s2, r3 = this.client.session.get(t);
      r3.transportType === F.relay && await this.confirmOnlineStateOrThrow();
      const n4 = this.getAppLinkIfEnabled(r3.peer.metadata, r3.transportType);
      isJsonRpcResult(s2) ? await this.sendResult({ id: i3, topic: t, result: s2.result, throwOnFailedPublish: true, appLink: n4 }) : isJsonRpcError(s2) && await this.sendError({ id: i3, topic: t, error: s2.error, appLink: n4 }), this.cleanupAfterResponse(e2);
    }, this.ping = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(e2);
      } catch (s2) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s2;
      }
      const { topic: t } = e2;
      if (this.client.session.keys.includes(t)) {
        const s2 = payloadId(), i3 = getBigIntRpcId().toString(), { done: r3, resolve: n4, reject: a5 } = gs();
        this.events.once(Ms("session_ping", s2), ({ error: c5 }) => {
          c5 ? a5(c5) : n4();
        }), await Promise.all([this.sendRequest({ topic: t, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s2, relayRpcId: i3 }), r3()]);
      } else this.client.core.pairing.pairings.keys.includes(t) && await this.client.core.pairing.ping({ topic: t });
    }, this.emit = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e2);
      const { topic: t, event: s2, chainId: i3 } = e2, r3 = getBigIntRpcId().toString();
      await this.sendRequest({ topic: t, method: "wc_sessionEvent", params: { event: s2, chainId: i3 }, throwOnFailedPublish: true, relayRpcId: r3 });
    }, this.disconnect = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e2);
      const { topic: t } = e2;
      if (this.client.session.keys.includes(t)) await this.sendRequest({ topic: t, method: "wc_sessionDelete", params: er("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: t, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({ topic: t });
      else {
        const { message: s2 } = xe("MISMATCHED_TOPIC", `Session or pairing topic not found: ${t}`);
        throw new Error(s2);
      }
    }, this.find = (e2) => (this.isInitialized(), this.client.session.getAll().filter((t) => hh(t, e2))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (e2, t) => {
      var s2;
      this.isInitialized(), this.isValidAuthenticate(e2);
      const i3 = t && this.client.core.linkModeSupportedApps.includes(t) && ((s2 = this.client.metadata.redirect) == null ? void 0 : s2.linkMode), r3 = i3 ? F.link_mode : F.relay;
      r3 === F.relay && await this.confirmOnlineStateOrThrow();
      const { chains: n4, statement: a5 = "", uri: c5, domain: h4, nonce: p4, type: d3, exp: l4, nbf: w5, methods: m2 = [], expiry: y6 } = e2, _3 = [...e2.resources || []], { topic: R2, uri: V } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r3 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: R2, uri: V } });
      const E4 = await this.client.core.crypto.generateKeyPair(), S3 = Ru(E4);
      if (await Promise.all([this.client.auth.authKeys.set(ae2, { responseTopic: S3, publicKey: E4 }), this.client.auth.pairingTopics.set(S3, { topic: S3, pairingTopic: R2 })]), await this.client.core.relayer.subscribe(S3, { transportType: r3 }), this.client.logger.info(`sending request to new pairing topic: ${R2}`), m2.length > 0) {
        const { namespace: O4 } = An(n4[0]);
        let T3 = xu(O4, "request", m2);
        Vr(_3) && (T3 = Mu(T3, _3.pop())), _3.push(T3);
      }
      const M3 = y6 && y6 > v2.wc_sessionAuthenticate.req.ttl ? y6 : v2.wc_sessionAuthenticate.req.ttl, W = { authPayload: { type: d3 ?? "caip122", chains: n4, statement: a5, aud: c5, domain: h4, version: "1", nonce: p4, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: l4, nbf: w5, resources: _3 }, requester: { publicKey: E4, metadata: this.client.metadata }, expiryTimestamp: ws(M3) }, N2 = { eip155: { chains: n4, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m2])], events: ["chainChanged", "accountsChanged"] } }, De = { requiredNamespaces: {}, optionalNamespaces: N2, relays: [{ protocol: "irn" }], pairingTopic: R2, proposer: { publicKey: E4, metadata: this.client.metadata }, expiryTimestamp: ws(v2.wc_sessionPropose.req.ttl) }, { done: wt2, resolve: Ve, reject: Ee2 } = gs(M3, "Request expired"), ce2 = async ({ error: O4, session: T3 }) => {
        if (this.events.off(Ms("session_request", G2), Re2), O4) Ee2(O4);
        else if (T3) {
          T3.self.publicKey = E4, await this.client.session.set(T3.topic, T3), await this.setExpiry(T3.topic, T3.expiry), R2 && await this.client.core.pairing.updateMetadata({ topic: R2, metadata: T3.peer.metadata });
          const le2 = this.client.session.get(T3.topic);
          await this.deleteProposal(Z2), Ve({ session: le2 });
        }
      }, Re2 = async (O4) => {
        var T3, le2, Me;
        if (await this.deletePendingAuthRequest(G2, { message: "fulfilled", code: 0 }), O4.error) {
          const te2 = er("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return O4.error.code === te2.code ? void 0 : (this.events.off(Ms("session_connect"), ce2), Ee2(O4.error.message));
        }
        await this.deleteProposal(Z2), this.events.off(Ms("session_connect"), ce2);
        const { cacaos: ke, responder: j4 } = O4.result, Ie2 = [], $e = [];
        for (const te2 of ke) {
          await mu({ cacao: te2, projectId: this.client.core.projectId }) || (this.client.logger.error(te2, "Signature verification failed"), Ee2(er("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: fe2 } = te2, ve2 = Vr(fe2.resources), Ke = [gu(fe2.iss)], mt2 = Vi(fe2.iss);
          if (ve2) {
            const qe = Eu(ve2), _t2 = Su(ve2);
            Ie2.push(...qe), Ke.push(..._t2);
          }
          for (const qe of Ke) $e.push(`${qe}:${mt2}`);
        }
        const ee2 = await this.client.core.crypto.generateSharedKey(E4, j4.publicKey);
        let pe;
        Ie2.length > 0 && (pe = { topic: ee2, acknowledged: true, self: { publicKey: E4, metadata: this.client.metadata }, peer: j4, controller: j4.publicKey, expiry: ws(z3), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: R2, namespaces: uh([...new Set(Ie2)], [...new Set($e)]), transportType: r3 }, await this.client.core.relayer.subscribe(ee2, { transportType: r3 }), await this.client.session.set(ee2, pe), R2 && await this.client.core.pairing.updateMetadata({ topic: R2, metadata: j4.metadata }), pe = this.client.session.get(ee2)), (T3 = this.client.metadata.redirect) != null && T3.linkMode && (le2 = j4.metadata.redirect) != null && le2.linkMode && (Me = j4.metadata.redirect) != null && Me.universal && t && (this.client.core.addLinkModeSupportedApp(j4.metadata.redirect.universal), this.client.session.update(ee2, { transportType: F.link_mode })), Ve({ auths: ke, session: pe });
      }, G2 = payloadId(), Z2 = payloadId();
      this.events.once(Ms("session_connect"), ce2), this.events.once(Ms("session_request", G2), Re2);
      let Se;
      try {
        if (i3) {
          const O4 = formatJsonRpcRequest("wc_sessionAuthenticate", W, G2);
          this.client.core.history.set(R2, O4);
          const T3 = await this.client.core.crypto.encode("", O4, { type: Sr, encoding: Iu });
          Se = Zu(t, R2, T3);
        } else await Promise.all([this.sendRequest({ topic: R2, method: "wc_sessionAuthenticate", params: W, expiry: e2.expiry, throwOnFailedPublish: true, clientRpcId: G2 }), this.sendRequest({ topic: R2, method: "wc_sessionPropose", params: De, expiry: v2.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: Z2 })]);
      } catch (O4) {
        throw this.events.off(Ms("session_connect"), ce2), this.events.off(Ms("session_request", G2), Re2), O4;
      }
      return await this.setProposal(Z2, I2({ id: Z2 }, De)), await this.setAuthRequest(G2, { request: D2(I2({}, W), { verifyContext: {} }), pairingTopic: R2, transportType: r3 }), { uri: Se ?? V, response: wt2 };
    }, this.approveSessionAuthenticate = async (e2) => {
      const { id: t, auths: s2 } = e2, i3 = this.client.core.eventClient.createEvent({ properties: { topic: t.toString(), trace: [Ps.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (y6) {
        throw i3.setError(Rs.no_internet_connection), y6;
      }
      const r3 = this.getPendingAuthRequest(t);
      if (!r3) throw i3.setError(Rs.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t}`);
      const n4 = r3.transportType || F.relay;
      n4 === F.relay && await this.confirmOnlineStateOrThrow();
      const a5 = r3.requester.publicKey, c5 = await this.client.core.crypto.generateKeyPair(), h4 = Ru(a5), p4 = { type: pr, receiverPublicKey: a5, senderPublicKey: c5 }, d3 = [], l4 = [];
      for (const y6 of s2) {
        if (!await mu({ cacao: y6, projectId: this.client.core.projectId })) {
          i3.setError(Rs.invalid_cacao);
          const S3 = er("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: t, topic: h4, error: S3, encodeOpts: p4 }), new Error(S3.message);
        }
        i3.addTrace(Ps.cacaos_verified);
        const { p: _3 } = y6, R2 = Vr(_3.resources), V = [gu(_3.iss)], E4 = Vi(_3.iss);
        if (R2) {
          const S3 = Eu(R2), M3 = Su(R2);
          d3.push(...S3), V.push(...M3);
        }
        for (const S3 of V) l4.push(`${S3}:${E4}`);
      }
      const w5 = await this.client.core.crypto.generateSharedKey(c5, a5);
      i3.addTrace(Ps.create_authenticated_session_topic);
      let m2;
      if ((d3 == null ? void 0 : d3.length) > 0) {
        m2 = { topic: w5, acknowledged: true, self: { publicKey: c5, metadata: this.client.metadata }, peer: { publicKey: a5, metadata: r3.requester.metadata }, controller: a5, expiry: ws(z3), authentication: s2, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r3.pairingTopic, namespaces: uh([...new Set(d3)], [...new Set(l4)]), transportType: n4 }, i3.addTrace(Ps.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(w5, { transportType: n4 });
        } catch (y6) {
          throw i3.setError(Rs.subscribe_authenticated_session_topic_failure), y6;
        }
        i3.addTrace(Ps.subscribe_authenticated_session_topic_success), await this.client.session.set(w5, m2), i3.addTrace(Ps.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r3.pairingTopic, metadata: r3.requester.metadata });
      }
      i3.addTrace(Ps.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: h4, id: t, result: { cacaos: s2, responder: { publicKey: c5, metadata: this.client.metadata } }, encodeOpts: p4, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r3.requester.metadata, n4) });
      } catch (y6) {
        throw i3.setError(Rs.authenticated_session_approve_publish_failure), y6;
      }
      return await this.client.auth.requests.delete(t, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r3.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i3.eventId }), { session: m2 };
    }, this.rejectSessionAuthenticate = async (e2) => {
      this.isInitialized();
      const { id: t, reason: s2 } = e2, i3 = this.getPendingAuthRequest(t);
      if (!i3) throw new Error(`Could not find pending auth request with id ${t}`);
      i3.transportType === F.relay && await this.confirmOnlineStateOrThrow();
      const r3 = i3.requester.publicKey, n4 = await this.client.core.crypto.generateKeyPair(), a5 = Ru(r3), c5 = { type: pr, receiverPublicKey: r3, senderPublicKey: n4 };
      await this.sendError({ id: t, topic: a5, error: s2, encodeOpts: c5, rpcOpts: v2.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i3.requester.metadata, i3.transportType) }), await this.client.auth.requests.delete(t, { message: "rejected", code: 0 }), await this.client.proposal.delete(t, er("USER_DISCONNECTED"));
    }, this.formatAuthMessage = (e2) => {
      this.isInitialized();
      const { request: t, iss: s2 } = e2;
      return Wf(t, s2);
    }, this.processRelayMessageCache = () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const e2 = this.relayMessageCache.shift();
          e2 && await this.onRelayMessage(e2);
        } catch (e2) {
          this.client.logger.error(e2);
        }
      }, 50);
    }, this.cleanupDuplicatePairings = async (e2) => {
      if (e2.pairingTopic) try {
        const t = this.client.core.pairing.pairings.get(e2.pairingTopic), s2 = this.client.core.pairing.pairings.getAll().filter((i3) => {
          var r3, n4;
          return ((r3 = i3.peerMetadata) == null ? void 0 : r3.url) && ((n4 = i3.peerMetadata) == null ? void 0 : n4.url) === e2.peer.metadata.url && i3.topic && i3.topic !== t.topic;
        });
        if (s2.length === 0) return;
        this.client.logger.info(`Cleaning up ${s2.length} duplicate pairing(s)`), await Promise.all(s2.map((i3) => this.client.core.pairing.disconnect({ topic: i3.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (t) {
        this.client.logger.error(t);
      }
    }, this.deleteSession = async (e2) => {
      var t;
      const { topic: s2, expirerHasDeleted: i3 = false, emitEvent: r3 = true, id: n4 = 0 } = e2, { self: a5 } = this.client.session.get(s2);
      await this.client.core.relayer.unsubscribe(s2), await this.client.session.delete(s2, er("USER_DISCONNECTED")), this.addToRecentlyDeleted(s2, "session"), this.client.core.crypto.keychain.has(a5.publicKey) && await this.client.core.crypto.deleteKeyPair(a5.publicKey), this.client.core.crypto.keychain.has(s2) && await this.client.core.crypto.deleteSymKey(s2), i3 || this.client.core.expirer.del(s2), this.client.core.storage.removeItem(xe2).catch((c5) => this.client.logger.warn(c5)), this.getPendingSessionRequests().forEach((c5) => {
        c5.topic === s2 && this.deletePendingSessionRequest(c5.id, er("USER_DISCONNECTED"));
      }), s2 === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = x3.idle), r3 && this.client.events.emit("session_delete", { id: n4, topic: s2 });
    }, this.deleteProposal = async (e2, t) => {
      if (t) try {
        const s2 = this.client.proposal.get(e2), i3 = this.client.core.eventClient.getEvent({ topic: s2.pairingTopic });
        i3 == null ? void 0 : i3.setError(Ss2.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(e2, er("USER_DISCONNECTED")), t ? Promise.resolve() : this.client.core.expirer.del(e2)]), this.addToRecentlyDeleted(e2, "proposal");
    }, this.deletePendingSessionRequest = async (e2, t, s2 = false) => {
      await Promise.all([this.client.pendingRequest.delete(e2, t), s2 ? Promise.resolve() : this.client.core.expirer.del(e2)]), this.addToRecentlyDeleted(e2, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i3) => i3.id !== e2), s2 && (this.sessionRequestQueue.state = x3.idle, this.client.events.emit("session_request_expire", { id: e2 }));
    }, this.deletePendingAuthRequest = async (e2, t, s2 = false) => {
      await Promise.all([this.client.auth.requests.delete(e2, t), s2 ? Promise.resolve() : this.client.core.expirer.del(e2)]);
    }, this.setExpiry = async (e2, t) => {
      this.client.session.keys.includes(e2) && (this.client.core.expirer.set(e2, t), await this.client.session.update(e2, { expiry: t }));
    }, this.setProposal = async (e2, t) => {
      this.client.core.expirer.set(e2, ws(v2.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e2, t);
    }, this.setAuthRequest = async (e2, t) => {
      const { request: s2, pairingTopic: i3, transportType: r3 = F.relay } = t;
      this.client.core.expirer.set(e2, s2.expiryTimestamp), await this.client.auth.requests.set(e2, { authPayload: s2.authPayload, requester: s2.requester, expiryTimestamp: s2.expiryTimestamp, id: e2, pairingTopic: i3, verifyContext: s2.verifyContext, transportType: r3 });
    }, this.setPendingSessionRequest = async (e2) => {
      const { id: t, topic: s2, params: i3, verifyContext: r3 } = e2, n4 = i3.request.expiryTimestamp || ws(v2.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(t, n4), await this.client.pendingRequest.set(t, { id: t, topic: s2, params: i3, verifyContext: r3 });
    }, this.sendRequest = async (e2) => {
      const { topic: t, method: s2, params: i3, expiry: r3, relayRpcId: n4, clientRpcId: a5, throwOnFailedPublish: c5, appLink: h4 } = e2, p4 = formatJsonRpcRequest(s2, i3, a5);
      let d3;
      const l4 = !!h4;
      try {
        const y6 = l4 ? Iu : tn;
        d3 = await this.client.core.crypto.encode(t, p4, { encoding: y6 });
      } catch (y6) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), y6;
      }
      let w5;
      if (at2.includes(s2)) {
        const y6 = Ou(JSON.stringify(p4)), _3 = Ou(d3);
        w5 = await this.client.core.verify.register({ id: _3, decryptedId: y6 });
      }
      const m2 = v2[s2].req;
      if (m2.attestation = w5, r3 && (m2.ttl = r3), n4 && (m2.id = n4), this.client.core.history.set(t, p4), l4) {
        const y6 = Zu(h4, t, d3);
        await global.Linking.openURL(y6, this.client.name);
      } else {
        const y6 = v2[s2].req;
        r3 && (y6.ttl = r3), n4 && (y6.id = n4), c5 ? (y6.internal = D2(I2({}, y6.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, d3, y6)) : this.client.core.relayer.publish(t, d3, y6).catch((_3) => this.client.logger.error(_3));
      }
      return p4.id;
    }, this.sendResult = async (e2) => {
      const { id: t, topic: s2, result: i3, throwOnFailedPublish: r3, encodeOpts: n4, appLink: a5 } = e2, c5 = formatJsonRpcResult(t, i3);
      let h4;
      const p4 = a5 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const l4 = p4 ? Iu : tn;
        h4 = await this.client.core.crypto.encode(s2, c5, D2(I2({}, n4 || {}), { encoding: l4 }));
      } catch (l4) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s2} failed`), l4;
      }
      let d3;
      try {
        d3 = await this.client.core.history.get(s2, t);
      } catch (l4) {
        throw this.client.logger.error(`sendResult() -> history.get(${s2}, ${t}) failed`), l4;
      }
      if (p4) {
        const l4 = Zu(a5, s2, h4);
        await global.Linking.openURL(l4, this.client.name);
      } else {
        const l4 = v2[d3.request.method].res;
        r3 ? (l4.internal = D2(I2({}, l4.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s2, h4, l4)) : this.client.core.relayer.publish(s2, h4, l4).catch((w5) => this.client.logger.error(w5));
      }
      await this.client.core.history.resolve(c5);
    }, this.sendError = async (e2) => {
      const { id: t, topic: s2, error: i3, encodeOpts: r3, rpcOpts: n4, appLink: a5 } = e2, c5 = formatJsonRpcError(t, i3);
      let h4;
      const p4 = a5 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const l4 = p4 ? Iu : tn;
        h4 = await this.client.core.crypto.encode(s2, c5, D2(I2({}, r3 || {}), { encoding: l4 }));
      } catch (l4) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s2} failed`), l4;
      }
      let d3;
      try {
        d3 = await this.client.core.history.get(s2, t);
      } catch (l4) {
        throw this.client.logger.error(`sendError() -> history.get(${s2}, ${t}) failed`), l4;
      }
      if (p4) {
        const l4 = Zu(a5, s2, h4);
        await global.Linking.openURL(l4, this.client.name);
      } else {
        const l4 = n4 || v2[d3.request.method].res;
        this.client.core.relayer.publish(s2, h4, l4);
      }
      await this.client.core.history.resolve(c5);
    }, this.cleanup = async () => {
      const e2 = [], t = [];
      this.client.session.getAll().forEach((s2) => {
        let i3 = false;
        xs(s2.expiry) && (i3 = true), this.client.core.crypto.keychain.has(s2.topic) || (i3 = true), i3 && e2.push(s2.topic);
      }), this.client.proposal.getAll().forEach((s2) => {
        xs(s2.expiryTimestamp) && t.push(s2.id);
      }), await Promise.all([...e2.map((s2) => this.deleteSession({ topic: s2 })), ...t.map((s2) => this.deleteProposal(s2))]);
    }, this.onRelayEventRequest = async (e2) => {
      this.requestQueue.queue.push(e2), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === x3.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = x3.active;
        const e2 = this.requestQueue.queue.shift();
        if (e2) try {
          await this.processRequest(e2);
        } catch (t) {
          this.client.logger.warn(t);
        }
      }
      this.requestQueue.state = x3.idle;
    }, this.processRequest = async (e2) => {
      const { topic: t, payload: s2, attestation: i3, transportType: r3, encryptedId: n4 } = e2, a5 = s2.method;
      if (!this.shouldIgnorePairingRequest({ topic: t, requestMethod: a5 })) switch (a5) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: t, payload: s2, attestation: i3, encryptedId: n4 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(t, s2);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(t, s2);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(t, s2);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(t, s2);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(t, s2);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: t, payload: s2, attestation: i3, encryptedId: n4, transportType: r3 });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(t, s2);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: t, payload: s2, attestation: i3, encryptedId: n4, transportType: r3 });
        default:
          return this.client.logger.info(`Unsupported request method ${a5}`);
      }
    }, this.onRelayEventResponse = async (e2) => {
      const { topic: t, payload: s2, transportType: i3 } = e2, r3 = (await this.client.core.history.get(t, s2.id)).request.method;
      switch (r3) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(t, s2, i3);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(t, s2);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(t, s2);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(t, s2);
        case "wc_sessionPing":
          return this.onSessionPingResponse(t, s2);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(t, s2);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(t, s2);
        default:
          return this.client.logger.info(`Unsupported response method ${r3}`);
      }
    }, this.onRelayEventUnknownPayload = (e2) => {
      const { topic: t } = e2, { message: s2 } = xe("MISSING_OR_INVALID", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s2);
    }, this.shouldIgnorePairingRequest = (e2) => {
      const { topic: t, requestMethod: s2 } = e2, i3 = this.expectedPairingMethodMap.get(t);
      return !i3 || i3.includes(s2) ? false : !!(i3.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }, this.onSessionProposeRequest = async (e2) => {
      const { topic: t, payload: s2, attestation: i3, encryptedId: r3 } = e2, { params: n4, id: a5 } = s2;
      try {
        const c5 = this.client.core.eventClient.getEvent({ topic: t });
        this.isValidConnect(I2({}, s2.params));
        const h4 = n4.expiryTimestamp || ws(v2.wc_sessionPropose.req.ttl), p4 = I2({ id: a5, pairingTopic: t, expiryTimestamp: h4 }, n4);
        await this.setProposal(a5, p4);
        const d3 = await this.getVerifyContext({ attestationId: i3, hash: Ou(JSON.stringify(s2)), encryptedId: r3, metadata: p4.proposer.metadata });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), c5 == null ? void 0 : c5.setError(M2.proposal_listener_not_found)), c5 == null ? void 0 : c5.addTrace(z2.emit_session_proposal), this.client.events.emit("session_proposal", { id: a5, params: p4, verifyContext: d3 });
      } catch (c5) {
        await this.sendError({ id: a5, topic: t, error: c5, rpcOpts: v2.wc_sessionPropose.autoReject }), this.client.logger.error(c5);
      }
    }, this.onSessionProposeResponse = async (e2, t, s2) => {
      const { id: i3 } = t;
      if (isJsonRpcResult(t)) {
        const { result: r3 } = t;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r3 });
        const n4 = this.client.proposal.get(i3);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n4 });
        const a5 = n4.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a5 });
        const c5 = r3.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: c5 });
        const h4 = await this.client.core.crypto.generateSharedKey(a5, c5);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: h4 });
        const p4 = await this.client.core.relayer.subscribe(h4, { transportType: s2 });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p4 }), await this.client.core.pairing.activate({ topic: e2 });
      } else if (isJsonRpcError(t)) {
        await this.client.proposal.delete(i3, er("USER_DISCONNECTED"));
        const r3 = Ms("session_connect");
        if (this.events.listenerCount(r3) === 0) throw new Error(`emitting ${r3} without any listeners, 954`);
        this.events.emit(Ms("session_connect"), { error: t.error });
      }
    }, this.onSessionSettleRequest = async (e2, t) => {
      const { id: s2, params: i3 } = t;
      try {
        this.isValidSessionSettleRequest(i3);
        const { relay: r3, controller: n4, expiry: a5, namespaces: c5, sessionProperties: h4, sessionConfig: p4 } = t.params, d3 = D2(I2(I2({ topic: e2, relay: r3, expiry: a5, namespaces: c5, acknowledged: true, pairingTopic: "", requiredNamespaces: {}, optionalNamespaces: {}, controller: n4.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: n4.publicKey, metadata: n4.metadata } }, h4 && { sessionProperties: h4 }), p4 && { sessionConfig: p4 }), { transportType: F.relay }), l4 = Ms("session_connect");
        if (this.events.listenerCount(l4) === 0) throw new Error(`emitting ${l4} without any listeners 997`);
        this.events.emit(Ms("session_connect"), { session: d3 }), await this.sendResult({ id: t.id, topic: e2, result: true, throwOnFailedPublish: true });
      } catch (r3) {
        await this.sendError({ id: s2, topic: e2, error: r3 }), this.client.logger.error(r3);
      }
    }, this.onSessionSettleResponse = async (e2, t) => {
      const { id: s2 } = t;
      isJsonRpcResult(t) ? (await this.client.session.update(e2, { acknowledged: true }), this.events.emit(Ms("session_approve", s2), {})) : isJsonRpcError(t) && (await this.client.session.delete(e2, er("USER_DISCONNECTED")), this.events.emit(Ms("session_approve", s2), { error: t.error }));
    }, this.onSessionUpdateRequest = async (e2, t) => {
      const { params: s2, id: i3 } = t;
      try {
        const r3 = `${e2}_session_update`, n4 = Rh.get(r3);
        if (n4 && this.isRequestOutOfSync(n4, i3)) {
          this.client.logger.info(`Discarding out of sync request - ${i3}`), this.sendError({ id: i3, topic: e2, error: er("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(I2({ topic: e2 }, s2));
        try {
          Rh.set(r3, i3), await this.client.session.update(e2, { namespaces: s2.namespaces }), await this.sendResult({ id: i3, topic: e2, result: true, throwOnFailedPublish: true });
        } catch (a5) {
          throw Rh.delete(r3), a5;
        }
        this.client.events.emit("session_update", { id: i3, topic: e2, params: s2 });
      } catch (r3) {
        await this.sendError({ id: i3, topic: e2, error: r3 }), this.client.logger.error(r3);
      }
    }, this.isRequestOutOfSync = (e2, t) => parseInt(t.toString().slice(0, -3)) <= parseInt(e2.toString().slice(0, -3)), this.onSessionUpdateResponse = (e2, t) => {
      const { id: s2 } = t, i3 = Ms("session_update", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(Ms("session_update", s2), {}) : isJsonRpcError(t) && this.events.emit(Ms("session_update", s2), { error: t.error });
    }, this.onSessionExtendRequest = async (e2, t) => {
      const { id: s2 } = t;
      try {
        this.isValidExtend({ topic: e2 }), await this.setExpiry(e2, ws(z3)), await this.sendResult({ id: s2, topic: e2, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_extend", { id: s2, topic: e2 });
      } catch (i3) {
        await this.sendError({ id: s2, topic: e2, error: i3 }), this.client.logger.error(i3);
      }
    }, this.onSessionExtendResponse = (e2, t) => {
      const { id: s2 } = t, i3 = Ms("session_extend", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(Ms("session_extend", s2), {}) : isJsonRpcError(t) && this.events.emit(Ms("session_extend", s2), { error: t.error });
    }, this.onSessionPingRequest = async (e2, t) => {
      const { id: s2 } = t;
      try {
        this.isValidPing({ topic: e2 }), await this.sendResult({ id: s2, topic: e2, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s2, topic: e2 });
      } catch (i3) {
        await this.sendError({ id: s2, topic: e2, error: i3 }), this.client.logger.error(i3);
      }
    }, this.onSessionPingResponse = (e2, t) => {
      const { id: s2 } = t, i3 = Ms("session_ping", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      setTimeout(() => {
        isJsonRpcResult(t) ? this.events.emit(Ms("session_ping", s2), {}) : isJsonRpcError(t) && this.events.emit(Ms("session_ping", s2), { error: t.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (e2, t) => {
      const { id: s2 } = t;
      try {
        this.isValidDisconnect({ topic: e2, reason: t.params }), Promise.all([new Promise((i3) => {
          this.client.core.relayer.once(w3.publish, async () => {
            i3(await this.deleteSession({ topic: e2, id: s2 }));
          });
        }), this.sendResult({ id: s2, topic: e2, result: true, throwOnFailedPublish: true }), this.cleanupPendingSentRequestsForTopic({ topic: e2, error: er("USER_DISCONNECTED") })]).catch((i3) => this.client.logger.error(i3));
      } catch (i3) {
        this.client.logger.error(i3);
      }
    }, this.onSessionRequest = async (e2) => {
      var t, s2, i3;
      const { topic: r3, payload: n4, attestation: a5, encryptedId: c5, transportType: h4 } = e2, { id: p4, params: d3 } = n4;
      try {
        await this.isValidRequest(I2({ topic: r3 }, d3));
        const l4 = this.client.session.get(r3), w5 = await this.getVerifyContext({ attestationId: a5, hash: Ou(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", d3, p4))), encryptedId: c5, metadata: l4.peer.metadata, transportType: h4 }), m2 = { id: p4, topic: r3, params: d3, verifyContext: w5 };
        await this.setPendingSessionRequest(m2), h4 === F.link_mode && (t = l4.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s2 = l4.peer.metadata.redirect) == null ? void 0 : s2.universal), (i3 = this.client.signConfig) != null && i3.disableRequestQueue ? this.emitSessionRequest(m2) : (this.addSessionRequestToSessionRequestQueue(m2), this.processSessionRequestQueue());
      } catch (l4) {
        await this.sendError({ id: p4, topic: r3, error: l4 }), this.client.logger.error(l4);
      }
    }, this.onSessionRequestResponse = (e2, t) => {
      const { id: s2 } = t, i3 = Ms("session_request", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(Ms("session_request", s2), { result: t.result }) : isJsonRpcError(t) && this.events.emit(Ms("session_request", s2), { error: t.error });
    }, this.onSessionEventRequest = async (e2, t) => {
      const { id: s2, params: i3 } = t;
      try {
        const r3 = `${e2}_session_event_${i3.event.name}`, n4 = Rh.get(r3);
        if (n4 && this.isRequestOutOfSync(n4, s2)) {
          this.client.logger.info(`Discarding out of sync request - ${s2}`);
          return;
        }
        this.isValidEmit(I2({ topic: e2 }, i3)), this.client.events.emit("session_event", { id: s2, topic: e2, params: i3 }), Rh.set(r3, s2);
      } catch (r3) {
        await this.sendError({ id: s2, topic: e2, error: r3 }), this.client.logger.error(r3);
      }
    }, this.onSessionAuthenticateResponse = (e2, t) => {
      const { id: s2 } = t;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: e2, payload: t }), isJsonRpcResult(t) ? this.events.emit(Ms("session_request", s2), { result: t.result }) : isJsonRpcError(t) && this.events.emit(Ms("session_request", s2), { error: t.error });
    }, this.onSessionAuthenticateRequest = async (e2) => {
      var t;
      const { topic: s2, payload: i3, attestation: r3, encryptedId: n4, transportType: a5 } = e2;
      try {
        const { requester: c5, authPayload: h4, expiryTimestamp: p4 } = i3.params, d3 = await this.getVerifyContext({ attestationId: r3, hash: Ou(JSON.stringify(i3)), encryptedId: n4, metadata: c5.metadata, transportType: a5 }), l4 = { requester: c5, pairingTopic: s2, id: i3.id, authPayload: h4, verifyContext: d3, expiryTimestamp: p4 };
        await this.setAuthRequest(i3.id, { request: l4, pairingTopic: s2, transportType: a5 }), a5 === F.link_mode && (t = c5.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(c5.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s2, params: i3.params, id: i3.id, verifyContext: d3 });
      } catch (c5) {
        this.client.logger.error(c5);
        const h4 = i3.params.requester.publicKey, p4 = await this.client.core.crypto.generateKeyPair(), d3 = this.getAppLinkIfEnabled(i3.params.requester.metadata, a5), l4 = { type: pr, receiverPublicKey: h4, senderPublicKey: p4 };
        await this.sendError({ id: i3.id, topic: s2, error: c5, encodeOpts: l4, rpcOpts: v2.wc_sessionAuthenticate.autoReject, appLink: d3 });
      }
    }, this.addSessionRequestToSessionRequestQueue = (e2) => {
      this.sessionRequestQueue.queue.push(e2);
    }, this.cleanupAfterResponse = (e2) => {
      this.deletePendingSessionRequest(e2.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = x3.idle, this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: e2, error: t }) => {
      const s2 = this.client.core.history.pending;
      s2.length > 0 && s2.filter((i3) => i3.topic === e2 && i3.request.method === "wc_sessionRequest").forEach((i3) => {
        const r3 = i3.request.id, n4 = Ms("session_request", r3);
        if (this.events.listenerCount(n4) === 0) throw new Error(`emitting ${n4} without any listeners`);
        this.events.emit(Ms("session_request", i3.request.id), { error: t });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === x3.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e2 = this.sessionRequestQueue.queue[0];
      if (!e2) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = x3.active, this.emitSessionRequest(e2);
      } catch (t) {
        this.client.logger.error(t);
      }
    }, this.emitSessionRequest = (e2) => {
      this.client.events.emit("session_request", e2);
    }, this.onPairingCreated = (e2) => {
      if (e2.methods && this.expectedPairingMethodMap.set(e2.topic, e2.methods), e2.active) return;
      const t = this.client.proposal.getAll().find((s2) => s2.pairingTopic === e2.topic);
      t && this.onSessionProposeRequest({ topic: e2.topic, payload: formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: t.requiredNamespaces, optionalNamespaces: t.optionalNamespaces, relays: t.relays, proposer: t.proposer, sessionProperties: t.sessionProperties }, t.id) });
    }, this.isValidConnect = async (e2) => {
      if (!Ah(e2)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e2)}`);
        throw new Error(a5);
      }
      const { pairingTopic: t, requiredNamespaces: s2, optionalNamespaces: i3, sessionProperties: r3, relays: n4 } = e2;
      if (Pe(t) || await this.isValidPairingTopic(t), !gh(n4, true)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `connect() relays: ${n4}`);
        throw new Error(a5);
      }
      !Pe(s2) && Xr(s2) !== 0 && this.validateNamespaces(s2, "requiredNamespaces"), !Pe(i3) && Xr(i3) !== 0 && this.validateNamespaces(i3, "optionalNamespaces"), Pe(r3) || this.validateSessionProps(r3, "sessionProperties");
    }, this.validateNamespaces = (e2, t) => {
      const s2 = vh(e2, "connect()", t);
      if (s2) throw new Error(s2.message);
    }, this.isValidApprove = async (e2) => {
      if (!Ah(e2)) throw new Error(xe("MISSING_OR_INVALID", `approve() params: ${e2}`).message);
      const { id: t, namespaces: s2, relayProtocol: i3, sessionProperties: r3 } = e2;
      this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
      const n4 = this.client.proposal.get(t), a5 = Oo(s2, "approve()");
      if (a5) throw new Error(a5.message);
      const c5 = To(n4.requiredNamespaces, s2, "approve()");
      if (c5) throw new Error(c5.message);
      if (!Yt(i3, true)) {
        const { message: h4 } = xe("MISSING_OR_INVALID", `approve() relayProtocol: ${i3}`);
        throw new Error(h4);
      }
      Pe(r3) || this.validateSessionProps(r3, "sessionProperties");
    }, this.isValidReject = async (e2) => {
      if (!Ah(e2)) {
        const { message: i3 } = xe("MISSING_OR_INVALID", `reject() params: ${e2}`);
        throw new Error(i3);
      }
      const { id: t, reason: s2 } = e2;
      if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !bh(s2)) {
        const { message: i3 } = xe("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s2)}`);
        throw new Error(i3);
      }
    }, this.isValidSessionSettleRequest = (e2) => {
      if (!Ah(e2)) {
        const { message: c5 } = xe("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e2}`);
        throw new Error(c5);
      }
      const { relay: t, controller: s2, namespaces: i3, expiry: r3 } = e2;
      if (!Po(t)) {
        const { message: c5 } = xe("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(c5);
      }
      const n4 = ph(s2, "onSessionSettleRequest()");
      if (n4) throw new Error(n4.message);
      const a5 = Oo(i3, "onSessionSettleRequest()");
      if (a5) throw new Error(a5.message);
      if (xs(r3)) {
        const { message: c5 } = xe("EXPIRED", "onSessionSettleRequest()");
        throw new Error(c5);
      }
    }, this.isValidUpdate = async (e2) => {
      if (!Ah(e2)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `update() params: ${e2}`);
        throw new Error(a5);
      }
      const { topic: t, namespaces: s2 } = e2;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const i3 = this.client.session.get(t), r3 = Oo(s2, "update()");
      if (r3) throw new Error(r3.message);
      const n4 = To(i3.requiredNamespaces, s2, "update()");
      if (n4) throw new Error(n4.message);
    }, this.isValidExtend = async (e2) => {
      if (!Ah(e2)) {
        const { message: s2 } = xe("MISSING_OR_INVALID", `extend() params: ${e2}`);
        throw new Error(s2);
      }
      const { topic: t } = e2;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
    }, this.isValidRequest = async (e2) => {
      if (!Ah(e2)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `request() params: ${e2}`);
        throw new Error(a5);
      }
      const { topic: t, request: s2, chainId: i3, expiry: r3 } = e2;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const { namespaces: n4 } = this.client.session.get(t);
      if (!Mh(n4, i3)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `request() chainId: ${i3}`);
        throw new Error(a5);
      }
      if (!yh(s2)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `request() ${JSON.stringify(s2)}`);
        throw new Error(a5);
      }
      if (!Eh(n4, i3, s2.method)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `request() method: ${s2.method}`);
        throw new Error(a5);
      }
      if (r3 && !_h(r3, me2)) {
        const { message: a5 } = xe("MISSING_OR_INVALID", `request() expiry: ${r3}. Expiry must be a number (in seconds) between ${me2.min} and ${me2.max}`);
        throw new Error(a5);
      }
    }, this.isValidRespond = async (e2) => {
      var t;
      if (!Ah(e2)) {
        const { message: r3 } = xe("MISSING_OR_INVALID", `respond() params: ${e2}`);
        throw new Error(r3);
      }
      const { topic: s2, response: i3 } = e2;
      try {
        await this.isValidSessionTopic(s2);
      } catch (r3) {
        throw (t = e2 == null ? void 0 : e2.response) != null && t.id && this.cleanupAfterResponse(e2), r3;
      }
      if (!wh(i3)) {
        const { message: r3 } = xe("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i3)}`);
        throw new Error(r3);
      }
    }, this.isValidPing = async (e2) => {
      if (!Ah(e2)) {
        const { message: s2 } = xe("MISSING_OR_INVALID", `ping() params: ${e2}`);
        throw new Error(s2);
      }
      const { topic: t } = e2;
      await this.isValidSessionOrPairingTopic(t);
    }, this.isValidEmit = async (e2) => {
      if (!Ah(e2)) {
        const { message: n4 } = xe("MISSING_OR_INVALID", `emit() params: ${e2}`);
        throw new Error(n4);
      }
      const { topic: t, event: s2, chainId: i3 } = e2;
      await this.isValidSessionTopic(t);
      const { namespaces: r3 } = this.client.session.get(t);
      if (!Mh(r3, i3)) {
        const { message: n4 } = xe("MISSING_OR_INVALID", `emit() chainId: ${i3}`);
        throw new Error(n4);
      }
      if (!xh(s2)) {
        const { message: n4 } = xe("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(n4);
      }
      if (!Sh(r3, i3, s2.name)) {
        const { message: n4 } = xe("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(n4);
      }
    }, this.isValidDisconnect = async (e2) => {
      if (!Ah(e2)) {
        const { message: s2 } = xe("MISSING_OR_INVALID", `disconnect() params: ${e2}`);
        throw new Error(s2);
      }
      const { topic: t } = e2;
      await this.isValidSessionOrPairingTopic(t);
    }, this.isValidAuthenticate = (e2) => {
      const { chains: t, uri: s2, domain: i3, nonce: r3 } = e2;
      if (!Array.isArray(t) || t.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!Yt(s2, false)) throw new Error("uri is required parameter");
      if (!Yt(i3, false)) throw new Error("domain is required parameter");
      if (!Yt(r3, false)) throw new Error("nonce is required parameter");
      if ([...new Set(t.map((a5) => An(a5).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: n4 } = An(t[0]);
      if (n4 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }, this.getVerifyContext = async (e2) => {
      const { attestationId: t, hash: s2, encryptedId: i3, metadata: r3, transportType: n4 } = e2, a5 = { verified: { verifyUrl: r3.verifyUrl || Z, validation: "UNKNOWN", origin: r3.url || "" } };
      try {
        if (n4 === F.link_mode) {
          const h4 = this.getAppLinkIfEnabled(r3, n4);
          return a5.verified.validation = h4 && new URL(h4).origin === new URL(r3.url).origin ? "VALID" : "INVALID", a5;
        }
        const c5 = await this.client.core.verify.resolve({ attestationId: t, hash: s2, encryptedId: i3, verifyUrl: r3.verifyUrl });
        c5 && (a5.verified.origin = c5.origin, a5.verified.isScam = c5.isScam, a5.verified.validation = c5.origin === new URL(r3.url).origin ? "VALID" : "INVALID");
      } catch (c5) {
        this.client.logger.warn(c5);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a5)}`), a5;
    }, this.validateSessionProps = (e2, t) => {
      Object.values(e2).forEach((s2) => {
        if (!Yt(s2, false)) {
          const { message: i3 } = xe("MISSING_OR_INVALID", `${t} must be in Record<string, string> format. Received: ${JSON.stringify(s2)}`);
          throw new Error(i3);
        }
      });
    }, this.getPendingAuthRequest = (e2) => {
      const t = this.client.auth.requests.get(e2);
      return typeof t == "object" ? t : void 0;
    }, this.addToRecentlyDeleted = (e2, t) => {
      if (this.recentlyDeletedMap.set(e2, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s2 = 0;
        const i3 = this.recentlyDeletedLimit / 2;
        for (const r3 of this.recentlyDeletedMap.keys()) {
          if (s2++ >= i3) break;
          this.recentlyDeletedMap.delete(r3);
        }
      }
    }, this.checkRecentlyDeleted = (e2) => {
      const t = this.recentlyDeletedMap.get(e2);
      if (t) {
        const { message: s2 } = xe("MISSING_OR_INVALID", `Record was recently deleted - ${t}: ${e2}`);
        throw new Error(s2);
      }
    }, this.isLinkModeEnabled = (e2, t) => {
      var s2, i3, r3, n4, a5, c5, h4, p4, d3;
      return !e2 || t !== F.link_mode ? false : ((i3 = (s2 = this.client.metadata) == null ? void 0 : s2.redirect) == null ? void 0 : i3.linkMode) === true && ((n4 = (r3 = this.client.metadata) == null ? void 0 : r3.redirect) == null ? void 0 : n4.universal) !== void 0 && ((c5 = (a5 = this.client.metadata) == null ? void 0 : a5.redirect) == null ? void 0 : c5.universal) !== "" && ((h4 = e2 == null ? void 0 : e2.redirect) == null ? void 0 : h4.universal) !== void 0 && ((p4 = e2 == null ? void 0 : e2.redirect) == null ? void 0 : p4.universal) !== "" && ((d3 = e2 == null ? void 0 : e2.redirect) == null ? void 0 : d3.linkMode) === true && this.client.core.linkModeSupportedApps.includes(e2.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }, this.getAppLinkIfEnabled = (e2, t) => {
      var s2;
      return this.isLinkModeEnabled(e2, t) ? (s2 = e2 == null ? void 0 : e2.redirect) == null ? void 0 : s2.universal : void 0;
    }, this.handleLinkModeMessage = ({ url: e2 }) => {
      if (!e2 || !e2.includes("wc_ev") || !e2.includes("topic")) return;
      const t = Is(e2, "topic") || "", s2 = decodeURIComponent(Is(e2, "wc_ev") || ""), i3 = this.client.session.keys.includes(t);
      i3 && this.client.session.update(t, { transportType: F.link_mode }), this.client.core.dispatchEnvelope({ topic: t, message: s2, sessionExists: i3 });
    }, this.registerLinkModeListeners = async () => {
      var e2;
      if (_s() || rr() && (e2 = this.client.metadata.redirect) != null && e2.linkMode) {
        const t = global == null ? void 0 : global.Linking;
        if (typeof t < "u") {
          t.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s2 = await t.getInitialURL();
          s2 && setTimeout(() => {
            this.handleLinkModeMessage({ url: s2 });
          }, 50);
        }
      }
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: o5 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(o5);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(w3.message, (o5) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(o5) : this.onRelayMessage(o5);
    });
  }
  async onRelayMessage(o5) {
    const { topic: e2, message: t, attestation: s2, transportType: i3 } = o5, { publicKey: r3 } = this.client.auth.authKeys.keys.includes(ae2) ? this.client.auth.authKeys.get(ae2) : { responseTopic: void 0, publicKey: void 0 }, n4 = await this.client.core.crypto.decode(e2, t, { receiverPublicKey: r3, encoding: i3 === F.link_mode ? Iu : tn });
    try {
      isJsonRpcRequest(n4) ? (this.client.core.history.set(e2, n4), this.onRelayEventRequest({ topic: e2, payload: n4, attestation: s2, transportType: i3, encryptedId: Ou(t) })) : isJsonRpcResponse(n4) ? (await this.client.core.history.resolve(n4), await this.onRelayEventResponse({ topic: e2, payload: n4, transportType: i3 }), this.client.core.history.delete(e2, n4.id)) : this.onRelayEventUnknownPayload({ topic: e2, payload: n4, transportType: i3 });
    } catch (a5) {
      this.client.logger.error(a5);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(R.expired, async (o5) => {
      const { topic: e2, id: t } = ys(o5.target);
      if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, xe("EXPIRED"), true);
      if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, xe("EXPIRED"), true);
      e2 ? this.client.session.keys.includes(e2) && (await this.deleteSession({ topic: e2, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: e2 })) : t && (await this.deleteProposal(t, true), this.client.events.emit("proposal_expire", { id: t }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(q.create, (o5) => this.onPairingCreated(o5)), this.client.core.pairing.events.on(q.delete, (o5) => {
      this.addToRecentlyDeleted(o5.topic, "pairing");
    });
  }
  isValidPairingTopic(o5) {
    if (!Yt(o5, false)) {
      const { message: e2 } = xe("MISSING_OR_INVALID", `pairing topic should be a string: ${o5}`);
      throw new Error(e2);
    }
    if (!this.client.core.pairing.pairings.keys.includes(o5)) {
      const { message: e2 } = xe("NO_MATCHING_KEY", `pairing topic doesn't exist: ${o5}`);
      throw new Error(e2);
    }
    if (xs(this.client.core.pairing.pairings.get(o5).expiry)) {
      const { message: e2 } = xe("EXPIRED", `pairing topic: ${o5}`);
      throw new Error(e2);
    }
  }
  async isValidSessionTopic(o5) {
    if (!Yt(o5, false)) {
      const { message: e2 } = xe("MISSING_OR_INVALID", `session topic should be a string: ${o5}`);
      throw new Error(e2);
    }
    if (this.checkRecentlyDeleted(o5), !this.client.session.keys.includes(o5)) {
      const { message: e2 } = xe("NO_MATCHING_KEY", `session topic doesn't exist: ${o5}`);
      throw new Error(e2);
    }
    if (xs(this.client.session.get(o5).expiry)) {
      await this.deleteSession({ topic: o5 });
      const { message: e2 } = xe("EXPIRED", `session topic: ${o5}`);
      throw new Error(e2);
    }
    if (!this.client.core.crypto.keychain.has(o5)) {
      const { message: e2 } = xe("MISSING_OR_INVALID", `session topic does not exist in keychain: ${o5}`);
      throw await this.deleteSession({ topic: o5 }), new Error(e2);
    }
  }
  async isValidSessionOrPairingTopic(o5) {
    if (this.checkRecentlyDeleted(o5), this.client.session.keys.includes(o5)) await this.isValidSessionTopic(o5);
    else if (this.client.core.pairing.pairings.keys.includes(o5)) this.isValidPairingTopic(o5);
    else if (Yt(o5, false)) {
      const { message: e2 } = xe("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${o5}`);
      throw new Error(e2);
    } else {
      const { message: e2 } = xe("MISSING_OR_INVALID", `session or pairing topic should be a string: ${o5}`);
      throw new Error(e2);
    }
  }
  async isValidProposalId(o5) {
    if (!mh(o5)) {
      const { message: e2 } = xe("MISSING_OR_INVALID", `proposal id should be a number: ${o5}`);
      throw new Error(e2);
    }
    if (!this.client.proposal.keys.includes(o5)) {
      const { message: e2 } = xe("NO_MATCHING_KEY", `proposal id doesn't exist: ${o5}`);
      throw new Error(e2);
    }
    if (xs(this.client.proposal.get(o5).expiryTimestamp)) {
      await this.deleteProposal(o5);
      const { message: e2 } = xe("EXPIRED", `proposal id: ${o5}`);
      throw new Error(e2);
    }
  }
};
var Ss3 = class extends ai {
  constructor(o5, e2) {
    super(o5, e2, st2, ye), this.core = o5, this.logger = e2;
  }
};
var yt2 = class extends ai {
  constructor(o5, e2) {
    super(o5, e2, rt2, ye), this.core = o5, this.logger = e2;
  }
};
var Is3 = class extends ai {
  constructor(o5, e2) {
    super(o5, e2, ot2, ye, (t) => t.id), this.core = o5, this.logger = e2;
  }
};
var fs2 = class extends ai {
  constructor(o5, e2) {
    super(o5, e2, pt2, oe2, () => ae2), this.core = o5, this.logger = e2;
  }
};
var vs = class extends ai {
  constructor(o5, e2) {
    super(o5, e2, ht2, oe2), this.core = o5, this.logger = e2;
  }
};
var qs2 = class extends ai {
  constructor(o5, e2) {
    super(o5, e2, dt2, oe2, (t) => t.id), this.core = o5, this.logger = e2;
  }
};
var Ts = class {
  constructor(o5, e2) {
    this.core = o5, this.logger = e2, this.authKeys = new fs2(this.core, this.logger), this.pairingTopics = new vs(this.core, this.logger), this.requests = new qs2(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var _e2 = class __e extends S {
  constructor(o5) {
    super(o5), this.protocol = be2, this.version = Ce2, this.name = we2.name, this.events = new import_events8.EventEmitter(), this.on = (t, s2) => this.events.on(t, s2), this.once = (t, s2) => this.events.once(t, s2), this.off = (t, s2) => this.events.off(t, s2), this.removeListener = (t, s2) => this.events.removeListener(t, s2), this.removeAllListeners = (t) => this.events.removeAllListeners(t), this.connect = async (t) => {
      try {
        return await this.engine.connect(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.pair = async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.approve = async (t) => {
      try {
        return await this.engine.approve(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.reject = async (t) => {
      try {
        return await this.engine.reject(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.update = async (t) => {
      try {
        return await this.engine.update(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.extend = async (t) => {
      try {
        return await this.engine.extend(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.request = async (t) => {
      try {
        return await this.engine.request(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.respond = async (t) => {
      try {
        return await this.engine.respond(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.ping = async (t) => {
      try {
        return await this.engine.ping(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.emit = async (t) => {
      try {
        return await this.engine.emit(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.disconnect = async (t) => {
      try {
        return await this.engine.disconnect(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.find = (t) => {
      try {
        return this.engine.find(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.authenticate = async (t, s2) => {
      try {
        return await this.engine.authenticate(t, s2);
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }, this.formatAuthMessage = (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.approveSessionAuthenticate = async (t) => {
      try {
        return await this.engine.approveSessionAuthenticate(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.rejectSessionAuthenticate = async (t) => {
      try {
        return await this.engine.rejectSessionAuthenticate(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.name = (o5 == null ? void 0 : o5.name) || we2.name, this.metadata = (o5 == null ? void 0 : o5.metadata) || fs(), this.signConfig = o5 == null ? void 0 : o5.signConfig;
    const e2 = typeof (o5 == null ? void 0 : o5.logger) < "u" && typeof (o5 == null ? void 0 : o5.logger) != "string" ? o5.logger : (0, import_pino.default)(k({ level: (o5 == null ? void 0 : o5.logger) || we2.logger }));
    this.core = (o5 == null ? void 0 : o5.core) || new On(o5), this.logger = E(e2, this.name), this.session = new yt2(this.core, this.logger), this.proposal = new Ss3(this.core, this.logger), this.pendingRequest = new Is3(this.core, this.logger), this.engine = new Rs2(this), this.auth = new Ts(this.core, this.logger);
  }
  static async init(o5) {
    const e2 = new __e(o5);
    return await e2.initialize(), e2;
  }
  get context() {
    return y(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), this.engine.processRelayMessageCache();
    } catch (o5) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(o5.message), o5;
    }
  }
};

// node_modules/@walletconnect/jsonrpc-http-connection/dist/index.es.js
var import_events9 = __toESM(require_events());
var import_cross_fetch = __toESM(require_browser_ponyfill());
var P2 = Object.defineProperty;
var w4 = Object.defineProperties;
var E3 = Object.getOwnPropertyDescriptors;
var c4 = Object.getOwnPropertySymbols;
var L = Object.prototype.hasOwnProperty;
var O3 = Object.prototype.propertyIsEnumerable;
var l3 = (r3, t, e2) => t in r3 ? P2(r3, t, { enumerable: true, configurable: true, writable: true, value: e2 }) : r3[t] = e2;
var p3 = (r3, t) => {
  for (var e2 in t || (t = {})) L.call(t, e2) && l3(r3, e2, t[e2]);
  if (c4) for (var e2 of c4(t)) O3.call(t, e2) && l3(r3, e2, t[e2]);
  return r3;
};
var v3 = (r3, t) => w4(r3, E3(t));
var j3 = { Accept: "application/json", "Content-Type": "application/json" };
var T2 = "POST";
var d2 = { headers: j3, method: T2 };
var g2 = 10;
var f3 = class {
  constructor(t, e2 = false) {
    if (this.url = t, this.disableProviderPing = e2, this.events = new import_events9.EventEmitter(), this.isAvailable = false, this.registering = false, !isHttpUrl(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);
    this.url = t, this.disableProviderPing = e2;
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(t, e2) {
    this.events.on(t, e2);
  }
  once(t, e2) {
    this.events.once(t, e2);
  }
  off(t, e2) {
    this.events.off(t, e2);
  }
  removeListener(t, e2) {
    this.events.removeListener(t, e2);
  }
  async open(t = this.url) {
    await this.register(t);
  }
  async close() {
    if (!this.isAvailable) throw new Error("Connection already closed");
    this.onClose();
  }
  async send(t) {
    this.isAvailable || await this.register();
    try {
      const e2 = safeJsonStringify(t), s2 = await (await (0, import_cross_fetch.default)(this.url, v3(p3({}, d2), { body: e2 }))).json();
      this.onPayload({ data: s2 });
    } catch (e2) {
      this.onError(t.id, e2);
    }
  }
  async register(t = this.url) {
    if (!isHttpUrl(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);
    if (this.registering) {
      const e2 = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= e2 || this.events.listenerCount("open") >= e2) && this.events.setMaxListeners(e2 + 1), new Promise((s2, i3) => {
        this.events.once("register_error", (n4) => {
          this.resetMaxListeners(), i3(n4);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.isAvailable > "u") return i3(new Error("HTTP connection is missing or invalid"));
          s2();
        });
      });
    }
    this.url = t, this.registering = true;
    try {
      if (!this.disableProviderPing) {
        const e2 = safeJsonStringify({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
        await (0, import_cross_fetch.default)(t, v3(p3({}, d2), { body: e2 }));
      }
      this.onOpen();
    } catch (e2) {
      const s2 = this.parseError(e2);
      throw this.events.emit("register_error", s2), this.onClose(), s2;
    }
  }
  onOpen() {
    this.isAvailable = true, this.registering = false, this.events.emit("open");
  }
  onClose() {
    this.isAvailable = false, this.registering = false, this.events.emit("close");
  }
  onPayload(t) {
    if (typeof t.data > "u") return;
    const e2 = typeof t.data == "string" ? safeJsonParse(t.data) : t.data;
    this.events.emit("payload", e2);
  }
  onError(t, e2) {
    const s2 = this.parseError(e2), i3 = s2.message || s2.toString(), n4 = formatJsonRpcError(t, i3);
    this.events.emit("payload", n4);
  }
  parseError(t, e2 = this.url) {
    return parseConnectionError(t, e2, "HTTP");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > g2 && this.events.setMaxListeners(g2);
  }
};

// node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events10 = __toESM(require_events());
var ya = "error";
var Yg = "wss://relay.walletconnect.org";
var Zg = "wc";
var Xg = "universal_provider";
var Sa = `${Zg}@2:${Xg}:`;
var Oa = "https://rpc.walletconnect.org/v1/";
var ze = "generic";
var Qg = `${Oa}bundler`;
var Tt2 = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
var _n2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var qi = { exports: {} };
(function(P3, s2) {
  (function() {
    var i3, p4 = "4.17.21", w5 = 200, I3 = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", y6 = "Expected a function", J = "Invalid `variable` option passed into `_.template`", Ht2 = "__lodash_hash_undefined__", Ke = 500, Ie2 = "__lodash_placeholder__", Dt2 = 1, Bt2 = 2, xe3 = 4, Ee2 = 1, mn2 = 2, vt2 = 1, he2 = 2, Gi = 4, Nt2 = 8, ye2 = 16, $t2 = 32, Se = 64, Gt2 = 128, Je = 256, gr3 = 512, Ma = 30, Ba = "...", Ga = 800, za = 16, zi = 1, Ka = 2, Ja = 3, le2 = 1 / 0, ee2 = 9007199254740991, Ya = 17976931348623157e292, wn2 = 0 / 0, Ut2 = 4294967295, Za = Ut2 - 1, Xa = Ut2 >>> 1, Qa = [["ary", Gt2], ["bind", vt2], ["bindKey", he2], ["curry", Nt2], ["curryRight", ye2], ["flip", gr3], ["partial", $t2], ["partialRight", Se], ["rearg", Je]], Oe = "[object Arguments]", Pn3 = "[object Array]", Va = "[object AsyncFunction]", Ye = "[object Boolean]", Ze4 = "[object Date]", ka = "[object DOMException]", Cn2 = "[object Error]", An2 = "[object Function]", Ki = "[object GeneratorFunction]", Et2 = "[object Map]", Xe2 = "[object Number]", ja = "[object Null]", zt2 = "[object Object]", Ji = "[object Promise]", to = "[object Proxy]", Qe2 = "[object RegExp]", yt3 = "[object Set]", Ve = "[object String]", In2 = "[object Symbol]", eo = "[object Undefined]", ke = "[object WeakMap]", no = "[object WeakSet]", je = "[object ArrayBuffer]", Re2 = "[object DataView]", vr2 = "[object Float32Array]", _r2 = "[object Float64Array]", mr2 = "[object Int8Array]", wr2 = "[object Int16Array]", Pr2 = "[object Int32Array]", Cr2 = "[object Uint8Array]", Ar2 = "[object Uint8ClampedArray]", Ir2 = "[object Uint16Array]", xr2 = "[object Uint32Array]", ro = /\b__p \+= '';/g, io = /\b(__p \+=) '' \+/g, so2 = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Yi = /&(?:amp|lt|gt|quot|#39);/g, Zi = /[&<>"']/g, uo = RegExp(Yi.source), ao = RegExp(Zi.source), oo = /<%-([\s\S]+?)%>/g, co = /<%([\s\S]+?)%>/g, Xi = /<%=([\s\S]+?)%>/g, fo = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, ho = /^\w*$/, lo = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Er2 = /[\\^$.*+?()[\]{}|]/g, po = RegExp(Er2.source), yr2 = /^\s+/, go = /\s/, vo = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, _o = /\{\n\/\* \[wrapped with (.+)\] \*/, mo = /,? & /, wo = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Po2 = /[()=,{}\[\]\/\s]/, Co = /\\(\\)?/g, Ao = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Qi = /\w*$/, Io = /^[-+]0x[0-9a-f]+$/i, xo2 = /^0b[01]+$/i, Eo = /^\[object .+?Constructor\]$/, yo = /^0o[0-7]+$/i, So = /^(?:0|[1-9]\d*)$/, Oo2 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, xn2 = /($^)/, Ro = /['\n\r\u2028\u2029\\]/g, En2 = "\\ud800-\\udfff", bo = "\\u0300-\\u036f", To2 = "\\ufe20-\\ufe2f", Lo = "\\u20d0-\\u20ff", Vi2 = bo + To2 + Lo, ki2 = "\\u2700-\\u27bf", ji = "a-z\\xdf-\\xf6\\xf8-\\xff", Ho = "\\xac\\xb1\\xd7\\xf7", Do = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", No = "\\u2000-\\u206f", $o = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ts2 = "A-Z\\xc0-\\xd6\\xd8-\\xde", es2 = "\\ufe0e\\ufe0f", ns2 = Ho + Do + No + $o, Sr3 = "['’]", Uo = "[" + En2 + "]", rs = "[" + ns2 + "]", yn2 = "[" + Vi2 + "]", is2 = "\\d+", qo = "[" + ki2 + "]", ss3 = "[" + ji + "]", us = "[^" + En2 + ns2 + is2 + ki2 + ji + ts2 + "]", Or2 = "\\ud83c[\\udffb-\\udfff]", Fo = "(?:" + yn2 + "|" + Or2 + ")", as = "[^" + En2 + "]", Rr2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", br2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", be3 = "[" + ts2 + "]", os = "\\u200d", cs2 = "(?:" + ss3 + "|" + us + ")", Wo = "(?:" + be3 + "|" + us + ")", fs3 = "(?:" + Sr3 + "(?:d|ll|m|re|s|t|ve))?", hs = "(?:" + Sr3 + "(?:D|LL|M|RE|S|T|VE))?", ls2 = Fo + "?", ps = "[" + es2 + "]?", Mo = "(?:" + os + "(?:" + [as, Rr2, br2].join("|") + ")" + ps + ls2 + ")*", Bo = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Go = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", ds = ps + ls2 + Mo, zo = "(?:" + [qo, Rr2, br2].join("|") + ")" + ds, Ko = "(?:" + [as + yn2 + "?", yn2, Rr2, br2, Uo].join("|") + ")", Jo = RegExp(Sr3, "g"), Yo = RegExp(yn2, "g"), Tr2 = RegExp(Or2 + "(?=" + Or2 + ")|" + Ko + ds, "g"), Zo = RegExp([be3 + "?" + ss3 + "+" + fs3 + "(?=" + [rs, be3, "$"].join("|") + ")", Wo + "+" + hs + "(?=" + [rs, be3 + cs2, "$"].join("|") + ")", be3 + "?" + cs2 + "+" + fs3, be3 + "+" + hs, Go, Bo, is2, zo].join("|"), "g"), Xo = RegExp("[" + os + En2 + Vi2 + es2 + "]"), Qo = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Vo = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], ko = -1, G2 = {};
    G2[vr2] = G2[_r2] = G2[mr2] = G2[wr2] = G2[Pr2] = G2[Cr2] = G2[Ar2] = G2[Ir2] = G2[xr2] = true, G2[Oe] = G2[Pn3] = G2[je] = G2[Ye] = G2[Re2] = G2[Ze4] = G2[Cn2] = G2[An2] = G2[Et2] = G2[Xe2] = G2[zt2] = G2[Qe2] = G2[yt3] = G2[Ve] = G2[ke] = false;
    var B2 = {};
    B2[Oe] = B2[Pn3] = B2[je] = B2[Re2] = B2[Ye] = B2[Ze4] = B2[vr2] = B2[_r2] = B2[mr2] = B2[wr2] = B2[Pr2] = B2[Et2] = B2[Xe2] = B2[zt2] = B2[Qe2] = B2[yt3] = B2[Ve] = B2[In2] = B2[Cr2] = B2[Ar2] = B2[Ir2] = B2[xr2] = true, B2[Cn2] = B2[An2] = B2[ke] = false;
    var jo = { À: "A", Á: "A", Â: "A", Ã: "A", Ä: "A", Å: "A", à: "a", á: "a", â: "a", ã: "a", ä: "a", å: "a", Ç: "C", ç: "c", Ð: "D", ð: "d", È: "E", É: "E", Ê: "E", Ë: "E", è: "e", é: "e", ê: "e", ë: "e", Ì: "I", Í: "I", Î: "I", Ï: "I", ì: "i", í: "i", î: "i", ï: "i", Ñ: "N", ñ: "n", Ò: "O", Ó: "O", Ô: "O", Õ: "O", Ö: "O", Ø: "O", ò: "o", ó: "o", ô: "o", õ: "o", ö: "o", ø: "o", Ù: "U", Ú: "U", Û: "U", Ü: "U", ù: "u", ú: "u", û: "u", ü: "u", Ý: "Y", ý: "y", ÿ: "y", Æ: "Ae", æ: "ae", Þ: "Th", þ: "th", ß: "ss", Ā: "A", Ă: "A", Ą: "A", ā: "a", ă: "a", ą: "a", Ć: "C", Ĉ: "C", Ċ: "C", Č: "C", ć: "c", ĉ: "c", ċ: "c", č: "c", Ď: "D", Đ: "D", ď: "d", đ: "d", Ē: "E", Ĕ: "E", Ė: "E", Ę: "E", Ě: "E", ē: "e", ĕ: "e", ė: "e", ę: "e", ě: "e", Ĝ: "G", Ğ: "G", Ġ: "G", Ģ: "G", ĝ: "g", ğ: "g", ġ: "g", ģ: "g", Ĥ: "H", Ħ: "H", ĥ: "h", ħ: "h", Ĩ: "I", Ī: "I", Ĭ: "I", Į: "I", İ: "I", ĩ: "i", ī: "i", ĭ: "i", į: "i", ı: "i", Ĵ: "J", ĵ: "j", Ķ: "K", ķ: "k", ĸ: "k", Ĺ: "L", Ļ: "L", Ľ: "L", Ŀ: "L", Ł: "L", ĺ: "l", ļ: "l", ľ: "l", ŀ: "l", ł: "l", Ń: "N", Ņ: "N", Ň: "N", Ŋ: "N", ń: "n", ņ: "n", ň: "n", ŋ: "n", Ō: "O", Ŏ: "O", Ő: "O", ō: "o", ŏ: "o", ő: "o", Ŕ: "R", Ŗ: "R", Ř: "R", ŕ: "r", ŗ: "r", ř: "r", Ś: "S", Ŝ: "S", Ş: "S", Š: "S", ś: "s", ŝ: "s", ş: "s", š: "s", Ţ: "T", Ť: "T", Ŧ: "T", ţ: "t", ť: "t", ŧ: "t", Ũ: "U", Ū: "U", Ŭ: "U", Ů: "U", Ű: "U", Ų: "U", ũ: "u", ū: "u", ŭ: "u", ů: "u", ű: "u", ų: "u", Ŵ: "W", ŵ: "w", Ŷ: "Y", ŷ: "y", Ÿ: "Y", Ź: "Z", Ż: "Z", Ž: "Z", ź: "z", ż: "z", ž: "z", Ĳ: "IJ", ĳ: "ij", Œ: "Oe", œ: "oe", ŉ: "'n", ſ: "s" }, tc = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, ec = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" }, nc = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, rc = parseFloat, ic = parseInt, gs2 = typeof _n2 == "object" && _n2 && _n2.Object === Object && _n2, sc = typeof self == "object" && self && self.Object === Object && self, j4 = gs2 || sc || Function("return this")(), Lr2 = s2 && !s2.nodeType && s2, pe = Lr2 && true && P3 && !P3.nodeType && P3, vs2 = pe && pe.exports === Lr2, Hr2 = vs2 && gs2.process, _t2 = function() {
      try {
        var h4 = pe && pe.require && pe.require("util").types;
        return h4 || Hr2 && Hr2.binding && Hr2.binding("util");
      } catch {
      }
    }(), _s3 = _t2 && _t2.isArrayBuffer, ms3 = _t2 && _t2.isDate, ws3 = _t2 && _t2.isMap, Ps2 = _t2 && _t2.isRegExp, Cs2 = _t2 && _t2.isSet, As3 = _t2 && _t2.isTypedArray;
    function ft2(h4, g3, d3) {
      switch (d3.length) {
        case 0:
          return h4.call(g3);
        case 1:
          return h4.call(g3, d3[0]);
        case 2:
          return h4.call(g3, d3[0], d3[1]);
        case 3:
          return h4.call(g3, d3[0], d3[1], d3[2]);
      }
      return h4.apply(g3, d3);
    }
    function uc(h4, g3, d3, A3) {
      for (var R2 = -1, U3 = h4 == null ? 0 : h4.length; ++R2 < U3; ) {
        var Q2 = h4[R2];
        g3(A3, Q2, d3(Q2), h4);
      }
      return A3;
    }
    function mt2(h4, g3) {
      for (var d3 = -1, A3 = h4 == null ? 0 : h4.length; ++d3 < A3 && g3(h4[d3], d3, h4) !== false; ) ;
      return h4;
    }
    function ac(h4, g3) {
      for (var d3 = h4 == null ? 0 : h4.length; d3-- && g3(h4[d3], d3, h4) !== false; ) ;
      return h4;
    }
    function Is4(h4, g3) {
      for (var d3 = -1, A3 = h4 == null ? 0 : h4.length; ++d3 < A3; ) if (!g3(h4[d3], d3, h4)) return false;
      return true;
    }
    function ne2(h4, g3) {
      for (var d3 = -1, A3 = h4 == null ? 0 : h4.length, R2 = 0, U3 = []; ++d3 < A3; ) {
        var Q2 = h4[d3];
        g3(Q2, d3, h4) && (U3[R2++] = Q2);
      }
      return U3;
    }
    function Sn2(h4, g3) {
      var d3 = h4 == null ? 0 : h4.length;
      return !!d3 && Te2(h4, g3, 0) > -1;
    }
    function Dr2(h4, g3, d3) {
      for (var A3 = -1, R2 = h4 == null ? 0 : h4.length; ++A3 < R2; ) if (d3(g3, h4[A3])) return true;
      return false;
    }
    function z4(h4, g3) {
      for (var d3 = -1, A3 = h4 == null ? 0 : h4.length, R2 = Array(A3); ++d3 < A3; ) R2[d3] = g3(h4[d3], d3, h4);
      return R2;
    }
    function re(h4, g3) {
      for (var d3 = -1, A3 = g3.length, R2 = h4.length; ++d3 < A3; ) h4[R2 + d3] = g3[d3];
      return h4;
    }
    function Nr3(h4, g3, d3, A3) {
      var R2 = -1, U3 = h4 == null ? 0 : h4.length;
      for (A3 && U3 && (d3 = h4[++R2]); ++R2 < U3; ) d3 = g3(d3, h4[R2], R2, h4);
      return d3;
    }
    function oc(h4, g3, d3, A3) {
      var R2 = h4 == null ? 0 : h4.length;
      for (A3 && R2 && (d3 = h4[--R2]); R2--; ) d3 = g3(d3, h4[R2], R2, h4);
      return d3;
    }
    function $r2(h4, g3) {
      for (var d3 = -1, A3 = h4 == null ? 0 : h4.length; ++d3 < A3; ) if (g3(h4[d3], d3, h4)) return true;
      return false;
    }
    var cc = Ur2("length");
    function fc(h4) {
      return h4.split("");
    }
    function hc(h4) {
      return h4.match(wo) || [];
    }
    function xs3(h4, g3, d3) {
      var A3;
      return d3(h4, function(R2, U3, Q2) {
        if (g3(R2, U3, Q2)) return A3 = U3, false;
      }), A3;
    }
    function On2(h4, g3, d3, A3) {
      for (var R2 = h4.length, U3 = d3 + (A3 ? 1 : -1); A3 ? U3-- : ++U3 < R2; ) if (g3(h4[U3], U3, h4)) return U3;
      return -1;
    }
    function Te2(h4, g3, d3) {
      return g3 === g3 ? Ic(h4, g3, d3) : On2(h4, Es3, d3);
    }
    function lc(h4, g3, d3, A3) {
      for (var R2 = d3 - 1, U3 = h4.length; ++R2 < U3; ) if (A3(h4[R2], g3)) return R2;
      return -1;
    }
    function Es3(h4) {
      return h4 !== h4;
    }
    function ys3(h4, g3) {
      var d3 = h4 == null ? 0 : h4.length;
      return d3 ? Fr2(h4, g3) / d3 : wn2;
    }
    function Ur2(h4) {
      return function(g3) {
        return g3 == null ? i3 : g3[h4];
      };
    }
    function qr2(h4) {
      return function(g3) {
        return h4 == null ? i3 : h4[g3];
      };
    }
    function Ss4(h4, g3, d3, A3, R2) {
      return R2(h4, function(U3, Q2, M3) {
        d3 = A3 ? (A3 = false, U3) : g3(d3, U3, Q2, M3);
      }), d3;
    }
    function pc(h4, g3) {
      var d3 = h4.length;
      for (h4.sort(g3); d3--; ) h4[d3] = h4[d3].value;
      return h4;
    }
    function Fr2(h4, g3) {
      for (var d3, A3 = -1, R2 = h4.length; ++A3 < R2; ) {
        var U3 = g3(h4[A3]);
        U3 !== i3 && (d3 = d3 === i3 ? U3 : d3 + U3);
      }
      return d3;
    }
    function Wr3(h4, g3) {
      for (var d3 = -1, A3 = Array(h4); ++d3 < h4; ) A3[d3] = g3(d3);
      return A3;
    }
    function dc(h4, g3) {
      return z4(g3, function(d3) {
        return [d3, h4[d3]];
      });
    }
    function Os2(h4) {
      return h4 && h4.slice(0, Ls2(h4) + 1).replace(yr2, "");
    }
    function ht3(h4) {
      return function(g3) {
        return h4(g3);
      };
    }
    function Mr2(h4, g3) {
      return z4(g3, function(d3) {
        return h4[d3];
      });
    }
    function tn3(h4, g3) {
      return h4.has(g3);
    }
    function Rs3(h4, g3) {
      for (var d3 = -1, A3 = h4.length; ++d3 < A3 && Te2(g3, h4[d3], 0) > -1; ) ;
      return d3;
    }
    function bs3(h4, g3) {
      for (var d3 = h4.length; d3-- && Te2(g3, h4[d3], 0) > -1; ) ;
      return d3;
    }
    function gc(h4, g3) {
      for (var d3 = h4.length, A3 = 0; d3--; ) h4[d3] === g3 && ++A3;
      return A3;
    }
    var vc = qr2(jo), _c = qr2(tc);
    function mc(h4) {
      return "\\" + nc[h4];
    }
    function wc(h4, g3) {
      return h4 == null ? i3 : h4[g3];
    }
    function Le2(h4) {
      return Xo.test(h4);
    }
    function Pc(h4) {
      return Qo.test(h4);
    }
    function Cc(h4) {
      for (var g3, d3 = []; !(g3 = h4.next()).done; ) d3.push(g3.value);
      return d3;
    }
    function Br2(h4) {
      var g3 = -1, d3 = Array(h4.size);
      return h4.forEach(function(A3, R2) {
        d3[++g3] = [R2, A3];
      }), d3;
    }
    function Ts2(h4, g3) {
      return function(d3) {
        return h4(g3(d3));
      };
    }
    function ie(h4, g3) {
      for (var d3 = -1, A3 = h4.length, R2 = 0, U3 = []; ++d3 < A3; ) {
        var Q2 = h4[d3];
        (Q2 === g3 || Q2 === Ie2) && (h4[d3] = Ie2, U3[R2++] = d3);
      }
      return U3;
    }
    function Rn2(h4) {
      var g3 = -1, d3 = Array(h4.size);
      return h4.forEach(function(A3) {
        d3[++g3] = A3;
      }), d3;
    }
    function Ac(h4) {
      var g3 = -1, d3 = Array(h4.size);
      return h4.forEach(function(A3) {
        d3[++g3] = [A3, A3];
      }), d3;
    }
    function Ic(h4, g3, d3) {
      for (var A3 = d3 - 1, R2 = h4.length; ++A3 < R2; ) if (h4[A3] === g3) return A3;
      return -1;
    }
    function xc(h4, g3, d3) {
      for (var A3 = d3 + 1; A3--; ) if (h4[A3] === g3) return A3;
      return A3;
    }
    function He(h4) {
      return Le2(h4) ? yc(h4) : cc(h4);
    }
    function St2(h4) {
      return Le2(h4) ? Sc(h4) : fc(h4);
    }
    function Ls2(h4) {
      for (var g3 = h4.length; g3-- && go.test(h4.charAt(g3)); ) ;
      return g3;
    }
    var Ec = qr2(ec);
    function yc(h4) {
      for (var g3 = Tr2.lastIndex = 0; Tr2.test(h4); ) ++g3;
      return g3;
    }
    function Sc(h4) {
      return h4.match(Tr2) || [];
    }
    function Oc(h4) {
      return h4.match(Zo) || [];
    }
    var Rc = function h4(g3) {
      g3 = g3 == null ? j4 : De.defaults(j4.Object(), g3, De.pick(j4, Vo));
      var d3 = g3.Array, A3 = g3.Date, R2 = g3.Error, U3 = g3.Function, Q2 = g3.Math, M3 = g3.Object, Gr2 = g3.RegExp, bc = g3.String, wt2 = g3.TypeError, bn2 = d3.prototype, Tc = U3.prototype, Ne = M3.prototype, Tn2 = g3["__core-js_shared__"], Ln = Tc.toString, W = Ne.hasOwnProperty, Lc = 0, Hs2 = function() {
        var t = /[^.]+$/.exec(Tn2 && Tn2.keys && Tn2.keys.IE_PROTO || "");
        return t ? "Symbol(src)_1." + t : "";
      }(), Hn = Ne.toString, Hc = Ln.call(M3), Dc = j4._, Nc = Gr2("^" + Ln.call(W).replace(Er2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Dn2 = vs2 ? g3.Buffer : i3, se2 = g3.Symbol, Nn = g3.Uint8Array, Ds = Dn2 ? Dn2.allocUnsafe : i3, $n = Ts2(M3.getPrototypeOf, M3), Ns3 = M3.create, $s2 = Ne.propertyIsEnumerable, Un = bn2.splice, Us2 = se2 ? se2.isConcatSpreadable : i3, en2 = se2 ? se2.iterator : i3, de = se2 ? se2.toStringTag : i3, qn = function() {
        try {
          var t = we3(M3, "defineProperty");
          return t({}, "", {}), t;
        } catch {
        }
      }(), $c = g3.clearTimeout !== j4.clearTimeout && g3.clearTimeout, Uc = A3 && A3.now !== j4.Date.now && A3.now, qc = g3.setTimeout !== j4.setTimeout && g3.setTimeout, Fn = Q2.ceil, Wn = Q2.floor, zr2 = M3.getOwnPropertySymbols, Fc = Dn2 ? Dn2.isBuffer : i3, qs3 = g3.isFinite, Wc = bn2.join, Mc = Ts2(M3.keys, M3), V = Q2.max, et3 = Q2.min, Bc = A3.now, Gc = g3.parseInt, Fs2 = Q2.random, zc = bn2.reverse, Kr3 = we3(g3, "DataView"), nn2 = we3(g3, "Map"), Jr2 = we3(g3, "Promise"), $e = we3(g3, "Set"), rn2 = we3(g3, "WeakMap"), sn2 = we3(M3, "create"), Mn = rn2 && new rn2(), Ue = {}, Kc = Pe3(Kr3), Jc = Pe3(nn2), Yc = Pe3(Jr2), Zc = Pe3($e), Xc = Pe3(rn2), Bn = se2 ? se2.prototype : i3, un2 = Bn ? Bn.valueOf : i3, Ws2 = Bn ? Bn.toString : i3;
      function a5(t) {
        if (Y2(t) && !b3(t) && !(t instanceof N2)) {
          if (t instanceof Pt2) return t;
          if (W.call(t, "__wrapped__")) return Mu2(t);
        }
        return new Pt2(t);
      }
      var qe = /* @__PURE__ */ function() {
        function t() {
        }
        return function(e2) {
          if (!K3(e2)) return {};
          if (Ns3) return Ns3(e2);
          t.prototype = e2;
          var n4 = new t();
          return t.prototype = i3, n4;
        };
      }();
      function Gn() {
      }
      function Pt2(t, e2) {
        this.__wrapped__ = t, this.__actions__ = [], this.__chain__ = !!e2, this.__index__ = 0, this.__values__ = i3;
      }
      a5.templateSettings = { escape: oo, evaluate: co, interpolate: Xi, variable: "", imports: { _: a5 } }, a5.prototype = Gn.prototype, a5.prototype.constructor = a5, Pt2.prototype = qe(Gn.prototype), Pt2.prototype.constructor = Pt2;
      function N2(t) {
        this.__wrapped__ = t, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = Ut2, this.__views__ = [];
      }
      function Qc() {
        var t = new N2(this.__wrapped__);
        return t.__actions__ = ut3(this.__actions__), t.__dir__ = this.__dir__, t.__filtered__ = this.__filtered__, t.__iteratees__ = ut3(this.__iteratees__), t.__takeCount__ = this.__takeCount__, t.__views__ = ut3(this.__views__), t;
      }
      function Vc() {
        if (this.__filtered__) {
          var t = new N2(this);
          t.__dir__ = -1, t.__filtered__ = true;
        } else t = this.clone(), t.__dir__ *= -1;
        return t;
      }
      function kc() {
        var t = this.__wrapped__.value(), e2 = this.__dir__, n4 = b3(t), r3 = e2 < 0, u3 = n4 ? t.length : 0, o5 = hh2(0, u3, this.__views__), c5 = o5.start, f4 = o5.end, l4 = f4 - c5, v4 = r3 ? f4 : c5 - 1, _3 = this.__iteratees__, m2 = _3.length, C2 = 0, x4 = et3(l4, this.__takeCount__);
        if (!n4 || !r3 && u3 == l4 && x4 == l4) return fu(t, this.__actions__);
        var S3 = [];
        t: for (; l4-- && C2 < x4; ) {
          v4 += e2;
          for (var L2 = -1, O4 = t[v4]; ++L2 < m2; ) {
            var D3 = _3[L2], $2 = D3.iteratee, dt3 = D3.type, st3 = $2(O4);
            if (dt3 == Ka) O4 = st3;
            else if (!st3) {
              if (dt3 == zi) continue t;
              break t;
            }
          }
          S3[C2++] = O4;
        }
        return S3;
      }
      N2.prototype = qe(Gn.prototype), N2.prototype.constructor = N2;
      function ge(t) {
        var e2 = -1, n4 = t == null ? 0 : t.length;
        for (this.clear(); ++e2 < n4; ) {
          var r3 = t[e2];
          this.set(r3[0], r3[1]);
        }
      }
      function jc() {
        this.__data__ = sn2 ? sn2(null) : {}, this.size = 0;
      }
      function tf(t) {
        var e2 = this.has(t) && delete this.__data__[t];
        return this.size -= e2 ? 1 : 0, e2;
      }
      function ef(t) {
        var e2 = this.__data__;
        if (sn2) {
          var n4 = e2[t];
          return n4 === Ht2 ? i3 : n4;
        }
        return W.call(e2, t) ? e2[t] : i3;
      }
      function nf(t) {
        var e2 = this.__data__;
        return sn2 ? e2[t] !== i3 : W.call(e2, t);
      }
      function rf(t, e2) {
        var n4 = this.__data__;
        return this.size += this.has(t) ? 0 : 1, n4[t] = sn2 && e2 === i3 ? Ht2 : e2, this;
      }
      ge.prototype.clear = jc, ge.prototype.delete = tf, ge.prototype.get = ef, ge.prototype.has = nf, ge.prototype.set = rf;
      function Kt2(t) {
        var e2 = -1, n4 = t == null ? 0 : t.length;
        for (this.clear(); ++e2 < n4; ) {
          var r3 = t[e2];
          this.set(r3[0], r3[1]);
        }
      }
      function sf() {
        this.__data__ = [], this.size = 0;
      }
      function uf(t) {
        var e2 = this.__data__, n4 = zn(e2, t);
        if (n4 < 0) return false;
        var r3 = e2.length - 1;
        return n4 == r3 ? e2.pop() : Un.call(e2, n4, 1), --this.size, true;
      }
      function af(t) {
        var e2 = this.__data__, n4 = zn(e2, t);
        return n4 < 0 ? i3 : e2[n4][1];
      }
      function of(t) {
        return zn(this.__data__, t) > -1;
      }
      function cf(t, e2) {
        var n4 = this.__data__, r3 = zn(n4, t);
        return r3 < 0 ? (++this.size, n4.push([t, e2])) : n4[r3][1] = e2, this;
      }
      Kt2.prototype.clear = sf, Kt2.prototype.delete = uf, Kt2.prototype.get = af, Kt2.prototype.has = of, Kt2.prototype.set = cf;
      function Jt2(t) {
        var e2 = -1, n4 = t == null ? 0 : t.length;
        for (this.clear(); ++e2 < n4; ) {
          var r3 = t[e2];
          this.set(r3[0], r3[1]);
        }
      }
      function ff() {
        this.size = 0, this.__data__ = { hash: new ge(), map: new (nn2 || Kt2)(), string: new ge() };
      }
      function hf(t) {
        var e2 = nr2(this, t).delete(t);
        return this.size -= e2 ? 1 : 0, e2;
      }
      function lf(t) {
        return nr2(this, t).get(t);
      }
      function pf(t) {
        return nr2(this, t).has(t);
      }
      function df(t, e2) {
        var n4 = nr2(this, t), r3 = n4.size;
        return n4.set(t, e2), this.size += n4.size == r3 ? 0 : 1, this;
      }
      Jt2.prototype.clear = ff, Jt2.prototype.delete = hf, Jt2.prototype.get = lf, Jt2.prototype.has = pf, Jt2.prototype.set = df;
      function ve2(t) {
        var e2 = -1, n4 = t == null ? 0 : t.length;
        for (this.__data__ = new Jt2(); ++e2 < n4; ) this.add(t[e2]);
      }
      function gf(t) {
        return this.__data__.set(t, Ht2), this;
      }
      function vf(t) {
        return this.__data__.has(t);
      }
      ve2.prototype.add = ve2.prototype.push = gf, ve2.prototype.has = vf;
      function Ot2(t) {
        var e2 = this.__data__ = new Kt2(t);
        this.size = e2.size;
      }
      function _f() {
        this.__data__ = new Kt2(), this.size = 0;
      }
      function mf(t) {
        var e2 = this.__data__, n4 = e2.delete(t);
        return this.size = e2.size, n4;
      }
      function wf(t) {
        return this.__data__.get(t);
      }
      function Pf(t) {
        return this.__data__.has(t);
      }
      function Cf(t, e2) {
        var n4 = this.__data__;
        if (n4 instanceof Kt2) {
          var r3 = n4.__data__;
          if (!nn2 || r3.length < w5 - 1) return r3.push([t, e2]), this.size = ++n4.size, this;
          n4 = this.__data__ = new Jt2(r3);
        }
        return n4.set(t, e2), this.size = n4.size, this;
      }
      Ot2.prototype.clear = _f, Ot2.prototype.delete = mf, Ot2.prototype.get = wf, Ot2.prototype.has = Pf, Ot2.prototype.set = Cf;
      function Ms3(t, e2) {
        var n4 = b3(t), r3 = !n4 && Ce3(t), u3 = !n4 && !r3 && fe2(t), o5 = !n4 && !r3 && !u3 && Be(t), c5 = n4 || r3 || u3 || o5, f4 = c5 ? Wr3(t.length, bc) : [], l4 = f4.length;
        for (var v4 in t) (e2 || W.call(t, v4)) && !(c5 && (v4 == "length" || u3 && (v4 == "offset" || v4 == "parent") || o5 && (v4 == "buffer" || v4 == "byteLength" || v4 == "byteOffset") || Qt2(v4, l4))) && f4.push(v4);
        return f4;
      }
      function Bs2(t) {
        var e2 = t.length;
        return e2 ? t[ri2(0, e2 - 1)] : i3;
      }
      function Af(t, e2) {
        return rr3(ut3(t), _e3(e2, 0, t.length));
      }
      function If(t) {
        return rr3(ut3(t));
      }
      function Yr2(t, e2, n4) {
        (n4 !== i3 && !Rt2(t[e2], n4) || n4 === i3 && !(e2 in t)) && Yt3(t, e2, n4);
      }
      function an2(t, e2, n4) {
        var r3 = t[e2];
        (!(W.call(t, e2) && Rt2(r3, n4)) || n4 === i3 && !(e2 in t)) && Yt3(t, e2, n4);
      }
      function zn(t, e2) {
        for (var n4 = t.length; n4--; ) if (Rt2(t[n4][0], e2)) return n4;
        return -1;
      }
      function xf(t, e2, n4, r3) {
        return ue2(t, function(u3, o5, c5) {
          e2(r3, u3, n4(u3), c5);
        }), r3;
      }
      function Gs2(t, e2) {
        return t && Ft2(e2, k3(e2), t);
      }
      function Ef(t, e2) {
        return t && Ft2(e2, ot3(e2), t);
      }
      function Yt3(t, e2, n4) {
        e2 == "__proto__" && qn ? qn(t, e2, { configurable: true, enumerable: true, value: n4, writable: true }) : t[e2] = n4;
      }
      function Zr2(t, e2) {
        for (var n4 = -1, r3 = e2.length, u3 = d3(r3), o5 = t == null; ++n4 < r3; ) u3[n4] = o5 ? i3 : Oi(t, e2[n4]);
        return u3;
      }
      function _e3(t, e2, n4) {
        return t === t && (n4 !== i3 && (t = t <= n4 ? t : n4), e2 !== i3 && (t = t >= e2 ? t : e2)), t;
      }
      function Ct2(t, e2, n4, r3, u3, o5) {
        var c5, f4 = e2 & Dt2, l4 = e2 & Bt2, v4 = e2 & xe3;
        if (n4 && (c5 = u3 ? n4(t, r3, u3, o5) : n4(t)), c5 !== i3) return c5;
        if (!K3(t)) return t;
        var _3 = b3(t);
        if (_3) {
          if (c5 = ph2(t), !f4) return ut3(t, c5);
        } else {
          var m2 = nt3(t), C2 = m2 == An2 || m2 == Ki;
          if (fe2(t)) return pu(t, f4);
          if (m2 == zt2 || m2 == Oe || C2 && !u3) {
            if (c5 = l4 || C2 ? {} : Lu2(t), !f4) return l4 ? nh(t, Ef(c5, t)) : eh(t, Gs2(c5, t));
          } else {
            if (!B2[m2]) return u3 ? t : {};
            c5 = dh2(t, m2, f4);
          }
        }
        o5 || (o5 = new Ot2());
        var x4 = o5.get(t);
        if (x4) return x4;
        o5.set(t, c5), aa(t) ? t.forEach(function(O4) {
          c5.add(Ct2(O4, e2, n4, O4, t, o5));
        }) : sa(t) && t.forEach(function(O4, D3) {
          c5.set(D3, Ct2(O4, e2, n4, D3, t, o5));
        });
        var S3 = v4 ? l4 ? di2 : pi2 : l4 ? ot3 : k3, L2 = _3 ? i3 : S3(t);
        return mt2(L2 || t, function(O4, D3) {
          L2 && (D3 = O4, O4 = t[D3]), an2(c5, D3, Ct2(O4, e2, n4, D3, t, o5));
        }), c5;
      }
      function yf(t) {
        var e2 = k3(t);
        return function(n4) {
          return zs2(n4, t, e2);
        };
      }
      function zs2(t, e2, n4) {
        var r3 = n4.length;
        if (t == null) return !r3;
        for (t = M3(t); r3--; ) {
          var u3 = n4[r3], o5 = e2[u3], c5 = t[u3];
          if (c5 === i3 && !(u3 in t) || !o5(c5)) return false;
        }
        return true;
      }
      function Ks2(t, e2, n4) {
        if (typeof t != "function") throw new wt2(y6);
        return dn2(function() {
          t.apply(i3, n4);
        }, e2);
      }
      function on3(t, e2, n4, r3) {
        var u3 = -1, o5 = Sn2, c5 = true, f4 = t.length, l4 = [], v4 = e2.length;
        if (!f4) return l4;
        n4 && (e2 = z4(e2, ht3(n4))), r3 ? (o5 = Dr2, c5 = false) : e2.length >= w5 && (o5 = tn3, c5 = false, e2 = new ve2(e2));
        t: for (; ++u3 < f4; ) {
          var _3 = t[u3], m2 = n4 == null ? _3 : n4(_3);
          if (_3 = r3 || _3 !== 0 ? _3 : 0, c5 && m2 === m2) {
            for (var C2 = v4; C2--; ) if (e2[C2] === m2) continue t;
            l4.push(_3);
          } else o5(e2, m2, r3) || l4.push(_3);
        }
        return l4;
      }
      var ue2 = mu2(qt2), Js2 = mu2(Qr2, true);
      function Sf(t, e2) {
        var n4 = true;
        return ue2(t, function(r3, u3, o5) {
          return n4 = !!e2(r3, u3, o5), n4;
        }), n4;
      }
      function Kn(t, e2, n4) {
        for (var r3 = -1, u3 = t.length; ++r3 < u3; ) {
          var o5 = t[r3], c5 = e2(o5);
          if (c5 != null && (f4 === i3 ? c5 === c5 && !pt3(c5) : n4(c5, f4))) var f4 = c5, l4 = o5;
        }
        return l4;
      }
      function Of(t, e2, n4, r3) {
        var u3 = t.length;
        for (n4 = T3(n4), n4 < 0 && (n4 = -n4 > u3 ? 0 : u3 + n4), r3 = r3 === i3 || r3 > u3 ? u3 : T3(r3), r3 < 0 && (r3 += u3), r3 = n4 > r3 ? 0 : ca(r3); n4 < r3; ) t[n4++] = e2;
        return t;
      }
      function Ys2(t, e2) {
        var n4 = [];
        return ue2(t, function(r3, u3, o5) {
          e2(r3, u3, o5) && n4.push(r3);
        }), n4;
      }
      function tt3(t, e2, n4, r3, u3) {
        var o5 = -1, c5 = t.length;
        for (n4 || (n4 = vh2), u3 || (u3 = []); ++o5 < c5; ) {
          var f4 = t[o5];
          e2 > 0 && n4(f4) ? e2 > 1 ? tt3(f4, e2 - 1, n4, r3, u3) : re(u3, f4) : r3 || (u3[u3.length] = f4);
        }
        return u3;
      }
      var Xr3 = wu(), Zs2 = wu(true);
      function qt2(t, e2) {
        return t && Xr3(t, e2, k3);
      }
      function Qr2(t, e2) {
        return t && Zs2(t, e2, k3);
      }
      function Jn(t, e2) {
        return ne2(e2, function(n4) {
          return Vt2(t[n4]);
        });
      }
      function me3(t, e2) {
        e2 = oe3(e2, t);
        for (var n4 = 0, r3 = e2.length; t != null && n4 < r3; ) t = t[Wt2(e2[n4++])];
        return n4 && n4 == r3 ? t : i3;
      }
      function Xs2(t, e2, n4) {
        var r3 = e2(t);
        return b3(t) ? r3 : re(r3, n4(t));
      }
      function rt3(t) {
        return t == null ? t === i3 ? eo : ja : de && de in M3(t) ? fh(t) : Ih(t);
      }
      function Vr3(t, e2) {
        return t > e2;
      }
      function Rf(t, e2) {
        return t != null && W.call(t, e2);
      }
      function bf(t, e2) {
        return t != null && e2 in M3(t);
      }
      function Tf(t, e2, n4) {
        return t >= et3(e2, n4) && t < V(e2, n4);
      }
      function kr2(t, e2, n4) {
        for (var r3 = n4 ? Dr2 : Sn2, u3 = t[0].length, o5 = t.length, c5 = o5, f4 = d3(o5), l4 = 1 / 0, v4 = []; c5--; ) {
          var _3 = t[c5];
          c5 && e2 && (_3 = z4(_3, ht3(e2))), l4 = et3(_3.length, l4), f4[c5] = !n4 && (e2 || u3 >= 120 && _3.length >= 120) ? new ve2(c5 && _3) : i3;
        }
        _3 = t[0];
        var m2 = -1, C2 = f4[0];
        t: for (; ++m2 < u3 && v4.length < l4; ) {
          var x4 = _3[m2], S3 = e2 ? e2(x4) : x4;
          if (x4 = n4 || x4 !== 0 ? x4 : 0, !(C2 ? tn3(C2, S3) : r3(v4, S3, n4))) {
            for (c5 = o5; --c5; ) {
              var L2 = f4[c5];
              if (!(L2 ? tn3(L2, S3) : r3(t[c5], S3, n4))) continue t;
            }
            C2 && C2.push(S3), v4.push(x4);
          }
        }
        return v4;
      }
      function Lf(t, e2, n4, r3) {
        return qt2(t, function(u3, o5, c5) {
          e2(r3, n4(u3), o5, c5);
        }), r3;
      }
      function cn2(t, e2, n4) {
        e2 = oe3(e2, t), t = $u2(t, e2);
        var r3 = t == null ? t : t[Wt2(It2(e2))];
        return r3 == null ? i3 : ft2(r3, t, n4);
      }
      function Qs2(t) {
        return Y2(t) && rt3(t) == Oe;
      }
      function Hf(t) {
        return Y2(t) && rt3(t) == je;
      }
      function Df(t) {
        return Y2(t) && rt3(t) == Ze4;
      }
      function fn2(t, e2, n4, r3, u3) {
        return t === e2 ? true : t == null || e2 == null || !Y2(t) && !Y2(e2) ? t !== t && e2 !== e2 : Nf(t, e2, n4, r3, fn2, u3);
      }
      function Nf(t, e2, n4, r3, u3, o5) {
        var c5 = b3(t), f4 = b3(e2), l4 = c5 ? Pn3 : nt3(t), v4 = f4 ? Pn3 : nt3(e2);
        l4 = l4 == Oe ? zt2 : l4, v4 = v4 == Oe ? zt2 : v4;
        var _3 = l4 == zt2, m2 = v4 == zt2, C2 = l4 == v4;
        if (C2 && fe2(t)) {
          if (!fe2(e2)) return false;
          c5 = true, _3 = false;
        }
        if (C2 && !_3) return o5 || (o5 = new Ot2()), c5 || Be(t) ? Ru2(t, e2, n4, r3, u3, o5) : oh(t, e2, l4, n4, r3, u3, o5);
        if (!(n4 & Ee2)) {
          var x4 = _3 && W.call(t, "__wrapped__"), S3 = m2 && W.call(e2, "__wrapped__");
          if (x4 || S3) {
            var L2 = x4 ? t.value() : t, O4 = S3 ? e2.value() : e2;
            return o5 || (o5 = new Ot2()), u3(L2, O4, n4, r3, o5);
          }
        }
        return C2 ? (o5 || (o5 = new Ot2()), ch2(t, e2, n4, r3, u3, o5)) : false;
      }
      function $f(t) {
        return Y2(t) && nt3(t) == Et2;
      }
      function jr2(t, e2, n4, r3) {
        var u3 = n4.length, o5 = u3, c5 = !r3;
        if (t == null) return !o5;
        for (t = M3(t); u3--; ) {
          var f4 = n4[u3];
          if (c5 && f4[2] ? f4[1] !== t[f4[0]] : !(f4[0] in t)) return false;
        }
        for (; ++u3 < o5; ) {
          f4 = n4[u3];
          var l4 = f4[0], v4 = t[l4], _3 = f4[1];
          if (c5 && f4[2]) {
            if (v4 === i3 && !(l4 in t)) return false;
          } else {
            var m2 = new Ot2();
            if (r3) var C2 = r3(v4, _3, l4, t, e2, m2);
            if (!(C2 === i3 ? fn2(_3, v4, Ee2 | mn2, r3, m2) : C2)) return false;
          }
        }
        return true;
      }
      function Vs2(t) {
        if (!K3(t) || mh2(t)) return false;
        var e2 = Vt2(t) ? Nc : Eo;
        return e2.test(Pe3(t));
      }
      function Uf(t) {
        return Y2(t) && rt3(t) == Qe2;
      }
      function qf(t) {
        return Y2(t) && nt3(t) == yt3;
      }
      function Ff(t) {
        return Y2(t) && cr2(t.length) && !!G2[rt3(t)];
      }
      function ks2(t) {
        return typeof t == "function" ? t : t == null ? ct3 : typeof t == "object" ? b3(t) ? eu(t[0], t[1]) : tu(t) : Pa(t);
      }
      function ti2(t) {
        if (!pn2(t)) return Mc(t);
        var e2 = [];
        for (var n4 in M3(t)) W.call(t, n4) && n4 != "constructor" && e2.push(n4);
        return e2;
      }
      function Wf2(t) {
        if (!K3(t)) return Ah2(t);
        var e2 = pn2(t), n4 = [];
        for (var r3 in t) r3 == "constructor" && (e2 || !W.call(t, r3)) || n4.push(r3);
        return n4;
      }
      function ei2(t, e2) {
        return t < e2;
      }
      function js2(t, e2) {
        var n4 = -1, r3 = at3(t) ? d3(t.length) : [];
        return ue2(t, function(u3, o5, c5) {
          r3[++n4] = e2(u3, o5, c5);
        }), r3;
      }
      function tu(t) {
        var e2 = vi(t);
        return e2.length == 1 && e2[0][2] ? Du2(e2[0][0], e2[0][1]) : function(n4) {
          return n4 === t || jr2(n4, t, e2);
        };
      }
      function eu(t, e2) {
        return mi2(t) && Hu(e2) ? Du2(Wt2(t), e2) : function(n4) {
          var r3 = Oi(n4, t);
          return r3 === i3 && r3 === e2 ? Ri(n4, t) : fn2(e2, r3, Ee2 | mn2);
        };
      }
      function Yn(t, e2, n4, r3, u3) {
        t !== e2 && Xr3(e2, function(o5, c5) {
          if (u3 || (u3 = new Ot2()), K3(o5)) Mf(t, e2, c5, n4, Yn, r3, u3);
          else {
            var f4 = r3 ? r3(Pi2(t, c5), o5, c5 + "", t, e2, u3) : i3;
            f4 === i3 && (f4 = o5), Yr2(t, c5, f4);
          }
        }, ot3);
      }
      function Mf(t, e2, n4, r3, u3, o5, c5) {
        var f4 = Pi2(t, n4), l4 = Pi2(e2, n4), v4 = c5.get(l4);
        if (v4) {
          Yr2(t, n4, v4);
          return;
        }
        var _3 = o5 ? o5(f4, l4, n4 + "", t, e2, c5) : i3, m2 = _3 === i3;
        if (m2) {
          var C2 = b3(l4), x4 = !C2 && fe2(l4), S3 = !C2 && !x4 && Be(l4);
          _3 = l4, C2 || x4 || S3 ? b3(f4) ? _3 = f4 : Z2(f4) ? _3 = ut3(f4) : x4 ? (m2 = false, _3 = pu(l4, true)) : S3 ? (m2 = false, _3 = du(l4, true)) : _3 = [] : gn2(l4) || Ce3(l4) ? (_3 = f4, Ce3(f4) ? _3 = fa(f4) : (!K3(f4) || Vt2(f4)) && (_3 = Lu2(l4))) : m2 = false;
        }
        m2 && (c5.set(l4, _3), u3(_3, l4, r3, o5, c5), c5.delete(l4)), Yr2(t, n4, _3);
      }
      function nu(t, e2) {
        var n4 = t.length;
        if (n4) return e2 += e2 < 0 ? n4 : 0, Qt2(e2, n4) ? t[e2] : i3;
      }
      function ru(t, e2, n4) {
        e2.length ? e2 = z4(e2, function(o5) {
          return b3(o5) ? function(c5) {
            return me3(c5, o5.length === 1 ? o5[0] : o5);
          } : o5;
        }) : e2 = [ct3];
        var r3 = -1;
        e2 = z4(e2, ht3(E4()));
        var u3 = js2(t, function(o5, c5, f4) {
          var l4 = z4(e2, function(v4) {
            return v4(o5);
          });
          return { criteria: l4, index: ++r3, value: o5 };
        });
        return pc(u3, function(o5, c5) {
          return th(o5, c5, n4);
        });
      }
      function Bf(t, e2) {
        return iu(t, e2, function(n4, r3) {
          return Ri(t, r3);
        });
      }
      function iu(t, e2, n4) {
        for (var r3 = -1, u3 = e2.length, o5 = {}; ++r3 < u3; ) {
          var c5 = e2[r3], f4 = me3(t, c5);
          n4(f4, c5) && hn2(o5, oe3(c5, t), f4);
        }
        return o5;
      }
      function Gf(t) {
        return function(e2) {
          return me3(e2, t);
        };
      }
      function ni2(t, e2, n4, r3) {
        var u3 = r3 ? lc : Te2, o5 = -1, c5 = e2.length, f4 = t;
        for (t === e2 && (e2 = ut3(e2)), n4 && (f4 = z4(t, ht3(n4))); ++o5 < c5; ) for (var l4 = 0, v4 = e2[o5], _3 = n4 ? n4(v4) : v4; (l4 = u3(f4, _3, l4, r3)) > -1; ) f4 !== t && Un.call(f4, l4, 1), Un.call(t, l4, 1);
        return t;
      }
      function su(t, e2) {
        for (var n4 = t ? e2.length : 0, r3 = n4 - 1; n4--; ) {
          var u3 = e2[n4];
          if (n4 == r3 || u3 !== o5) {
            var o5 = u3;
            Qt2(u3) ? Un.call(t, u3, 1) : ui2(t, u3);
          }
        }
        return t;
      }
      function ri2(t, e2) {
        return t + Wn(Fs2() * (e2 - t + 1));
      }
      function zf(t, e2, n4, r3) {
        for (var u3 = -1, o5 = V(Fn((e2 - t) / (n4 || 1)), 0), c5 = d3(o5); o5--; ) c5[r3 ? o5 : ++u3] = t, t += n4;
        return c5;
      }
      function ii2(t, e2) {
        var n4 = "";
        if (!t || e2 < 1 || e2 > ee2) return n4;
        do
          e2 % 2 && (n4 += t), e2 = Wn(e2 / 2), e2 && (t += t);
        while (e2);
        return n4;
      }
      function H(t, e2) {
        return Ci(Nu(t, e2, ct3), t + "");
      }
      function Kf(t) {
        return Bs2(Ge(t));
      }
      function Jf(t, e2) {
        var n4 = Ge(t);
        return rr3(n4, _e3(e2, 0, n4.length));
      }
      function hn2(t, e2, n4, r3) {
        if (!K3(t)) return t;
        e2 = oe3(e2, t);
        for (var u3 = -1, o5 = e2.length, c5 = o5 - 1, f4 = t; f4 != null && ++u3 < o5; ) {
          var l4 = Wt2(e2[u3]), v4 = n4;
          if (l4 === "__proto__" || l4 === "constructor" || l4 === "prototype") return t;
          if (u3 != c5) {
            var _3 = f4[l4];
            v4 = r3 ? r3(_3, l4, f4) : i3, v4 === i3 && (v4 = K3(_3) ? _3 : Qt2(e2[u3 + 1]) ? [] : {});
          }
          an2(f4, l4, v4), f4 = f4[l4];
        }
        return t;
      }
      var uu = Mn ? function(t, e2) {
        return Mn.set(t, e2), t;
      } : ct3, Yf = qn ? function(t, e2) {
        return qn(t, "toString", { configurable: true, enumerable: false, value: Ti(e2), writable: true });
      } : ct3;
      function Zf(t) {
        return rr3(Ge(t));
      }
      function At2(t, e2, n4) {
        var r3 = -1, u3 = t.length;
        e2 < 0 && (e2 = -e2 > u3 ? 0 : u3 + e2), n4 = n4 > u3 ? u3 : n4, n4 < 0 && (n4 += u3), u3 = e2 > n4 ? 0 : n4 - e2 >>> 0, e2 >>>= 0;
        for (var o5 = d3(u3); ++r3 < u3; ) o5[r3] = t[r3 + e2];
        return o5;
      }
      function Xf(t, e2) {
        var n4;
        return ue2(t, function(r3, u3, o5) {
          return n4 = e2(r3, u3, o5), !n4;
        }), !!n4;
      }
      function Zn(t, e2, n4) {
        var r3 = 0, u3 = t == null ? r3 : t.length;
        if (typeof e2 == "number" && e2 === e2 && u3 <= Xa) {
          for (; r3 < u3; ) {
            var o5 = r3 + u3 >>> 1, c5 = t[o5];
            c5 !== null && !pt3(c5) && (n4 ? c5 <= e2 : c5 < e2) ? r3 = o5 + 1 : u3 = o5;
          }
          return u3;
        }
        return si2(t, e2, ct3, n4);
      }
      function si2(t, e2, n4, r3) {
        var u3 = 0, o5 = t == null ? 0 : t.length;
        if (o5 === 0) return 0;
        e2 = n4(e2);
        for (var c5 = e2 !== e2, f4 = e2 === null, l4 = pt3(e2), v4 = e2 === i3; u3 < o5; ) {
          var _3 = Wn((u3 + o5) / 2), m2 = n4(t[_3]), C2 = m2 !== i3, x4 = m2 === null, S3 = m2 === m2, L2 = pt3(m2);
          if (c5) var O4 = r3 || S3;
          else v4 ? O4 = S3 && (r3 || C2) : f4 ? O4 = S3 && C2 && (r3 || !x4) : l4 ? O4 = S3 && C2 && !x4 && (r3 || !L2) : x4 || L2 ? O4 = false : O4 = r3 ? m2 <= e2 : m2 < e2;
          O4 ? u3 = _3 + 1 : o5 = _3;
        }
        return et3(o5, Za);
      }
      function au(t, e2) {
        for (var n4 = -1, r3 = t.length, u3 = 0, o5 = []; ++n4 < r3; ) {
          var c5 = t[n4], f4 = e2 ? e2(c5) : c5;
          if (!n4 || !Rt2(f4, l4)) {
            var l4 = f4;
            o5[u3++] = c5 === 0 ? 0 : c5;
          }
        }
        return o5;
      }
      function ou(t) {
        return typeof t == "number" ? t : pt3(t) ? wn2 : +t;
      }
      function lt3(t) {
        if (typeof t == "string") return t;
        if (b3(t)) return z4(t, lt3) + "";
        if (pt3(t)) return Ws2 ? Ws2.call(t) : "";
        var e2 = t + "";
        return e2 == "0" && 1 / t == -le2 ? "-0" : e2;
      }
      function ae3(t, e2, n4) {
        var r3 = -1, u3 = Sn2, o5 = t.length, c5 = true, f4 = [], l4 = f4;
        if (n4) c5 = false, u3 = Dr2;
        else if (o5 >= w5) {
          var v4 = e2 ? null : uh2(t);
          if (v4) return Rn2(v4);
          c5 = false, u3 = tn3, l4 = new ve2();
        } else l4 = e2 ? [] : f4;
        t: for (; ++r3 < o5; ) {
          var _3 = t[r3], m2 = e2 ? e2(_3) : _3;
          if (_3 = n4 || _3 !== 0 ? _3 : 0, c5 && m2 === m2) {
            for (var C2 = l4.length; C2--; ) if (l4[C2] === m2) continue t;
            e2 && l4.push(m2), f4.push(_3);
          } else u3(l4, m2, n4) || (l4 !== f4 && l4.push(m2), f4.push(_3));
        }
        return f4;
      }
      function ui2(t, e2) {
        return e2 = oe3(e2, t), t = $u2(t, e2), t == null || delete t[Wt2(It2(e2))];
      }
      function cu(t, e2, n4, r3) {
        return hn2(t, e2, n4(me3(t, e2)), r3);
      }
      function Xn(t, e2, n4, r3) {
        for (var u3 = t.length, o5 = r3 ? u3 : -1; (r3 ? o5-- : ++o5 < u3) && e2(t[o5], o5, t); ) ;
        return n4 ? At2(t, r3 ? 0 : o5, r3 ? o5 + 1 : u3) : At2(t, r3 ? o5 + 1 : 0, r3 ? u3 : o5);
      }
      function fu(t, e2) {
        var n4 = t;
        return n4 instanceof N2 && (n4 = n4.value()), Nr3(e2, function(r3, u3) {
          return u3.func.apply(u3.thisArg, re([r3], u3.args));
        }, n4);
      }
      function ai2(t, e2, n4) {
        var r3 = t.length;
        if (r3 < 2) return r3 ? ae3(t[0]) : [];
        for (var u3 = -1, o5 = d3(r3); ++u3 < r3; ) for (var c5 = t[u3], f4 = -1; ++f4 < r3; ) f4 != u3 && (o5[u3] = on3(o5[u3] || c5, t[f4], e2, n4));
        return ae3(tt3(o5, 1), e2, n4);
      }
      function hu(t, e2, n4) {
        for (var r3 = -1, u3 = t.length, o5 = e2.length, c5 = {}; ++r3 < u3; ) {
          var f4 = r3 < o5 ? e2[r3] : i3;
          n4(c5, t[r3], f4);
        }
        return c5;
      }
      function oi2(t) {
        return Z2(t) ? t : [];
      }
      function ci2(t) {
        return typeof t == "function" ? t : ct3;
      }
      function oe3(t, e2) {
        return b3(t) ? t : mi2(t, e2) ? [t] : Wu(q2(t));
      }
      var Qf = H;
      function ce2(t, e2, n4) {
        var r3 = t.length;
        return n4 = n4 === i3 ? r3 : n4, !e2 && n4 >= r3 ? t : At2(t, e2, n4);
      }
      var lu = $c || function(t) {
        return j4.clearTimeout(t);
      };
      function pu(t, e2) {
        if (e2) return t.slice();
        var n4 = t.length, r3 = Ds ? Ds(n4) : new t.constructor(n4);
        return t.copy(r3), r3;
      }
      function fi2(t) {
        var e2 = new t.constructor(t.byteLength);
        return new Nn(e2).set(new Nn(t)), e2;
      }
      function Vf(t, e2) {
        var n4 = e2 ? fi2(t.buffer) : t.buffer;
        return new t.constructor(n4, t.byteOffset, t.byteLength);
      }
      function kf(t) {
        var e2 = new t.constructor(t.source, Qi.exec(t));
        return e2.lastIndex = t.lastIndex, e2;
      }
      function jf(t) {
        return un2 ? M3(un2.call(t)) : {};
      }
      function du(t, e2) {
        var n4 = e2 ? fi2(t.buffer) : t.buffer;
        return new t.constructor(n4, t.byteOffset, t.length);
      }
      function gu2(t, e2) {
        if (t !== e2) {
          var n4 = t !== i3, r3 = t === null, u3 = t === t, o5 = pt3(t), c5 = e2 !== i3, f4 = e2 === null, l4 = e2 === e2, v4 = pt3(e2);
          if (!f4 && !v4 && !o5 && t > e2 || o5 && c5 && l4 && !f4 && !v4 || r3 && c5 && l4 || !n4 && l4 || !u3) return 1;
          if (!r3 && !o5 && !v4 && t < e2 || v4 && n4 && u3 && !r3 && !o5 || f4 && n4 && u3 || !c5 && u3 || !l4) return -1;
        }
        return 0;
      }
      function th(t, e2, n4) {
        for (var r3 = -1, u3 = t.criteria, o5 = e2.criteria, c5 = u3.length, f4 = n4.length; ++r3 < c5; ) {
          var l4 = gu2(u3[r3], o5[r3]);
          if (l4) {
            if (r3 >= f4) return l4;
            var v4 = n4[r3];
            return l4 * (v4 == "desc" ? -1 : 1);
          }
        }
        return t.index - e2.index;
      }
      function vu(t, e2, n4, r3) {
        for (var u3 = -1, o5 = t.length, c5 = n4.length, f4 = -1, l4 = e2.length, v4 = V(o5 - c5, 0), _3 = d3(l4 + v4), m2 = !r3; ++f4 < l4; ) _3[f4] = e2[f4];
        for (; ++u3 < c5; ) (m2 || u3 < o5) && (_3[n4[u3]] = t[u3]);
        for (; v4--; ) _3[f4++] = t[u3++];
        return _3;
      }
      function _u2(t, e2, n4, r3) {
        for (var u3 = -1, o5 = t.length, c5 = -1, f4 = n4.length, l4 = -1, v4 = e2.length, _3 = V(o5 - f4, 0), m2 = d3(_3 + v4), C2 = !r3; ++u3 < _3; ) m2[u3] = t[u3];
        for (var x4 = u3; ++l4 < v4; ) m2[x4 + l4] = e2[l4];
        for (; ++c5 < f4; ) (C2 || u3 < o5) && (m2[x4 + n4[c5]] = t[u3++]);
        return m2;
      }
      function ut3(t, e2) {
        var n4 = -1, r3 = t.length;
        for (e2 || (e2 = d3(r3)); ++n4 < r3; ) e2[n4] = t[n4];
        return e2;
      }
      function Ft2(t, e2, n4, r3) {
        var u3 = !n4;
        n4 || (n4 = {});
        for (var o5 = -1, c5 = e2.length; ++o5 < c5; ) {
          var f4 = e2[o5], l4 = r3 ? r3(n4[f4], t[f4], f4, n4, t) : i3;
          l4 === i3 && (l4 = t[f4]), u3 ? Yt3(n4, f4, l4) : an2(n4, f4, l4);
        }
        return n4;
      }
      function eh(t, e2) {
        return Ft2(t, _i2(t), e2);
      }
      function nh(t, e2) {
        return Ft2(t, bu(t), e2);
      }
      function Qn(t, e2) {
        return function(n4, r3) {
          var u3 = b3(n4) ? uc : xf, o5 = e2 ? e2() : {};
          return u3(n4, t, E4(r3, 2), o5);
        };
      }
      function Fe(t) {
        return H(function(e2, n4) {
          var r3 = -1, u3 = n4.length, o5 = u3 > 1 ? n4[u3 - 1] : i3, c5 = u3 > 2 ? n4[2] : i3;
          for (o5 = t.length > 3 && typeof o5 == "function" ? (u3--, o5) : i3, c5 && it3(n4[0], n4[1], c5) && (o5 = u3 < 3 ? i3 : o5, u3 = 1), e2 = M3(e2); ++r3 < u3; ) {
            var f4 = n4[r3];
            f4 && t(e2, f4, r3, o5);
          }
          return e2;
        });
      }
      function mu2(t, e2) {
        return function(n4, r3) {
          if (n4 == null) return n4;
          if (!at3(n4)) return t(n4, r3);
          for (var u3 = n4.length, o5 = e2 ? u3 : -1, c5 = M3(n4); (e2 ? o5-- : ++o5 < u3) && r3(c5[o5], o5, c5) !== false; ) ;
          return n4;
        };
      }
      function wu(t) {
        return function(e2, n4, r3) {
          for (var u3 = -1, o5 = M3(e2), c5 = r3(e2), f4 = c5.length; f4--; ) {
            var l4 = c5[t ? f4 : ++u3];
            if (n4(o5[l4], l4, o5) === false) break;
          }
          return e2;
        };
      }
      function rh(t, e2, n4) {
        var r3 = e2 & vt2, u3 = ln2(t);
        function o5() {
          var c5 = this && this !== j4 && this instanceof o5 ? u3 : t;
          return c5.apply(r3 ? n4 : this, arguments);
        }
        return o5;
      }
      function Pu2(t) {
        return function(e2) {
          e2 = q2(e2);
          var n4 = Le2(e2) ? St2(e2) : i3, r3 = n4 ? n4[0] : e2.charAt(0), u3 = n4 ? ce2(n4, 1).join("") : e2.slice(1);
          return r3[t]() + u3;
        };
      }
      function We(t) {
        return function(e2) {
          return Nr3(ma(_a(e2).replace(Jo, "")), t, "");
        };
      }
      function ln2(t) {
        return function() {
          var e2 = arguments;
          switch (e2.length) {
            case 0:
              return new t();
            case 1:
              return new t(e2[0]);
            case 2:
              return new t(e2[0], e2[1]);
            case 3:
              return new t(e2[0], e2[1], e2[2]);
            case 4:
              return new t(e2[0], e2[1], e2[2], e2[3]);
            case 5:
              return new t(e2[0], e2[1], e2[2], e2[3], e2[4]);
            case 6:
              return new t(e2[0], e2[1], e2[2], e2[3], e2[4], e2[5]);
            case 7:
              return new t(e2[0], e2[1], e2[2], e2[3], e2[4], e2[5], e2[6]);
          }
          var n4 = qe(t.prototype), r3 = t.apply(n4, e2);
          return K3(r3) ? r3 : n4;
        };
      }
      function ih(t, e2, n4) {
        var r3 = ln2(t);
        function u3() {
          for (var o5 = arguments.length, c5 = d3(o5), f4 = o5, l4 = Me(u3); f4--; ) c5[f4] = arguments[f4];
          var v4 = o5 < 3 && c5[0] !== l4 && c5[o5 - 1] !== l4 ? [] : ie(c5, l4);
          if (o5 -= v4.length, o5 < n4) return Eu2(t, e2, Vn, u3.placeholder, i3, c5, v4, i3, i3, n4 - o5);
          var _3 = this && this !== j4 && this instanceof u3 ? r3 : t;
          return ft2(_3, this, c5);
        }
        return u3;
      }
      function Cu2(t) {
        return function(e2, n4, r3) {
          var u3 = M3(e2);
          if (!at3(e2)) {
            var o5 = E4(n4, 3);
            e2 = k3(e2), n4 = function(f4) {
              return o5(u3[f4], f4, u3);
            };
          }
          var c5 = t(e2, n4, r3);
          return c5 > -1 ? u3[o5 ? e2[c5] : c5] : i3;
        };
      }
      function Au(t) {
        return Xt2(function(e2) {
          var n4 = e2.length, r3 = n4, u3 = Pt2.prototype.thru;
          for (t && e2.reverse(); r3--; ) {
            var o5 = e2[r3];
            if (typeof o5 != "function") throw new wt2(y6);
            if (u3 && !c5 && er3(o5) == "wrapper") var c5 = new Pt2([], true);
          }
          for (r3 = c5 ? r3 : n4; ++r3 < n4; ) {
            o5 = e2[r3];
            var f4 = er3(o5), l4 = f4 == "wrapper" ? gi2(o5) : i3;
            l4 && wi(l4[0]) && l4[1] == (Gt2 | Nt2 | $t2 | Je) && !l4[4].length && l4[9] == 1 ? c5 = c5[er3(l4[0])].apply(c5, l4[3]) : c5 = o5.length == 1 && wi(o5) ? c5[f4]() : c5.thru(o5);
          }
          return function() {
            var v4 = arguments, _3 = v4[0];
            if (c5 && v4.length == 1 && b3(_3)) return c5.plant(_3).value();
            for (var m2 = 0, C2 = n4 ? e2[m2].apply(this, v4) : _3; ++m2 < n4; ) C2 = e2[m2].call(this, C2);
            return C2;
          };
        });
      }
      function Vn(t, e2, n4, r3, u3, o5, c5, f4, l4, v4) {
        var _3 = e2 & Gt2, m2 = e2 & vt2, C2 = e2 & he2, x4 = e2 & (Nt2 | ye2), S3 = e2 & gr3, L2 = C2 ? i3 : ln2(t);
        function O4() {
          for (var D3 = arguments.length, $2 = d3(D3), dt3 = D3; dt3--; ) $2[dt3] = arguments[dt3];
          if (x4) var st3 = Me(O4), gt3 = gc($2, st3);
          if (r3 && ($2 = vu($2, r3, u3, x4)), o5 && ($2 = _u2($2, o5, c5, x4)), D3 -= gt3, x4 && D3 < v4) {
            var X = ie($2, st3);
            return Eu2(t, e2, Vn, O4.placeholder, n4, $2, X, f4, l4, v4 - D3);
          }
          var bt2 = m2 ? n4 : this, jt2 = C2 ? bt2[t] : t;
          return D3 = $2.length, f4 ? $2 = xh2($2, f4) : S3 && D3 > 1 && $2.reverse(), _3 && l4 < D3 && ($2.length = l4), this && this !== j4 && this instanceof O4 && (jt2 = L2 || ln2(jt2)), jt2.apply(bt2, $2);
        }
        return O4;
      }
      function Iu2(t, e2) {
        return function(n4, r3) {
          return Lf(n4, t, e2(r3), {});
        };
      }
      function kn(t, e2) {
        return function(n4, r3) {
          var u3;
          if (n4 === i3 && r3 === i3) return e2;
          if (n4 !== i3 && (u3 = n4), r3 !== i3) {
            if (u3 === i3) return r3;
            typeof n4 == "string" || typeof r3 == "string" ? (n4 = lt3(n4), r3 = lt3(r3)) : (n4 = ou(n4), r3 = ou(r3)), u3 = t(n4, r3);
          }
          return u3;
        };
      }
      function hi2(t) {
        return Xt2(function(e2) {
          return e2 = z4(e2, ht3(E4())), H(function(n4) {
            var r3 = this;
            return t(e2, function(u3) {
              return ft2(u3, r3, n4);
            });
          });
        });
      }
      function jn(t, e2) {
        e2 = e2 === i3 ? " " : lt3(e2);
        var n4 = e2.length;
        if (n4 < 2) return n4 ? ii2(e2, t) : e2;
        var r3 = ii2(e2, Fn(t / He(e2)));
        return Le2(e2) ? ce2(St2(r3), 0, t).join("") : r3.slice(0, t);
      }
      function sh(t, e2, n4, r3) {
        var u3 = e2 & vt2, o5 = ln2(t);
        function c5() {
          for (var f4 = -1, l4 = arguments.length, v4 = -1, _3 = r3.length, m2 = d3(_3 + l4), C2 = this && this !== j4 && this instanceof c5 ? o5 : t; ++v4 < _3; ) m2[v4] = r3[v4];
          for (; l4--; ) m2[v4++] = arguments[++f4];
          return ft2(C2, u3 ? n4 : this, m2);
        }
        return c5;
      }
      function xu2(t) {
        return function(e2, n4, r3) {
          return r3 && typeof r3 != "number" && it3(e2, n4, r3) && (n4 = r3 = i3), e2 = kt2(e2), n4 === i3 ? (n4 = e2, e2 = 0) : n4 = kt2(n4), r3 = r3 === i3 ? e2 < n4 ? 1 : -1 : kt2(r3), zf(e2, n4, r3, t);
        };
      }
      function tr2(t) {
        return function(e2, n4) {
          return typeof e2 == "string" && typeof n4 == "string" || (e2 = xt2(e2), n4 = xt2(n4)), t(e2, n4);
        };
      }
      function Eu2(t, e2, n4, r3, u3, o5, c5, f4, l4, v4) {
        var _3 = e2 & Nt2, m2 = _3 ? c5 : i3, C2 = _3 ? i3 : c5, x4 = _3 ? o5 : i3, S3 = _3 ? i3 : o5;
        e2 |= _3 ? $t2 : Se, e2 &= ~(_3 ? Se : $t2), e2 & Gi || (e2 &= ~(vt2 | he2));
        var L2 = [t, e2, u3, x4, m2, S3, C2, f4, l4, v4], O4 = n4.apply(i3, L2);
        return wi(t) && Uu2(O4, L2), O4.placeholder = r3, qu2(O4, t, e2);
      }
      function li2(t) {
        var e2 = Q2[t];
        return function(n4, r3) {
          if (n4 = xt2(n4), r3 = r3 == null ? 0 : et3(T3(r3), 292), r3 && qs3(n4)) {
            var u3 = (q2(n4) + "e").split("e"), o5 = e2(u3[0] + "e" + (+u3[1] + r3));
            return u3 = (q2(o5) + "e").split("e"), +(u3[0] + "e" + (+u3[1] - r3));
          }
          return e2(n4);
        };
      }
      var uh2 = $e && 1 / Rn2(new $e([, -0]))[1] == le2 ? function(t) {
        return new $e(t);
      } : Di2;
      function yu(t) {
        return function(e2) {
          var n4 = nt3(e2);
          return n4 == Et2 ? Br2(e2) : n4 == yt3 ? Ac(e2) : dc(e2, t(e2));
        };
      }
      function Zt2(t, e2, n4, r3, u3, o5, c5, f4) {
        var l4 = e2 & he2;
        if (!l4 && typeof t != "function") throw new wt2(y6);
        var v4 = r3 ? r3.length : 0;
        if (v4 || (e2 &= ~($t2 | Se), r3 = u3 = i3), c5 = c5 === i3 ? c5 : V(T3(c5), 0), f4 = f4 === i3 ? f4 : T3(f4), v4 -= u3 ? u3.length : 0, e2 & Se) {
          var _3 = r3, m2 = u3;
          r3 = u3 = i3;
        }
        var C2 = l4 ? i3 : gi2(t), x4 = [t, e2, n4, r3, u3, _3, m2, o5, c5, f4];
        if (C2 && Ch2(x4, C2), t = x4[0], e2 = x4[1], n4 = x4[2], r3 = x4[3], u3 = x4[4], f4 = x4[9] = x4[9] === i3 ? l4 ? 0 : t.length : V(x4[9] - v4, 0), !f4 && e2 & (Nt2 | ye2) && (e2 &= ~(Nt2 | ye2)), !e2 || e2 == vt2) var S3 = rh(t, e2, n4);
        else e2 == Nt2 || e2 == ye2 ? S3 = ih(t, e2, f4) : (e2 == $t2 || e2 == (vt2 | $t2)) && !u3.length ? S3 = sh(t, e2, n4, r3) : S3 = Vn.apply(i3, x4);
        var L2 = C2 ? uu : Uu2;
        return qu2(L2(S3, x4), t, e2);
      }
      function Su2(t, e2, n4, r3) {
        return t === i3 || Rt2(t, Ne[n4]) && !W.call(r3, n4) ? e2 : t;
      }
      function Ou2(t, e2, n4, r3, u3, o5) {
        return K3(t) && K3(e2) && (o5.set(e2, t), Yn(t, e2, i3, Ou2, o5), o5.delete(e2)), t;
      }
      function ah(t) {
        return gn2(t) ? i3 : t;
      }
      function Ru2(t, e2, n4, r3, u3, o5) {
        var c5 = n4 & Ee2, f4 = t.length, l4 = e2.length;
        if (f4 != l4 && !(c5 && l4 > f4)) return false;
        var v4 = o5.get(t), _3 = o5.get(e2);
        if (v4 && _3) return v4 == e2 && _3 == t;
        var m2 = -1, C2 = true, x4 = n4 & mn2 ? new ve2() : i3;
        for (o5.set(t, e2), o5.set(e2, t); ++m2 < f4; ) {
          var S3 = t[m2], L2 = e2[m2];
          if (r3) var O4 = c5 ? r3(L2, S3, m2, e2, t, o5) : r3(S3, L2, m2, t, e2, o5);
          if (O4 !== i3) {
            if (O4) continue;
            C2 = false;
            break;
          }
          if (x4) {
            if (!$r2(e2, function(D3, $2) {
              if (!tn3(x4, $2) && (S3 === D3 || u3(S3, D3, n4, r3, o5))) return x4.push($2);
            })) {
              C2 = false;
              break;
            }
          } else if (!(S3 === L2 || u3(S3, L2, n4, r3, o5))) {
            C2 = false;
            break;
          }
        }
        return o5.delete(t), o5.delete(e2), C2;
      }
      function oh(t, e2, n4, r3, u3, o5, c5) {
        switch (n4) {
          case Re2:
            if (t.byteLength != e2.byteLength || t.byteOffset != e2.byteOffset) return false;
            t = t.buffer, e2 = e2.buffer;
          case je:
            return !(t.byteLength != e2.byteLength || !o5(new Nn(t), new Nn(e2)));
          case Ye:
          case Ze4:
          case Xe2:
            return Rt2(+t, +e2);
          case Cn2:
            return t.name == e2.name && t.message == e2.message;
          case Qe2:
          case Ve:
            return t == e2 + "";
          case Et2:
            var f4 = Br2;
          case yt3:
            var l4 = r3 & Ee2;
            if (f4 || (f4 = Rn2), t.size != e2.size && !l4) return false;
            var v4 = c5.get(t);
            if (v4) return v4 == e2;
            r3 |= mn2, c5.set(t, e2);
            var _3 = Ru2(f4(t), f4(e2), r3, u3, o5, c5);
            return c5.delete(t), _3;
          case In2:
            if (un2) return un2.call(t) == un2.call(e2);
        }
        return false;
      }
      function ch2(t, e2, n4, r3, u3, o5) {
        var c5 = n4 & Ee2, f4 = pi2(t), l4 = f4.length, v4 = pi2(e2), _3 = v4.length;
        if (l4 != _3 && !c5) return false;
        for (var m2 = l4; m2--; ) {
          var C2 = f4[m2];
          if (!(c5 ? C2 in e2 : W.call(e2, C2))) return false;
        }
        var x4 = o5.get(t), S3 = o5.get(e2);
        if (x4 && S3) return x4 == e2 && S3 == t;
        var L2 = true;
        o5.set(t, e2), o5.set(e2, t);
        for (var O4 = c5; ++m2 < l4; ) {
          C2 = f4[m2];
          var D3 = t[C2], $2 = e2[C2];
          if (r3) var dt3 = c5 ? r3($2, D3, C2, e2, t, o5) : r3(D3, $2, C2, t, e2, o5);
          if (!(dt3 === i3 ? D3 === $2 || u3(D3, $2, n4, r3, o5) : dt3)) {
            L2 = false;
            break;
          }
          O4 || (O4 = C2 == "constructor");
        }
        if (L2 && !O4) {
          var st3 = t.constructor, gt3 = e2.constructor;
          st3 != gt3 && "constructor" in t && "constructor" in e2 && !(typeof st3 == "function" && st3 instanceof st3 && typeof gt3 == "function" && gt3 instanceof gt3) && (L2 = false);
        }
        return o5.delete(t), o5.delete(e2), L2;
      }
      function Xt2(t) {
        return Ci(Nu(t, i3, zu2), t + "");
      }
      function pi2(t) {
        return Xs2(t, k3, _i2);
      }
      function di2(t) {
        return Xs2(t, ot3, bu);
      }
      var gi2 = Mn ? function(t) {
        return Mn.get(t);
      } : Di2;
      function er3(t) {
        for (var e2 = t.name + "", n4 = Ue[e2], r3 = W.call(Ue, e2) ? n4.length : 0; r3--; ) {
          var u3 = n4[r3], o5 = u3.func;
          if (o5 == null || o5 == t) return u3.name;
        }
        return e2;
      }
      function Me(t) {
        var e2 = W.call(a5, "placeholder") ? a5 : t;
        return e2.placeholder;
      }
      function E4() {
        var t = a5.iteratee || Li;
        return t = t === Li ? ks2 : t, arguments.length ? t(arguments[0], arguments[1]) : t;
      }
      function nr2(t, e2) {
        var n4 = t.__data__;
        return _h2(e2) ? n4[typeof e2 == "string" ? "string" : "hash"] : n4.map;
      }
      function vi(t) {
        for (var e2 = k3(t), n4 = e2.length; n4--; ) {
          var r3 = e2[n4], u3 = t[r3];
          e2[n4] = [r3, u3, Hu(u3)];
        }
        return e2;
      }
      function we3(t, e2) {
        var n4 = wc(t, e2);
        return Vs2(n4) ? n4 : i3;
      }
      function fh(t) {
        var e2 = W.call(t, de), n4 = t[de];
        try {
          t[de] = i3;
          var r3 = true;
        } catch {
        }
        var u3 = Hn.call(t);
        return r3 && (e2 ? t[de] = n4 : delete t[de]), u3;
      }
      var _i2 = zr2 ? function(t) {
        return t == null ? [] : (t = M3(t), ne2(zr2(t), function(e2) {
          return $s2.call(t, e2);
        }));
      } : Ni, bu = zr2 ? function(t) {
        for (var e2 = []; t; ) re(e2, _i2(t)), t = $n(t);
        return e2;
      } : Ni, nt3 = rt3;
      (Kr3 && nt3(new Kr3(new ArrayBuffer(1))) != Re2 || nn2 && nt3(new nn2()) != Et2 || Jr2 && nt3(Jr2.resolve()) != Ji || $e && nt3(new $e()) != yt3 || rn2 && nt3(new rn2()) != ke) && (nt3 = function(t) {
        var e2 = rt3(t), n4 = e2 == zt2 ? t.constructor : i3, r3 = n4 ? Pe3(n4) : "";
        if (r3) switch (r3) {
          case Kc:
            return Re2;
          case Jc:
            return Et2;
          case Yc:
            return Ji;
          case Zc:
            return yt3;
          case Xc:
            return ke;
        }
        return e2;
      });
      function hh2(t, e2, n4) {
        for (var r3 = -1, u3 = n4.length; ++r3 < u3; ) {
          var o5 = n4[r3], c5 = o5.size;
          switch (o5.type) {
            case "drop":
              t += c5;
              break;
            case "dropRight":
              e2 -= c5;
              break;
            case "take":
              e2 = et3(e2, t + c5);
              break;
            case "takeRight":
              t = V(t, e2 - c5);
              break;
          }
        }
        return { start: t, end: e2 };
      }
      function lh2(t) {
        var e2 = t.match(_o);
        return e2 ? e2[1].split(mo) : [];
      }
      function Tu2(t, e2, n4) {
        e2 = oe3(e2, t);
        for (var r3 = -1, u3 = e2.length, o5 = false; ++r3 < u3; ) {
          var c5 = Wt2(e2[r3]);
          if (!(o5 = t != null && n4(t, c5))) break;
          t = t[c5];
        }
        return o5 || ++r3 != u3 ? o5 : (u3 = t == null ? 0 : t.length, !!u3 && cr2(u3) && Qt2(c5, u3) && (b3(t) || Ce3(t)));
      }
      function ph2(t) {
        var e2 = t.length, n4 = new t.constructor(e2);
        return e2 && typeof t[0] == "string" && W.call(t, "index") && (n4.index = t.index, n4.input = t.input), n4;
      }
      function Lu2(t) {
        return typeof t.constructor == "function" && !pn2(t) ? qe($n(t)) : {};
      }
      function dh2(t, e2, n4) {
        var r3 = t.constructor;
        switch (e2) {
          case je:
            return fi2(t);
          case Ye:
          case Ze4:
            return new r3(+t);
          case Re2:
            return Vf(t, n4);
          case vr2:
          case _r2:
          case mr2:
          case wr2:
          case Pr2:
          case Cr2:
          case Ar2:
          case Ir2:
          case xr2:
            return du(t, n4);
          case Et2:
            return new r3();
          case Xe2:
          case Ve:
            return new r3(t);
          case Qe2:
            return kf(t);
          case yt3:
            return new r3();
          case In2:
            return jf(t);
        }
      }
      function gh2(t, e2) {
        var n4 = e2.length;
        if (!n4) return t;
        var r3 = n4 - 1;
        return e2[r3] = (n4 > 1 ? "& " : "") + e2[r3], e2 = e2.join(n4 > 2 ? ", " : " "), t.replace(vo, `{
/* [wrapped with ` + e2 + `] */
`);
      }
      function vh2(t) {
        return b3(t) || Ce3(t) || !!(Us2 && t && t[Us2]);
      }
      function Qt2(t, e2) {
        var n4 = typeof t;
        return e2 = e2 ?? ee2, !!e2 && (n4 == "number" || n4 != "symbol" && So.test(t)) && t > -1 && t % 1 == 0 && t < e2;
      }
      function it3(t, e2, n4) {
        if (!K3(n4)) return false;
        var r3 = typeof e2;
        return (r3 == "number" ? at3(n4) && Qt2(e2, n4.length) : r3 == "string" && e2 in n4) ? Rt2(n4[e2], t) : false;
      }
      function mi2(t, e2) {
        if (b3(t)) return false;
        var n4 = typeof t;
        return n4 == "number" || n4 == "symbol" || n4 == "boolean" || t == null || pt3(t) ? true : ho.test(t) || !fo.test(t) || e2 != null && t in M3(e2);
      }
      function _h2(t) {
        var e2 = typeof t;
        return e2 == "string" || e2 == "number" || e2 == "symbol" || e2 == "boolean" ? t !== "__proto__" : t === null;
      }
      function wi(t) {
        var e2 = er3(t), n4 = a5[e2];
        if (typeof n4 != "function" || !(e2 in N2.prototype)) return false;
        if (t === n4) return true;
        var r3 = gi2(n4);
        return !!r3 && t === r3[0];
      }
      function mh2(t) {
        return !!Hs2 && Hs2 in t;
      }
      var wh2 = Tn2 ? Vt2 : $i;
      function pn2(t) {
        var e2 = t && t.constructor, n4 = typeof e2 == "function" && e2.prototype || Ne;
        return t === n4;
      }
      function Hu(t) {
        return t === t && !K3(t);
      }
      function Du2(t, e2) {
        return function(n4) {
          return n4 == null ? false : n4[t] === e2 && (e2 !== i3 || t in M3(n4));
        };
      }
      function Ph(t) {
        var e2 = ar2(t, function(r3) {
          return n4.size === Ke && n4.clear(), r3;
        }), n4 = e2.cache;
        return e2;
      }
      function Ch2(t, e2) {
        var n4 = t[1], r3 = e2[1], u3 = n4 | r3, o5 = u3 < (vt2 | he2 | Gt2), c5 = r3 == Gt2 && n4 == Nt2 || r3 == Gt2 && n4 == Je && t[7].length <= e2[8] || r3 == (Gt2 | Je) && e2[7].length <= e2[8] && n4 == Nt2;
        if (!(o5 || c5)) return t;
        r3 & vt2 && (t[2] = e2[2], u3 |= n4 & vt2 ? 0 : Gi);
        var f4 = e2[3];
        if (f4) {
          var l4 = t[3];
          t[3] = l4 ? vu(l4, f4, e2[4]) : f4, t[4] = l4 ? ie(t[3], Ie2) : e2[4];
        }
        return f4 = e2[5], f4 && (l4 = t[5], t[5] = l4 ? _u2(l4, f4, e2[6]) : f4, t[6] = l4 ? ie(t[5], Ie2) : e2[6]), f4 = e2[7], f4 && (t[7] = f4), r3 & Gt2 && (t[8] = t[8] == null ? e2[8] : et3(t[8], e2[8])), t[9] == null && (t[9] = e2[9]), t[0] = e2[0], t[1] = u3, t;
      }
      function Ah2(t) {
        var e2 = [];
        if (t != null) for (var n4 in M3(t)) e2.push(n4);
        return e2;
      }
      function Ih(t) {
        return Hn.call(t);
      }
      function Nu(t, e2, n4) {
        return e2 = V(e2 === i3 ? t.length - 1 : e2, 0), function() {
          for (var r3 = arguments, u3 = -1, o5 = V(r3.length - e2, 0), c5 = d3(o5); ++u3 < o5; ) c5[u3] = r3[e2 + u3];
          u3 = -1;
          for (var f4 = d3(e2 + 1); ++u3 < e2; ) f4[u3] = r3[u3];
          return f4[e2] = n4(c5), ft2(t, this, f4);
        };
      }
      function $u2(t, e2) {
        return e2.length < 2 ? t : me3(t, At2(e2, 0, -1));
      }
      function xh2(t, e2) {
        for (var n4 = t.length, r3 = et3(e2.length, n4), u3 = ut3(t); r3--; ) {
          var o5 = e2[r3];
          t[r3] = Qt2(o5, n4) ? u3[o5] : i3;
        }
        return t;
      }
      function Pi2(t, e2) {
        if (!(e2 === "constructor" && typeof t[e2] == "function") && e2 != "__proto__") return t[e2];
      }
      var Uu2 = Fu2(uu), dn2 = qc || function(t, e2) {
        return j4.setTimeout(t, e2);
      }, Ci = Fu2(Yf);
      function qu2(t, e2, n4) {
        var r3 = e2 + "";
        return Ci(t, gh2(r3, Eh2(lh2(r3), n4)));
      }
      function Fu2(t) {
        var e2 = 0, n4 = 0;
        return function() {
          var r3 = Bc(), u3 = za - (r3 - n4);
          if (n4 = r3, u3 > 0) {
            if (++e2 >= Ga) return arguments[0];
          } else e2 = 0;
          return t.apply(i3, arguments);
        };
      }
      function rr3(t, e2) {
        var n4 = -1, r3 = t.length, u3 = r3 - 1;
        for (e2 = e2 === i3 ? r3 : e2; ++n4 < e2; ) {
          var o5 = ri2(n4, u3), c5 = t[o5];
          t[o5] = t[n4], t[n4] = c5;
        }
        return t.length = e2, t;
      }
      var Wu = Ph(function(t) {
        var e2 = [];
        return t.charCodeAt(0) === 46 && e2.push(""), t.replace(lo, function(n4, r3, u3, o5) {
          e2.push(u3 ? o5.replace(Co, "$1") : r3 || n4);
        }), e2;
      });
      function Wt2(t) {
        if (typeof t == "string" || pt3(t)) return t;
        var e2 = t + "";
        return e2 == "0" && 1 / t == -le2 ? "-0" : e2;
      }
      function Pe3(t) {
        if (t != null) {
          try {
            return Ln.call(t);
          } catch {
          }
          try {
            return t + "";
          } catch {
          }
        }
        return "";
      }
      function Eh2(t, e2) {
        return mt2(Qa, function(n4) {
          var r3 = "_." + n4[0];
          e2 & n4[1] && !Sn2(t, r3) && t.push(r3);
        }), t.sort();
      }
      function Mu2(t) {
        if (t instanceof N2) return t.clone();
        var e2 = new Pt2(t.__wrapped__, t.__chain__);
        return e2.__actions__ = ut3(t.__actions__), e2.__index__ = t.__index__, e2.__values__ = t.__values__, e2;
      }
      function yh2(t, e2, n4) {
        (n4 ? it3(t, e2, n4) : e2 === i3) ? e2 = 1 : e2 = V(T3(e2), 0);
        var r3 = t == null ? 0 : t.length;
        if (!r3 || e2 < 1) return [];
        for (var u3 = 0, o5 = 0, c5 = d3(Fn(r3 / e2)); u3 < r3; ) c5[o5++] = At2(t, u3, u3 += e2);
        return c5;
      }
      function Sh2(t) {
        for (var e2 = -1, n4 = t == null ? 0 : t.length, r3 = 0, u3 = []; ++e2 < n4; ) {
          var o5 = t[e2];
          o5 && (u3[r3++] = o5);
        }
        return u3;
      }
      function Oh() {
        var t = arguments.length;
        if (!t) return [];
        for (var e2 = d3(t - 1), n4 = arguments[0], r3 = t; r3--; ) e2[r3 - 1] = arguments[r3];
        return re(b3(n4) ? ut3(n4) : [n4], tt3(e2, 1));
      }
      var Rh2 = H(function(t, e2) {
        return Z2(t) ? on3(t, tt3(e2, 1, Z2, true)) : [];
      }), bh2 = H(function(t, e2) {
        var n4 = It2(e2);
        return Z2(n4) && (n4 = i3), Z2(t) ? on3(t, tt3(e2, 1, Z2, true), E4(n4, 2)) : [];
      }), Th = H(function(t, e2) {
        var n4 = It2(e2);
        return Z2(n4) && (n4 = i3), Z2(t) ? on3(t, tt3(e2, 1, Z2, true), i3, n4) : [];
      });
      function Lh(t, e2, n4) {
        var r3 = t == null ? 0 : t.length;
        return r3 ? (e2 = n4 || e2 === i3 ? 1 : T3(e2), At2(t, e2 < 0 ? 0 : e2, r3)) : [];
      }
      function Hh(t, e2, n4) {
        var r3 = t == null ? 0 : t.length;
        return r3 ? (e2 = n4 || e2 === i3 ? 1 : T3(e2), e2 = r3 - e2, At2(t, 0, e2 < 0 ? 0 : e2)) : [];
      }
      function Dh(t, e2) {
        return t && t.length ? Xn(t, E4(e2, 3), true, true) : [];
      }
      function Nh(t, e2) {
        return t && t.length ? Xn(t, E4(e2, 3), true) : [];
      }
      function $h(t, e2, n4, r3) {
        var u3 = t == null ? 0 : t.length;
        return u3 ? (n4 && typeof n4 != "number" && it3(t, e2, n4) && (n4 = 0, r3 = u3), Of(t, e2, n4, r3)) : [];
      }
      function Bu2(t, e2, n4) {
        var r3 = t == null ? 0 : t.length;
        if (!r3) return -1;
        var u3 = n4 == null ? 0 : T3(n4);
        return u3 < 0 && (u3 = V(r3 + u3, 0)), On2(t, E4(e2, 3), u3);
      }
      function Gu(t, e2, n4) {
        var r3 = t == null ? 0 : t.length;
        if (!r3) return -1;
        var u3 = r3 - 1;
        return n4 !== i3 && (u3 = T3(n4), u3 = n4 < 0 ? V(r3 + u3, 0) : et3(u3, r3 - 1)), On2(t, E4(e2, 3), u3, true);
      }
      function zu2(t) {
        var e2 = t == null ? 0 : t.length;
        return e2 ? tt3(t, 1) : [];
      }
      function Uh(t) {
        var e2 = t == null ? 0 : t.length;
        return e2 ? tt3(t, le2) : [];
      }
      function qh(t, e2) {
        var n4 = t == null ? 0 : t.length;
        return n4 ? (e2 = e2 === i3 ? 1 : T3(e2), tt3(t, e2)) : [];
      }
      function Fh(t) {
        for (var e2 = -1, n4 = t == null ? 0 : t.length, r3 = {}; ++e2 < n4; ) {
          var u3 = t[e2];
          r3[u3[0]] = u3[1];
        }
        return r3;
      }
      function Ku(t) {
        return t && t.length ? t[0] : i3;
      }
      function Wh(t, e2, n4) {
        var r3 = t == null ? 0 : t.length;
        if (!r3) return -1;
        var u3 = n4 == null ? 0 : T3(n4);
        return u3 < 0 && (u3 = V(r3 + u3, 0)), Te2(t, e2, u3);
      }
      function Mh2(t) {
        var e2 = t == null ? 0 : t.length;
        return e2 ? At2(t, 0, -1) : [];
      }
      var Bh2 = H(function(t) {
        var e2 = z4(t, oi2);
        return e2.length && e2[0] === t[0] ? kr2(e2) : [];
      }), Gh = H(function(t) {
        var e2 = It2(t), n4 = z4(t, oi2);
        return e2 === It2(n4) ? e2 = i3 : n4.pop(), n4.length && n4[0] === t[0] ? kr2(n4, E4(e2, 2)) : [];
      }), zh = H(function(t) {
        var e2 = It2(t), n4 = z4(t, oi2);
        return e2 = typeof e2 == "function" ? e2 : i3, e2 && n4.pop(), n4.length && n4[0] === t[0] ? kr2(n4, i3, e2) : [];
      });
      function Kh(t, e2) {
        return t == null ? "" : Wc.call(t, e2);
      }
      function It2(t) {
        var e2 = t == null ? 0 : t.length;
        return e2 ? t[e2 - 1] : i3;
      }
      function Jh(t, e2, n4) {
        var r3 = t == null ? 0 : t.length;
        if (!r3) return -1;
        var u3 = r3;
        return n4 !== i3 && (u3 = T3(n4), u3 = u3 < 0 ? V(r3 + u3, 0) : et3(u3, r3 - 1)), e2 === e2 ? xc(t, e2, u3) : On2(t, Es3, u3, true);
      }
      function Yh(t, e2) {
        return t && t.length ? nu(t, T3(e2)) : i3;
      }
      var Zh = H(Ju);
      function Ju(t, e2) {
        return t && t.length && e2 && e2.length ? ni2(t, e2) : t;
      }
      function Xh(t, e2, n4) {
        return t && t.length && e2 && e2.length ? ni2(t, e2, E4(n4, 2)) : t;
      }
      function Qh(t, e2, n4) {
        return t && t.length && e2 && e2.length ? ni2(t, e2, i3, n4) : t;
      }
      var Vh = Xt2(function(t, e2) {
        var n4 = t == null ? 0 : t.length, r3 = Zr2(t, e2);
        return su(t, z4(e2, function(u3) {
          return Qt2(u3, n4) ? +u3 : u3;
        }).sort(gu2)), r3;
      });
      function kh(t, e2) {
        var n4 = [];
        if (!(t && t.length)) return n4;
        var r3 = -1, u3 = [], o5 = t.length;
        for (e2 = E4(e2, 3); ++r3 < o5; ) {
          var c5 = t[r3];
          e2(c5, r3, t) && (n4.push(c5), u3.push(r3));
        }
        return su(t, u3), n4;
      }
      function Ai(t) {
        return t == null ? t : zc.call(t);
      }
      function jh(t, e2, n4) {
        var r3 = t == null ? 0 : t.length;
        return r3 ? (n4 && typeof n4 != "number" && it3(t, e2, n4) ? (e2 = 0, n4 = r3) : (e2 = e2 == null ? 0 : T3(e2), n4 = n4 === i3 ? r3 : T3(n4)), At2(t, e2, n4)) : [];
      }
      function tl(t, e2) {
        return Zn(t, e2);
      }
      function el(t, e2, n4) {
        return si2(t, e2, E4(n4, 2));
      }
      function nl(t, e2) {
        var n4 = t == null ? 0 : t.length;
        if (n4) {
          var r3 = Zn(t, e2);
          if (r3 < n4 && Rt2(t[r3], e2)) return r3;
        }
        return -1;
      }
      function rl(t, e2) {
        return Zn(t, e2, true);
      }
      function il(t, e2, n4) {
        return si2(t, e2, E4(n4, 2), true);
      }
      function sl(t, e2) {
        var n4 = t == null ? 0 : t.length;
        if (n4) {
          var r3 = Zn(t, e2, true) - 1;
          if (Rt2(t[r3], e2)) return r3;
        }
        return -1;
      }
      function ul(t) {
        return t && t.length ? au(t) : [];
      }
      function al(t, e2) {
        return t && t.length ? au(t, E4(e2, 2)) : [];
      }
      function ol(t) {
        var e2 = t == null ? 0 : t.length;
        return e2 ? At2(t, 1, e2) : [];
      }
      function cl(t, e2, n4) {
        return t && t.length ? (e2 = n4 || e2 === i3 ? 1 : T3(e2), At2(t, 0, e2 < 0 ? 0 : e2)) : [];
      }
      function fl(t, e2, n4) {
        var r3 = t == null ? 0 : t.length;
        return r3 ? (e2 = n4 || e2 === i3 ? 1 : T3(e2), e2 = r3 - e2, At2(t, e2 < 0 ? 0 : e2, r3)) : [];
      }
      function hl(t, e2) {
        return t && t.length ? Xn(t, E4(e2, 3), false, true) : [];
      }
      function ll(t, e2) {
        return t && t.length ? Xn(t, E4(e2, 3)) : [];
      }
      var pl = H(function(t) {
        return ae3(tt3(t, 1, Z2, true));
      }), dl = H(function(t) {
        var e2 = It2(t);
        return Z2(e2) && (e2 = i3), ae3(tt3(t, 1, Z2, true), E4(e2, 2));
      }), gl = H(function(t) {
        var e2 = It2(t);
        return e2 = typeof e2 == "function" ? e2 : i3, ae3(tt3(t, 1, Z2, true), i3, e2);
      });
      function vl(t) {
        return t && t.length ? ae3(t) : [];
      }
      function _l(t, e2) {
        return t && t.length ? ae3(t, E4(e2, 2)) : [];
      }
      function ml(t, e2) {
        return e2 = typeof e2 == "function" ? e2 : i3, t && t.length ? ae3(t, i3, e2) : [];
      }
      function Ii(t) {
        if (!(t && t.length)) return [];
        var e2 = 0;
        return t = ne2(t, function(n4) {
          if (Z2(n4)) return e2 = V(n4.length, e2), true;
        }), Wr3(e2, function(n4) {
          return z4(t, Ur2(n4));
        });
      }
      function Yu(t, e2) {
        if (!(t && t.length)) return [];
        var n4 = Ii(t);
        return e2 == null ? n4 : z4(n4, function(r3) {
          return ft2(e2, i3, r3);
        });
      }
      var wl = H(function(t, e2) {
        return Z2(t) ? on3(t, e2) : [];
      }), Pl = H(function(t) {
        return ai2(ne2(t, Z2));
      }), Cl = H(function(t) {
        var e2 = It2(t);
        return Z2(e2) && (e2 = i3), ai2(ne2(t, Z2), E4(e2, 2));
      }), Al = H(function(t) {
        var e2 = It2(t);
        return e2 = typeof e2 == "function" ? e2 : i3, ai2(ne2(t, Z2), i3, e2);
      }), Il = H(Ii);
      function xl(t, e2) {
        return hu(t || [], e2 || [], an2);
      }
      function El(t, e2) {
        return hu(t || [], e2 || [], hn2);
      }
      var yl = H(function(t) {
        var e2 = t.length, n4 = e2 > 1 ? t[e2 - 1] : i3;
        return n4 = typeof n4 == "function" ? (t.pop(), n4) : i3, Yu(t, n4);
      });
      function Zu2(t) {
        var e2 = a5(t);
        return e2.__chain__ = true, e2;
      }
      function Sl(t, e2) {
        return e2(t), t;
      }
      function ir2(t, e2) {
        return e2(t);
      }
      var Ol = Xt2(function(t) {
        var e2 = t.length, n4 = e2 ? t[0] : 0, r3 = this.__wrapped__, u3 = function(o5) {
          return Zr2(o5, t);
        };
        return e2 > 1 || this.__actions__.length || !(r3 instanceof N2) || !Qt2(n4) ? this.thru(u3) : (r3 = r3.slice(n4, +n4 + (e2 ? 1 : 0)), r3.__actions__.push({ func: ir2, args: [u3], thisArg: i3 }), new Pt2(r3, this.__chain__).thru(function(o5) {
          return e2 && !o5.length && o5.push(i3), o5;
        }));
      });
      function Rl() {
        return Zu2(this);
      }
      function bl() {
        return new Pt2(this.value(), this.__chain__);
      }
      function Tl() {
        this.__values__ === i3 && (this.__values__ = oa(this.value()));
        var t = this.__index__ >= this.__values__.length, e2 = t ? i3 : this.__values__[this.__index__++];
        return { done: t, value: e2 };
      }
      function Ll() {
        return this;
      }
      function Hl(t) {
        for (var e2, n4 = this; n4 instanceof Gn; ) {
          var r3 = Mu2(n4);
          r3.__index__ = 0, r3.__values__ = i3, e2 ? u3.__wrapped__ = r3 : e2 = r3;
          var u3 = r3;
          n4 = n4.__wrapped__;
        }
        return u3.__wrapped__ = t, e2;
      }
      function Dl() {
        var t = this.__wrapped__;
        if (t instanceof N2) {
          var e2 = t;
          return this.__actions__.length && (e2 = new N2(this)), e2 = e2.reverse(), e2.__actions__.push({ func: ir2, args: [Ai], thisArg: i3 }), new Pt2(e2, this.__chain__);
        }
        return this.thru(Ai);
      }
      function Nl() {
        return fu(this.__wrapped__, this.__actions__);
      }
      var $l = Qn(function(t, e2, n4) {
        W.call(t, n4) ? ++t[n4] : Yt3(t, n4, 1);
      });
      function Ul(t, e2, n4) {
        var r3 = b3(t) ? Is4 : Sf;
        return n4 && it3(t, e2, n4) && (e2 = i3), r3(t, E4(e2, 3));
      }
      function ql(t, e2) {
        var n4 = b3(t) ? ne2 : Ys2;
        return n4(t, E4(e2, 3));
      }
      var Fl = Cu2(Bu2), Wl = Cu2(Gu);
      function Ml(t, e2) {
        return tt3(sr2(t, e2), 1);
      }
      function Bl(t, e2) {
        return tt3(sr2(t, e2), le2);
      }
      function Gl(t, e2, n4) {
        return n4 = n4 === i3 ? 1 : T3(n4), tt3(sr2(t, e2), n4);
      }
      function Xu2(t, e2) {
        var n4 = b3(t) ? mt2 : ue2;
        return n4(t, E4(e2, 3));
      }
      function Qu(t, e2) {
        var n4 = b3(t) ? ac : Js2;
        return n4(t, E4(e2, 3));
      }
      var zl = Qn(function(t, e2, n4) {
        W.call(t, n4) ? t[n4].push(e2) : Yt3(t, n4, [e2]);
      });
      function Kl2(t, e2, n4, r3) {
        t = at3(t) ? t : Ge(t), n4 = n4 && !r3 ? T3(n4) : 0;
        var u3 = t.length;
        return n4 < 0 && (n4 = V(u3 + n4, 0)), fr2(t) ? n4 <= u3 && t.indexOf(e2, n4) > -1 : !!u3 && Te2(t, e2, n4) > -1;
      }
      var Jl = H(function(t, e2, n4) {
        var r3 = -1, u3 = typeof e2 == "function", o5 = at3(t) ? d3(t.length) : [];
        return ue2(t, function(c5) {
          o5[++r3] = u3 ? ft2(e2, c5, n4) : cn2(c5, e2, n4);
        }), o5;
      }), Yl = Qn(function(t, e2, n4) {
        Yt3(t, n4, e2);
      });
      function sr2(t, e2) {
        var n4 = b3(t) ? z4 : js2;
        return n4(t, E4(e2, 3));
      }
      function Zl(t, e2, n4, r3) {
        return t == null ? [] : (b3(e2) || (e2 = e2 == null ? [] : [e2]), n4 = r3 ? i3 : n4, b3(n4) || (n4 = n4 == null ? [] : [n4]), ru(t, e2, n4));
      }
      var Xl = Qn(function(t, e2, n4) {
        t[n4 ? 0 : 1].push(e2);
      }, function() {
        return [[], []];
      });
      function Ql(t, e2, n4) {
        var r3 = b3(t) ? Nr3 : Ss4, u3 = arguments.length < 3;
        return r3(t, E4(e2, 4), n4, u3, ue2);
      }
      function Vl(t, e2, n4) {
        var r3 = b3(t) ? oc : Ss4, u3 = arguments.length < 3;
        return r3(t, E4(e2, 4), n4, u3, Js2);
      }
      function kl(t, e2) {
        var n4 = b3(t) ? ne2 : Ys2;
        return n4(t, or2(E4(e2, 3)));
      }
      function jl(t) {
        var e2 = b3(t) ? Bs2 : Kf;
        return e2(t);
      }
      function tp(t, e2, n4) {
        (n4 ? it3(t, e2, n4) : e2 === i3) ? e2 = 1 : e2 = T3(e2);
        var r3 = b3(t) ? Af : Jf;
        return r3(t, e2);
      }
      function ep(t) {
        var e2 = b3(t) ? If : Zf;
        return e2(t);
      }
      function np(t) {
        if (t == null) return 0;
        if (at3(t)) return fr2(t) ? He(t) : t.length;
        var e2 = nt3(t);
        return e2 == Et2 || e2 == yt3 ? t.size : ti2(t).length;
      }
      function rp(t, e2, n4) {
        var r3 = b3(t) ? $r2 : Xf;
        return n4 && it3(t, e2, n4) && (e2 = i3), r3(t, E4(e2, 3));
      }
      var ip = H(function(t, e2) {
        if (t == null) return [];
        var n4 = e2.length;
        return n4 > 1 && it3(t, e2[0], e2[1]) ? e2 = [] : n4 > 2 && it3(e2[0], e2[1], e2[2]) && (e2 = [e2[0]]), ru(t, tt3(e2, 1), []);
      }), ur2 = Uc || function() {
        return j4.Date.now();
      };
      function sp(t, e2) {
        if (typeof e2 != "function") throw new wt2(y6);
        return t = T3(t), function() {
          if (--t < 1) return e2.apply(this, arguments);
        };
      }
      function Vu(t, e2, n4) {
        return e2 = n4 ? i3 : e2, e2 = t && e2 == null ? t.length : e2, Zt2(t, Gt2, i3, i3, i3, i3, e2);
      }
      function ku2(t, e2) {
        var n4;
        if (typeof e2 != "function") throw new wt2(y6);
        return t = T3(t), function() {
          return --t > 0 && (n4 = e2.apply(this, arguments)), t <= 1 && (e2 = i3), n4;
        };
      }
      var xi = H(function(t, e2, n4) {
        var r3 = vt2;
        if (n4.length) {
          var u3 = ie(n4, Me(xi));
          r3 |= $t2;
        }
        return Zt2(t, r3, e2, n4, u3);
      }), ju2 = H(function(t, e2, n4) {
        var r3 = vt2 | he2;
        if (n4.length) {
          var u3 = ie(n4, Me(ju2));
          r3 |= $t2;
        }
        return Zt2(e2, r3, t, n4, u3);
      });
      function ta(t, e2, n4) {
        e2 = n4 ? i3 : e2;
        var r3 = Zt2(t, Nt2, i3, i3, i3, i3, i3, e2);
        return r3.placeholder = ta.placeholder, r3;
      }
      function ea(t, e2, n4) {
        e2 = n4 ? i3 : e2;
        var r3 = Zt2(t, ye2, i3, i3, i3, i3, i3, e2);
        return r3.placeholder = ea.placeholder, r3;
      }
      function na(t, e2, n4) {
        var r3, u3, o5, c5, f4, l4, v4 = 0, _3 = false, m2 = false, C2 = true;
        if (typeof t != "function") throw new wt2(y6);
        e2 = xt2(e2) || 0, K3(n4) && (_3 = !!n4.leading, m2 = "maxWait" in n4, o5 = m2 ? V(xt2(n4.maxWait) || 0, e2) : o5, C2 = "trailing" in n4 ? !!n4.trailing : C2);
        function x4(X) {
          var bt2 = r3, jt2 = u3;
          return r3 = u3 = i3, v4 = X, c5 = t.apply(jt2, bt2), c5;
        }
        function S3(X) {
          return v4 = X, f4 = dn2(D3, e2), _3 ? x4(X) : c5;
        }
        function L2(X) {
          var bt2 = X - l4, jt2 = X - v4, Ca = e2 - bt2;
          return m2 ? et3(Ca, o5 - jt2) : Ca;
        }
        function O4(X) {
          var bt2 = X - l4, jt2 = X - v4;
          return l4 === i3 || bt2 >= e2 || bt2 < 0 || m2 && jt2 >= o5;
        }
        function D3() {
          var X = ur2();
          if (O4(X)) return $2(X);
          f4 = dn2(D3, L2(X));
        }
        function $2(X) {
          return f4 = i3, C2 && r3 ? x4(X) : (r3 = u3 = i3, c5);
        }
        function dt3() {
          f4 !== i3 && lu(f4), v4 = 0, r3 = l4 = u3 = f4 = i3;
        }
        function st3() {
          return f4 === i3 ? c5 : $2(ur2());
        }
        function gt3() {
          var X = ur2(), bt2 = O4(X);
          if (r3 = arguments, u3 = this, l4 = X, bt2) {
            if (f4 === i3) return S3(l4);
            if (m2) return lu(f4), f4 = dn2(D3, e2), x4(l4);
          }
          return f4 === i3 && (f4 = dn2(D3, e2)), c5;
        }
        return gt3.cancel = dt3, gt3.flush = st3, gt3;
      }
      var up = H(function(t, e2) {
        return Ks2(t, 1, e2);
      }), ap = H(function(t, e2, n4) {
        return Ks2(t, xt2(e2) || 0, n4);
      });
      function op(t) {
        return Zt2(t, gr3);
      }
      function ar2(t, e2) {
        if (typeof t != "function" || e2 != null && typeof e2 != "function") throw new wt2(y6);
        var n4 = function() {
          var r3 = arguments, u3 = e2 ? e2.apply(this, r3) : r3[0], o5 = n4.cache;
          if (o5.has(u3)) return o5.get(u3);
          var c5 = t.apply(this, r3);
          return n4.cache = o5.set(u3, c5) || o5, c5;
        };
        return n4.cache = new (ar2.Cache || Jt2)(), n4;
      }
      ar2.Cache = Jt2;
      function or2(t) {
        if (typeof t != "function") throw new wt2(y6);
        return function() {
          var e2 = arguments;
          switch (e2.length) {
            case 0:
              return !t.call(this);
            case 1:
              return !t.call(this, e2[0]);
            case 2:
              return !t.call(this, e2[0], e2[1]);
            case 3:
              return !t.call(this, e2[0], e2[1], e2[2]);
          }
          return !t.apply(this, e2);
        };
      }
      function cp(t) {
        return ku2(2, t);
      }
      var fp = Qf(function(t, e2) {
        e2 = e2.length == 1 && b3(e2[0]) ? z4(e2[0], ht3(E4())) : z4(tt3(e2, 1), ht3(E4()));
        var n4 = e2.length;
        return H(function(r3) {
          for (var u3 = -1, o5 = et3(r3.length, n4); ++u3 < o5; ) r3[u3] = e2[u3].call(this, r3[u3]);
          return ft2(t, this, r3);
        });
      }), Ei = H(function(t, e2) {
        var n4 = ie(e2, Me(Ei));
        return Zt2(t, $t2, i3, e2, n4);
      }), ra = H(function(t, e2) {
        var n4 = ie(e2, Me(ra));
        return Zt2(t, Se, i3, e2, n4);
      }), hp = Xt2(function(t, e2) {
        return Zt2(t, Je, i3, i3, i3, e2);
      });
      function lp(t, e2) {
        if (typeof t != "function") throw new wt2(y6);
        return e2 = e2 === i3 ? e2 : T3(e2), H(t, e2);
      }
      function pp(t, e2) {
        if (typeof t != "function") throw new wt2(y6);
        return e2 = e2 == null ? 0 : V(T3(e2), 0), H(function(n4) {
          var r3 = n4[e2], u3 = ce2(n4, 0, e2);
          return r3 && re(u3, r3), ft2(t, this, u3);
        });
      }
      function dp(t, e2, n4) {
        var r3 = true, u3 = true;
        if (typeof t != "function") throw new wt2(y6);
        return K3(n4) && (r3 = "leading" in n4 ? !!n4.leading : r3, u3 = "trailing" in n4 ? !!n4.trailing : u3), na(t, e2, { leading: r3, maxWait: e2, trailing: u3 });
      }
      function gp(t) {
        return Vu(t, 1);
      }
      function vp(t, e2) {
        return Ei(ci2(e2), t);
      }
      function _p() {
        if (!arguments.length) return [];
        var t = arguments[0];
        return b3(t) ? t : [t];
      }
      function mp(t) {
        return Ct2(t, xe3);
      }
      function wp(t, e2) {
        return e2 = typeof e2 == "function" ? e2 : i3, Ct2(t, xe3, e2);
      }
      function Pp(t) {
        return Ct2(t, Dt2 | xe3);
      }
      function Cp(t, e2) {
        return e2 = typeof e2 == "function" ? e2 : i3, Ct2(t, Dt2 | xe3, e2);
      }
      function Ap(t, e2) {
        return e2 == null || zs2(t, e2, k3(e2));
      }
      function Rt2(t, e2) {
        return t === e2 || t !== t && e2 !== e2;
      }
      var Ip = tr2(Vr3), xp = tr2(function(t, e2) {
        return t >= e2;
      }), Ce3 = Qs2(/* @__PURE__ */ function() {
        return arguments;
      }()) ? Qs2 : function(t) {
        return Y2(t) && W.call(t, "callee") && !$s2.call(t, "callee");
      }, b3 = d3.isArray, Ep = _s3 ? ht3(_s3) : Hf;
      function at3(t) {
        return t != null && cr2(t.length) && !Vt2(t);
      }
      function Z2(t) {
        return Y2(t) && at3(t);
      }
      function yp(t) {
        return t === true || t === false || Y2(t) && rt3(t) == Ye;
      }
      var fe2 = Fc || $i, Sp = ms3 ? ht3(ms3) : Df;
      function Op(t) {
        return Y2(t) && t.nodeType === 1 && !gn2(t);
      }
      function Rp(t) {
        if (t == null) return true;
        if (at3(t) && (b3(t) || typeof t == "string" || typeof t.splice == "function" || fe2(t) || Be(t) || Ce3(t))) return !t.length;
        var e2 = nt3(t);
        if (e2 == Et2 || e2 == yt3) return !t.size;
        if (pn2(t)) return !ti2(t).length;
        for (var n4 in t) if (W.call(t, n4)) return false;
        return true;
      }
      function bp(t, e2) {
        return fn2(t, e2);
      }
      function Tp(t, e2, n4) {
        n4 = typeof n4 == "function" ? n4 : i3;
        var r3 = n4 ? n4(t, e2) : i3;
        return r3 === i3 ? fn2(t, e2, i3, n4) : !!r3;
      }
      function yi2(t) {
        if (!Y2(t)) return false;
        var e2 = rt3(t);
        return e2 == Cn2 || e2 == ka || typeof t.message == "string" && typeof t.name == "string" && !gn2(t);
      }
      function Lp(t) {
        return typeof t == "number" && qs3(t);
      }
      function Vt2(t) {
        if (!K3(t)) return false;
        var e2 = rt3(t);
        return e2 == An2 || e2 == Ki || e2 == Va || e2 == to;
      }
      function ia(t) {
        return typeof t == "number" && t == T3(t);
      }
      function cr2(t) {
        return typeof t == "number" && t > -1 && t % 1 == 0 && t <= ee2;
      }
      function K3(t) {
        var e2 = typeof t;
        return t != null && (e2 == "object" || e2 == "function");
      }
      function Y2(t) {
        return t != null && typeof t == "object";
      }
      var sa = ws3 ? ht3(ws3) : $f;
      function Hp(t, e2) {
        return t === e2 || jr2(t, e2, vi(e2));
      }
      function Dp(t, e2, n4) {
        return n4 = typeof n4 == "function" ? n4 : i3, jr2(t, e2, vi(e2), n4);
      }
      function Np(t) {
        return ua(t) && t != +t;
      }
      function $p(t) {
        if (wh2(t)) throw new R2(I3);
        return Vs2(t);
      }
      function Up(t) {
        return t === null;
      }
      function qp(t) {
        return t == null;
      }
      function ua(t) {
        return typeof t == "number" || Y2(t) && rt3(t) == Xe2;
      }
      function gn2(t) {
        if (!Y2(t) || rt3(t) != zt2) return false;
        var e2 = $n(t);
        if (e2 === null) return true;
        var n4 = W.call(e2, "constructor") && e2.constructor;
        return typeof n4 == "function" && n4 instanceof n4 && Ln.call(n4) == Hc;
      }
      var Si = Ps2 ? ht3(Ps2) : Uf;
      function Fp(t) {
        return ia(t) && t >= -ee2 && t <= ee2;
      }
      var aa = Cs2 ? ht3(Cs2) : qf;
      function fr2(t) {
        return typeof t == "string" || !b3(t) && Y2(t) && rt3(t) == Ve;
      }
      function pt3(t) {
        return typeof t == "symbol" || Y2(t) && rt3(t) == In2;
      }
      var Be = As3 ? ht3(As3) : Ff;
      function Wp(t) {
        return t === i3;
      }
      function Mp(t) {
        return Y2(t) && nt3(t) == ke;
      }
      function Bp(t) {
        return Y2(t) && rt3(t) == no;
      }
      var Gp = tr2(ei2), zp = tr2(function(t, e2) {
        return t <= e2;
      });
      function oa(t) {
        if (!t) return [];
        if (at3(t)) return fr2(t) ? St2(t) : ut3(t);
        if (en2 && t[en2]) return Cc(t[en2]());
        var e2 = nt3(t), n4 = e2 == Et2 ? Br2 : e2 == yt3 ? Rn2 : Ge;
        return n4(t);
      }
      function kt2(t) {
        if (!t) return t === 0 ? t : 0;
        if (t = xt2(t), t === le2 || t === -le2) {
          var e2 = t < 0 ? -1 : 1;
          return e2 * Ya;
        }
        return t === t ? t : 0;
      }
      function T3(t) {
        var e2 = kt2(t), n4 = e2 % 1;
        return e2 === e2 ? n4 ? e2 - n4 : e2 : 0;
      }
      function ca(t) {
        return t ? _e3(T3(t), 0, Ut2) : 0;
      }
      function xt2(t) {
        if (typeof t == "number") return t;
        if (pt3(t)) return wn2;
        if (K3(t)) {
          var e2 = typeof t.valueOf == "function" ? t.valueOf() : t;
          t = K3(e2) ? e2 + "" : e2;
        }
        if (typeof t != "string") return t === 0 ? t : +t;
        t = Os2(t);
        var n4 = xo2.test(t);
        return n4 || yo.test(t) ? ic(t.slice(2), n4 ? 2 : 8) : Io.test(t) ? wn2 : +t;
      }
      function fa(t) {
        return Ft2(t, ot3(t));
      }
      function Kp(t) {
        return t ? _e3(T3(t), -ee2, ee2) : t === 0 ? t : 0;
      }
      function q2(t) {
        return t == null ? "" : lt3(t);
      }
      var Jp = Fe(function(t, e2) {
        if (pn2(e2) || at3(e2)) {
          Ft2(e2, k3(e2), t);
          return;
        }
        for (var n4 in e2) W.call(e2, n4) && an2(t, n4, e2[n4]);
      }), ha = Fe(function(t, e2) {
        Ft2(e2, ot3(e2), t);
      }), hr2 = Fe(function(t, e2, n4, r3) {
        Ft2(e2, ot3(e2), t, r3);
      }), Yp = Fe(function(t, e2, n4, r3) {
        Ft2(e2, k3(e2), t, r3);
      }), Zp = Xt2(Zr2);
      function Xp(t, e2) {
        var n4 = qe(t);
        return e2 == null ? n4 : Gs2(n4, e2);
      }
      var Qp = H(function(t, e2) {
        t = M3(t);
        var n4 = -1, r3 = e2.length, u3 = r3 > 2 ? e2[2] : i3;
        for (u3 && it3(e2[0], e2[1], u3) && (r3 = 1); ++n4 < r3; ) for (var o5 = e2[n4], c5 = ot3(o5), f4 = -1, l4 = c5.length; ++f4 < l4; ) {
          var v4 = c5[f4], _3 = t[v4];
          (_3 === i3 || Rt2(_3, Ne[v4]) && !W.call(t, v4)) && (t[v4] = o5[v4]);
        }
        return t;
      }), Vp = H(function(t) {
        return t.push(i3, Ou2), ft2(la, i3, t);
      });
      function kp(t, e2) {
        return xs3(t, E4(e2, 3), qt2);
      }
      function jp(t, e2) {
        return xs3(t, E4(e2, 3), Qr2);
      }
      function td(t, e2) {
        return t == null ? t : Xr3(t, E4(e2, 3), ot3);
      }
      function ed(t, e2) {
        return t == null ? t : Zs2(t, E4(e2, 3), ot3);
      }
      function nd(t, e2) {
        return t && qt2(t, E4(e2, 3));
      }
      function rd(t, e2) {
        return t && Qr2(t, E4(e2, 3));
      }
      function id(t) {
        return t == null ? [] : Jn(t, k3(t));
      }
      function sd(t) {
        return t == null ? [] : Jn(t, ot3(t));
      }
      function Oi(t, e2, n4) {
        var r3 = t == null ? i3 : me3(t, e2);
        return r3 === i3 ? n4 : r3;
      }
      function ud(t, e2) {
        return t != null && Tu2(t, e2, Rf);
      }
      function Ri(t, e2) {
        return t != null && Tu2(t, e2, bf);
      }
      var ad = Iu2(function(t, e2, n4) {
        e2 != null && typeof e2.toString != "function" && (e2 = Hn.call(e2)), t[e2] = n4;
      }, Ti(ct3)), od = Iu2(function(t, e2, n4) {
        e2 != null && typeof e2.toString != "function" && (e2 = Hn.call(e2)), W.call(t, e2) ? t[e2].push(n4) : t[e2] = [n4];
      }, E4), cd = H(cn2);
      function k3(t) {
        return at3(t) ? Ms3(t) : ti2(t);
      }
      function ot3(t) {
        return at3(t) ? Ms3(t, true) : Wf2(t);
      }
      function fd(t, e2) {
        var n4 = {};
        return e2 = E4(e2, 3), qt2(t, function(r3, u3, o5) {
          Yt3(n4, e2(r3, u3, o5), r3);
        }), n4;
      }
      function hd(t, e2) {
        var n4 = {};
        return e2 = E4(e2, 3), qt2(t, function(r3, u3, o5) {
          Yt3(n4, u3, e2(r3, u3, o5));
        }), n4;
      }
      var ld = Fe(function(t, e2, n4) {
        Yn(t, e2, n4);
      }), la = Fe(function(t, e2, n4, r3) {
        Yn(t, e2, n4, r3);
      }), pd = Xt2(function(t, e2) {
        var n4 = {};
        if (t == null) return n4;
        var r3 = false;
        e2 = z4(e2, function(o5) {
          return o5 = oe3(o5, t), r3 || (r3 = o5.length > 1), o5;
        }), Ft2(t, di2(t), n4), r3 && (n4 = Ct2(n4, Dt2 | Bt2 | xe3, ah));
        for (var u3 = e2.length; u3--; ) ui2(n4, e2[u3]);
        return n4;
      });
      function dd(t, e2) {
        return pa(t, or2(E4(e2)));
      }
      var gd = Xt2(function(t, e2) {
        return t == null ? {} : Bf(t, e2);
      });
      function pa(t, e2) {
        if (t == null) return {};
        var n4 = z4(di2(t), function(r3) {
          return [r3];
        });
        return e2 = E4(e2), iu(t, n4, function(r3, u3) {
          return e2(r3, u3[0]);
        });
      }
      function vd(t, e2, n4) {
        e2 = oe3(e2, t);
        var r3 = -1, u3 = e2.length;
        for (u3 || (u3 = 1, t = i3); ++r3 < u3; ) {
          var o5 = t == null ? i3 : t[Wt2(e2[r3])];
          o5 === i3 && (r3 = u3, o5 = n4), t = Vt2(o5) ? o5.call(t) : o5;
        }
        return t;
      }
      function _d(t, e2, n4) {
        return t == null ? t : hn2(t, e2, n4);
      }
      function md(t, e2, n4, r3) {
        return r3 = typeof r3 == "function" ? r3 : i3, t == null ? t : hn2(t, e2, n4, r3);
      }
      var da = yu(k3), ga = yu(ot3);
      function wd(t, e2, n4) {
        var r3 = b3(t), u3 = r3 || fe2(t) || Be(t);
        if (e2 = E4(e2, 4), n4 == null) {
          var o5 = t && t.constructor;
          u3 ? n4 = r3 ? new o5() : [] : K3(t) ? n4 = Vt2(o5) ? qe($n(t)) : {} : n4 = {};
        }
        return (u3 ? mt2 : qt2)(t, function(c5, f4, l4) {
          return e2(n4, c5, f4, l4);
        }), n4;
      }
      function Pd(t, e2) {
        return t == null ? true : ui2(t, e2);
      }
      function Cd(t, e2, n4) {
        return t == null ? t : cu(t, e2, ci2(n4));
      }
      function Ad(t, e2, n4, r3) {
        return r3 = typeof r3 == "function" ? r3 : i3, t == null ? t : cu(t, e2, ci2(n4), r3);
      }
      function Ge(t) {
        return t == null ? [] : Mr2(t, k3(t));
      }
      function Id2(t) {
        return t == null ? [] : Mr2(t, ot3(t));
      }
      function xd(t, e2, n4) {
        return n4 === i3 && (n4 = e2, e2 = i3), n4 !== i3 && (n4 = xt2(n4), n4 = n4 === n4 ? n4 : 0), e2 !== i3 && (e2 = xt2(e2), e2 = e2 === e2 ? e2 : 0), _e3(xt2(t), e2, n4);
      }
      function Ed(t, e2, n4) {
        return e2 = kt2(e2), n4 === i3 ? (n4 = e2, e2 = 0) : n4 = kt2(n4), t = xt2(t), Tf(t, e2, n4);
      }
      function yd(t, e2, n4) {
        if (n4 && typeof n4 != "boolean" && it3(t, e2, n4) && (e2 = n4 = i3), n4 === i3 && (typeof e2 == "boolean" ? (n4 = e2, e2 = i3) : typeof t == "boolean" && (n4 = t, t = i3)), t === i3 && e2 === i3 ? (t = 0, e2 = 1) : (t = kt2(t), e2 === i3 ? (e2 = t, t = 0) : e2 = kt2(e2)), t > e2) {
          var r3 = t;
          t = e2, e2 = r3;
        }
        if (n4 || t % 1 || e2 % 1) {
          var u3 = Fs2();
          return et3(t + u3 * (e2 - t + rc("1e-" + ((u3 + "").length - 1))), e2);
        }
        return ri2(t, e2);
      }
      var Sd = We(function(t, e2, n4) {
        return e2 = e2.toLowerCase(), t + (n4 ? va(e2) : e2);
      });
      function va(t) {
        return bi3(q2(t).toLowerCase());
      }
      function _a(t) {
        return t = q2(t), t && t.replace(Oo2, vc).replace(Yo, "");
      }
      function Od(t, e2, n4) {
        t = q2(t), e2 = lt3(e2);
        var r3 = t.length;
        n4 = n4 === i3 ? r3 : _e3(T3(n4), 0, r3);
        var u3 = n4;
        return n4 -= e2.length, n4 >= 0 && t.slice(n4, u3) == e2;
      }
      function Rd(t) {
        return t = q2(t), t && ao.test(t) ? t.replace(Zi, _c) : t;
      }
      function bd(t) {
        return t = q2(t), t && po.test(t) ? t.replace(Er2, "\\$&") : t;
      }
      var Td = We(function(t, e2, n4) {
        return t + (n4 ? "-" : "") + e2.toLowerCase();
      }), Ld = We(function(t, e2, n4) {
        return t + (n4 ? " " : "") + e2.toLowerCase();
      }), Hd = Pu2("toLowerCase");
      function Dd(t, e2, n4) {
        t = q2(t), e2 = T3(e2);
        var r3 = e2 ? He(t) : 0;
        if (!e2 || r3 >= e2) return t;
        var u3 = (e2 - r3) / 2;
        return jn(Wn(u3), n4) + t + jn(Fn(u3), n4);
      }
      function Nd(t, e2, n4) {
        t = q2(t), e2 = T3(e2);
        var r3 = e2 ? He(t) : 0;
        return e2 && r3 < e2 ? t + jn(e2 - r3, n4) : t;
      }
      function $d(t, e2, n4) {
        t = q2(t), e2 = T3(e2);
        var r3 = e2 ? He(t) : 0;
        return e2 && r3 < e2 ? jn(e2 - r3, n4) + t : t;
      }
      function Ud(t, e2, n4) {
        return n4 || e2 == null ? e2 = 0 : e2 && (e2 = +e2), Gc(q2(t).replace(yr2, ""), e2 || 0);
      }
      function qd(t, e2, n4) {
        return (n4 ? it3(t, e2, n4) : e2 === i3) ? e2 = 1 : e2 = T3(e2), ii2(q2(t), e2);
      }
      function Fd() {
        var t = arguments, e2 = q2(t[0]);
        return t.length < 3 ? e2 : e2.replace(t[1], t[2]);
      }
      var Wd = We(function(t, e2, n4) {
        return t + (n4 ? "_" : "") + e2.toLowerCase();
      });
      function Md(t, e2, n4) {
        return n4 && typeof n4 != "number" && it3(t, e2, n4) && (e2 = n4 = i3), n4 = n4 === i3 ? Ut2 : n4 >>> 0, n4 ? (t = q2(t), t && (typeof e2 == "string" || e2 != null && !Si(e2)) && (e2 = lt3(e2), !e2 && Le2(t)) ? ce2(St2(t), 0, n4) : t.split(e2, n4)) : [];
      }
      var Bd = We(function(t, e2, n4) {
        return t + (n4 ? " " : "") + bi3(e2);
      });
      function Gd(t, e2, n4) {
        return t = q2(t), n4 = n4 == null ? 0 : _e3(T3(n4), 0, t.length), e2 = lt3(e2), t.slice(n4, n4 + e2.length) == e2;
      }
      function zd(t, e2, n4) {
        var r3 = a5.templateSettings;
        n4 && it3(t, e2, n4) && (e2 = i3), t = q2(t), e2 = hr2({}, e2, r3, Su2);
        var u3 = hr2({}, e2.imports, r3.imports, Su2), o5 = k3(u3), c5 = Mr2(u3, o5), f4, l4, v4 = 0, _3 = e2.interpolate || xn2, m2 = "__p += '", C2 = Gr2((e2.escape || xn2).source + "|" + _3.source + "|" + (_3 === Xi ? Ao : xn2).source + "|" + (e2.evaluate || xn2).source + "|$", "g"), x4 = "//# sourceURL=" + (W.call(e2, "sourceURL") ? (e2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++ko + "]") + `
`;
        t.replace(C2, function(O4, D3, $2, dt3, st3, gt3) {
          return $2 || ($2 = dt3), m2 += t.slice(v4, gt3).replace(Ro, mc), D3 && (f4 = true, m2 += `' +
__e(` + D3 + `) +
'`), st3 && (l4 = true, m2 += `';
` + st3 + `;
__p += '`), $2 && (m2 += `' +
((__t = (` + $2 + `)) == null ? '' : __t) +
'`), v4 = gt3 + O4.length, O4;
        }), m2 += `';
`;
        var S3 = W.call(e2, "variable") && e2.variable;
        if (!S3) m2 = `with (obj) {
` + m2 + `
}
`;
        else if (Po2.test(S3)) throw new R2(J);
        m2 = (l4 ? m2.replace(ro, "") : m2).replace(io, "$1").replace(so2, "$1;"), m2 = "function(" + (S3 || "obj") + `) {
` + (S3 ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (f4 ? ", __e = _.escape" : "") + (l4 ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + m2 + `return __p
}`;
        var L2 = wa(function() {
          return U3(o5, x4 + "return " + m2).apply(i3, c5);
        });
        if (L2.source = m2, yi2(L2)) throw L2;
        return L2;
      }
      function Kd(t) {
        return q2(t).toLowerCase();
      }
      function Jd(t) {
        return q2(t).toUpperCase();
      }
      function Yd(t, e2, n4) {
        if (t = q2(t), t && (n4 || e2 === i3)) return Os2(t);
        if (!t || !(e2 = lt3(e2))) return t;
        var r3 = St2(t), u3 = St2(e2), o5 = Rs3(r3, u3), c5 = bs3(r3, u3) + 1;
        return ce2(r3, o5, c5).join("");
      }
      function Zd(t, e2, n4) {
        if (t = q2(t), t && (n4 || e2 === i3)) return t.slice(0, Ls2(t) + 1);
        if (!t || !(e2 = lt3(e2))) return t;
        var r3 = St2(t), u3 = bs3(r3, St2(e2)) + 1;
        return ce2(r3, 0, u3).join("");
      }
      function Xd(t, e2, n4) {
        if (t = q2(t), t && (n4 || e2 === i3)) return t.replace(yr2, "");
        if (!t || !(e2 = lt3(e2))) return t;
        var r3 = St2(t), u3 = Rs3(r3, St2(e2));
        return ce2(r3, u3).join("");
      }
      function Qd(t, e2) {
        var n4 = Ma, r3 = Ba;
        if (K3(e2)) {
          var u3 = "separator" in e2 ? e2.separator : u3;
          n4 = "length" in e2 ? T3(e2.length) : n4, r3 = "omission" in e2 ? lt3(e2.omission) : r3;
        }
        t = q2(t);
        var o5 = t.length;
        if (Le2(t)) {
          var c5 = St2(t);
          o5 = c5.length;
        }
        if (n4 >= o5) return t;
        var f4 = n4 - He(r3);
        if (f4 < 1) return r3;
        var l4 = c5 ? ce2(c5, 0, f4).join("") : t.slice(0, f4);
        if (u3 === i3) return l4 + r3;
        if (c5 && (f4 += l4.length - f4), Si(u3)) {
          if (t.slice(f4).search(u3)) {
            var v4, _3 = l4;
            for (u3.global || (u3 = Gr2(u3.source, q2(Qi.exec(u3)) + "g")), u3.lastIndex = 0; v4 = u3.exec(_3); ) var m2 = v4.index;
            l4 = l4.slice(0, m2 === i3 ? f4 : m2);
          }
        } else if (t.indexOf(lt3(u3), f4) != f4) {
          var C2 = l4.lastIndexOf(u3);
          C2 > -1 && (l4 = l4.slice(0, C2));
        }
        return l4 + r3;
      }
      function Vd(t) {
        return t = q2(t), t && uo.test(t) ? t.replace(Yi, Ec) : t;
      }
      var kd = We(function(t, e2, n4) {
        return t + (n4 ? " " : "") + e2.toUpperCase();
      }), bi3 = Pu2("toUpperCase");
      function ma(t, e2, n4) {
        return t = q2(t), e2 = n4 ? i3 : e2, e2 === i3 ? Pc(t) ? Oc(t) : hc(t) : t.match(e2) || [];
      }
      var wa = H(function(t, e2) {
        try {
          return ft2(t, i3, e2);
        } catch (n4) {
          return yi2(n4) ? n4 : new R2(n4);
        }
      }), jd = Xt2(function(t, e2) {
        return mt2(e2, function(n4) {
          n4 = Wt2(n4), Yt3(t, n4, xi(t[n4], t));
        }), t;
      });
      function tg(t) {
        var e2 = t == null ? 0 : t.length, n4 = E4();
        return t = e2 ? z4(t, function(r3) {
          if (typeof r3[1] != "function") throw new wt2(y6);
          return [n4(r3[0]), r3[1]];
        }) : [], H(function(r3) {
          for (var u3 = -1; ++u3 < e2; ) {
            var o5 = t[u3];
            if (ft2(o5[0], this, r3)) return ft2(o5[1], this, r3);
          }
        });
      }
      function eg(t) {
        return yf(Ct2(t, Dt2));
      }
      function Ti(t) {
        return function() {
          return t;
        };
      }
      function ng(t, e2) {
        return t == null || t !== t ? e2 : t;
      }
      var rg = Au(), ig = Au(true);
      function ct3(t) {
        return t;
      }
      function Li(t) {
        return ks2(typeof t == "function" ? t : Ct2(t, Dt2));
      }
      function sg(t) {
        return tu(Ct2(t, Dt2));
      }
      function ug(t, e2) {
        return eu(t, Ct2(e2, Dt2));
      }
      var ag = H(function(t, e2) {
        return function(n4) {
          return cn2(n4, t, e2);
        };
      }), og = H(function(t, e2) {
        return function(n4) {
          return cn2(t, n4, e2);
        };
      });
      function Hi(t, e2, n4) {
        var r3 = k3(e2), u3 = Jn(e2, r3);
        n4 == null && !(K3(e2) && (u3.length || !r3.length)) && (n4 = e2, e2 = t, t = this, u3 = Jn(e2, k3(e2)));
        var o5 = !(K3(n4) && "chain" in n4) || !!n4.chain, c5 = Vt2(t);
        return mt2(u3, function(f4) {
          var l4 = e2[f4];
          t[f4] = l4, c5 && (t.prototype[f4] = function() {
            var v4 = this.__chain__;
            if (o5 || v4) {
              var _3 = t(this.__wrapped__), m2 = _3.__actions__ = ut3(this.__actions__);
              return m2.push({ func: l4, args: arguments, thisArg: t }), _3.__chain__ = v4, _3;
            }
            return l4.apply(t, re([this.value()], arguments));
          });
        }), t;
      }
      function cg() {
        return j4._ === this && (j4._ = Dc), this;
      }
      function Di2() {
      }
      function fg(t) {
        return t = T3(t), H(function(e2) {
          return nu(e2, t);
        });
      }
      var hg = hi2(z4), lg = hi2(Is4), pg = hi2($r2);
      function Pa(t) {
        return mi2(t) ? Ur2(Wt2(t)) : Gf(t);
      }
      function dg(t) {
        return function(e2) {
          return t == null ? i3 : me3(t, e2);
        };
      }
      var gg = xu2(), vg = xu2(true);
      function Ni() {
        return [];
      }
      function $i() {
        return false;
      }
      function _g() {
        return {};
      }
      function mg() {
        return "";
      }
      function wg() {
        return true;
      }
      function Pg(t, e2) {
        if (t = T3(t), t < 1 || t > ee2) return [];
        var n4 = Ut2, r3 = et3(t, Ut2);
        e2 = E4(e2), t -= Ut2;
        for (var u3 = Wr3(r3, e2); ++n4 < t; ) e2(n4);
        return u3;
      }
      function Cg(t) {
        return b3(t) ? z4(t, Wt2) : pt3(t) ? [t] : ut3(Wu(q2(t)));
      }
      function Ag(t) {
        var e2 = ++Lc;
        return q2(t) + e2;
      }
      var Ig = kn(function(t, e2) {
        return t + e2;
      }, 0), xg = li2("ceil"), Eg = kn(function(t, e2) {
        return t / e2;
      }, 1), yg = li2("floor");
      function Sg(t) {
        return t && t.length ? Kn(t, ct3, Vr3) : i3;
      }
      function Og(t, e2) {
        return t && t.length ? Kn(t, E4(e2, 2), Vr3) : i3;
      }
      function Rg(t) {
        return ys3(t, ct3);
      }
      function bg(t, e2) {
        return ys3(t, E4(e2, 2));
      }
      function Tg(t) {
        return t && t.length ? Kn(t, ct3, ei2) : i3;
      }
      function Lg(t, e2) {
        return t && t.length ? Kn(t, E4(e2, 2), ei2) : i3;
      }
      var Hg = kn(function(t, e2) {
        return t * e2;
      }, 1), Dg = li2("round"), Ng = kn(function(t, e2) {
        return t - e2;
      }, 0);
      function $g(t) {
        return t && t.length ? Fr2(t, ct3) : 0;
      }
      function Ug(t, e2) {
        return t && t.length ? Fr2(t, E4(e2, 2)) : 0;
      }
      return a5.after = sp, a5.ary = Vu, a5.assign = Jp, a5.assignIn = ha, a5.assignInWith = hr2, a5.assignWith = Yp, a5.at = Zp, a5.before = ku2, a5.bind = xi, a5.bindAll = jd, a5.bindKey = ju2, a5.castArray = _p, a5.chain = Zu2, a5.chunk = yh2, a5.compact = Sh2, a5.concat = Oh, a5.cond = tg, a5.conforms = eg, a5.constant = Ti, a5.countBy = $l, a5.create = Xp, a5.curry = ta, a5.curryRight = ea, a5.debounce = na, a5.defaults = Qp, a5.defaultsDeep = Vp, a5.defer = up, a5.delay = ap, a5.difference = Rh2, a5.differenceBy = bh2, a5.differenceWith = Th, a5.drop = Lh, a5.dropRight = Hh, a5.dropRightWhile = Dh, a5.dropWhile = Nh, a5.fill = $h, a5.filter = ql, a5.flatMap = Ml, a5.flatMapDeep = Bl, a5.flatMapDepth = Gl, a5.flatten = zu2, a5.flattenDeep = Uh, a5.flattenDepth = qh, a5.flip = op, a5.flow = rg, a5.flowRight = ig, a5.fromPairs = Fh, a5.functions = id, a5.functionsIn = sd, a5.groupBy = zl, a5.initial = Mh2, a5.intersection = Bh2, a5.intersectionBy = Gh, a5.intersectionWith = zh, a5.invert = ad, a5.invertBy = od, a5.invokeMap = Jl, a5.iteratee = Li, a5.keyBy = Yl, a5.keys = k3, a5.keysIn = ot3, a5.map = sr2, a5.mapKeys = fd, a5.mapValues = hd, a5.matches = sg, a5.matchesProperty = ug, a5.memoize = ar2, a5.merge = ld, a5.mergeWith = la, a5.method = ag, a5.methodOf = og, a5.mixin = Hi, a5.negate = or2, a5.nthArg = fg, a5.omit = pd, a5.omitBy = dd, a5.once = cp, a5.orderBy = Zl, a5.over = hg, a5.overArgs = fp, a5.overEvery = lg, a5.overSome = pg, a5.partial = Ei, a5.partialRight = ra, a5.partition = Xl, a5.pick = gd, a5.pickBy = pa, a5.property = Pa, a5.propertyOf = dg, a5.pull = Zh, a5.pullAll = Ju, a5.pullAllBy = Xh, a5.pullAllWith = Qh, a5.pullAt = Vh, a5.range = gg, a5.rangeRight = vg, a5.rearg = hp, a5.reject = kl, a5.remove = kh, a5.rest = lp, a5.reverse = Ai, a5.sampleSize = tp, a5.set = _d, a5.setWith = md, a5.shuffle = ep, a5.slice = jh, a5.sortBy = ip, a5.sortedUniq = ul, a5.sortedUniqBy = al, a5.split = Md, a5.spread = pp, a5.tail = ol, a5.take = cl, a5.takeRight = fl, a5.takeRightWhile = hl, a5.takeWhile = ll, a5.tap = Sl, a5.throttle = dp, a5.thru = ir2, a5.toArray = oa, a5.toPairs = da, a5.toPairsIn = ga, a5.toPath = Cg, a5.toPlainObject = fa, a5.transform = wd, a5.unary = gp, a5.union = pl, a5.unionBy = dl, a5.unionWith = gl, a5.uniq = vl, a5.uniqBy = _l, a5.uniqWith = ml, a5.unset = Pd, a5.unzip = Ii, a5.unzipWith = Yu, a5.update = Cd, a5.updateWith = Ad, a5.values = Ge, a5.valuesIn = Id2, a5.without = wl, a5.words = ma, a5.wrap = vp, a5.xor = Pl, a5.xorBy = Cl, a5.xorWith = Al, a5.zip = Il, a5.zipObject = xl, a5.zipObjectDeep = El, a5.zipWith = yl, a5.entries = da, a5.entriesIn = ga, a5.extend = ha, a5.extendWith = hr2, Hi(a5, a5), a5.add = Ig, a5.attempt = wa, a5.camelCase = Sd, a5.capitalize = va, a5.ceil = xg, a5.clamp = xd, a5.clone = mp, a5.cloneDeep = Pp, a5.cloneDeepWith = Cp, a5.cloneWith = wp, a5.conformsTo = Ap, a5.deburr = _a, a5.defaultTo = ng, a5.divide = Eg, a5.endsWith = Od, a5.eq = Rt2, a5.escape = Rd, a5.escapeRegExp = bd, a5.every = Ul, a5.find = Fl, a5.findIndex = Bu2, a5.findKey = kp, a5.findLast = Wl, a5.findLastIndex = Gu, a5.findLastKey = jp, a5.floor = yg, a5.forEach = Xu2, a5.forEachRight = Qu, a5.forIn = td, a5.forInRight = ed, a5.forOwn = nd, a5.forOwnRight = rd, a5.get = Oi, a5.gt = Ip, a5.gte = xp, a5.has = ud, a5.hasIn = Ri, a5.head = Ku, a5.identity = ct3, a5.includes = Kl2, a5.indexOf = Wh, a5.inRange = Ed, a5.invoke = cd, a5.isArguments = Ce3, a5.isArray = b3, a5.isArrayBuffer = Ep, a5.isArrayLike = at3, a5.isArrayLikeObject = Z2, a5.isBoolean = yp, a5.isBuffer = fe2, a5.isDate = Sp, a5.isElement = Op, a5.isEmpty = Rp, a5.isEqual = bp, a5.isEqualWith = Tp, a5.isError = yi2, a5.isFinite = Lp, a5.isFunction = Vt2, a5.isInteger = ia, a5.isLength = cr2, a5.isMap = sa, a5.isMatch = Hp, a5.isMatchWith = Dp, a5.isNaN = Np, a5.isNative = $p, a5.isNil = qp, a5.isNull = Up, a5.isNumber = ua, a5.isObject = K3, a5.isObjectLike = Y2, a5.isPlainObject = gn2, a5.isRegExp = Si, a5.isSafeInteger = Fp, a5.isSet = aa, a5.isString = fr2, a5.isSymbol = pt3, a5.isTypedArray = Be, a5.isUndefined = Wp, a5.isWeakMap = Mp, a5.isWeakSet = Bp, a5.join = Kh, a5.kebabCase = Td, a5.last = It2, a5.lastIndexOf = Jh, a5.lowerCase = Ld, a5.lowerFirst = Hd, a5.lt = Gp, a5.lte = zp, a5.max = Sg, a5.maxBy = Og, a5.mean = Rg, a5.meanBy = bg, a5.min = Tg, a5.minBy = Lg, a5.stubArray = Ni, a5.stubFalse = $i, a5.stubObject = _g, a5.stubString = mg, a5.stubTrue = wg, a5.multiply = Hg, a5.nth = Yh, a5.noConflict = cg, a5.noop = Di2, a5.now = ur2, a5.pad = Dd, a5.padEnd = Nd, a5.padStart = $d, a5.parseInt = Ud, a5.random = yd, a5.reduce = Ql, a5.reduceRight = Vl, a5.repeat = qd, a5.replace = Fd, a5.result = vd, a5.round = Dg, a5.runInContext = h4, a5.sample = jl, a5.size = np, a5.snakeCase = Wd, a5.some = rp, a5.sortedIndex = tl, a5.sortedIndexBy = el, a5.sortedIndexOf = nl, a5.sortedLastIndex = rl, a5.sortedLastIndexBy = il, a5.sortedLastIndexOf = sl, a5.startCase = Bd, a5.startsWith = Gd, a5.subtract = Ng, a5.sum = $g, a5.sumBy = Ug, a5.template = zd, a5.times = Pg, a5.toFinite = kt2, a5.toInteger = T3, a5.toLength = ca, a5.toLower = Kd, a5.toNumber = xt2, a5.toSafeInteger = Kp, a5.toString = q2, a5.toUpper = Jd, a5.trim = Yd, a5.trimEnd = Zd, a5.trimStart = Xd, a5.truncate = Qd, a5.unescape = Vd, a5.uniqueId = Ag, a5.upperCase = kd, a5.upperFirst = bi3, a5.each = Xu2, a5.eachRight = Qu, a5.first = Ku, Hi(a5, function() {
        var t = {};
        return qt2(a5, function(e2, n4) {
          W.call(a5.prototype, n4) || (t[n4] = e2);
        }), t;
      }(), { chain: false }), a5.VERSION = p4, mt2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(t) {
        a5[t].placeholder = a5;
      }), mt2(["drop", "take"], function(t, e2) {
        N2.prototype[t] = function(n4) {
          n4 = n4 === i3 ? 1 : V(T3(n4), 0);
          var r3 = this.__filtered__ && !e2 ? new N2(this) : this.clone();
          return r3.__filtered__ ? r3.__takeCount__ = et3(n4, r3.__takeCount__) : r3.__views__.push({ size: et3(n4, Ut2), type: t + (r3.__dir__ < 0 ? "Right" : "") }), r3;
        }, N2.prototype[t + "Right"] = function(n4) {
          return this.reverse()[t](n4).reverse();
        };
      }), mt2(["filter", "map", "takeWhile"], function(t, e2) {
        var n4 = e2 + 1, r3 = n4 == zi || n4 == Ja;
        N2.prototype[t] = function(u3) {
          var o5 = this.clone();
          return o5.__iteratees__.push({ iteratee: E4(u3, 3), type: n4 }), o5.__filtered__ = o5.__filtered__ || r3, o5;
        };
      }), mt2(["head", "last"], function(t, e2) {
        var n4 = "take" + (e2 ? "Right" : "");
        N2.prototype[t] = function() {
          return this[n4](1).value()[0];
        };
      }), mt2(["initial", "tail"], function(t, e2) {
        var n4 = "drop" + (e2 ? "" : "Right");
        N2.prototype[t] = function() {
          return this.__filtered__ ? new N2(this) : this[n4](1);
        };
      }), N2.prototype.compact = function() {
        return this.filter(ct3);
      }, N2.prototype.find = function(t) {
        return this.filter(t).head();
      }, N2.prototype.findLast = function(t) {
        return this.reverse().find(t);
      }, N2.prototype.invokeMap = H(function(t, e2) {
        return typeof t == "function" ? new N2(this) : this.map(function(n4) {
          return cn2(n4, t, e2);
        });
      }), N2.prototype.reject = function(t) {
        return this.filter(or2(E4(t)));
      }, N2.prototype.slice = function(t, e2) {
        t = T3(t);
        var n4 = this;
        return n4.__filtered__ && (t > 0 || e2 < 0) ? new N2(n4) : (t < 0 ? n4 = n4.takeRight(-t) : t && (n4 = n4.drop(t)), e2 !== i3 && (e2 = T3(e2), n4 = e2 < 0 ? n4.dropRight(-e2) : n4.take(e2 - t)), n4);
      }, N2.prototype.takeRightWhile = function(t) {
        return this.reverse().takeWhile(t).reverse();
      }, N2.prototype.toArray = function() {
        return this.take(Ut2);
      }, qt2(N2.prototype, function(t, e2) {
        var n4 = /^(?:filter|find|map|reject)|While$/.test(e2), r3 = /^(?:head|last)$/.test(e2), u3 = a5[r3 ? "take" + (e2 == "last" ? "Right" : "") : e2], o5 = r3 || /^find/.test(e2);
        u3 && (a5.prototype[e2] = function() {
          var c5 = this.__wrapped__, f4 = r3 ? [1] : arguments, l4 = c5 instanceof N2, v4 = f4[0], _3 = l4 || b3(c5), m2 = function(D3) {
            var $2 = u3.apply(a5, re([D3], f4));
            return r3 && C2 ? $2[0] : $2;
          };
          _3 && n4 && typeof v4 == "function" && v4.length != 1 && (l4 = _3 = false);
          var C2 = this.__chain__, x4 = !!this.__actions__.length, S3 = o5 && !C2, L2 = l4 && !x4;
          if (!o5 && _3) {
            c5 = L2 ? c5 : new N2(this);
            var O4 = t.apply(c5, f4);
            return O4.__actions__.push({ func: ir2, args: [m2], thisArg: i3 }), new Pt2(O4, C2);
          }
          return S3 && L2 ? t.apply(this, f4) : (O4 = this.thru(m2), S3 ? r3 ? O4.value()[0] : O4.value() : O4);
        });
      }), mt2(["pop", "push", "shift", "sort", "splice", "unshift"], function(t) {
        var e2 = bn2[t], n4 = /^(?:push|sort|unshift)$/.test(t) ? "tap" : "thru", r3 = /^(?:pop|shift)$/.test(t);
        a5.prototype[t] = function() {
          var u3 = arguments;
          if (r3 && !this.__chain__) {
            var o5 = this.value();
            return e2.apply(b3(o5) ? o5 : [], u3);
          }
          return this[n4](function(c5) {
            return e2.apply(b3(c5) ? c5 : [], u3);
          });
        };
      }), qt2(N2.prototype, function(t, e2) {
        var n4 = a5[e2];
        if (n4) {
          var r3 = n4.name + "";
          W.call(Ue, r3) || (Ue[r3] = []), Ue[r3].push({ name: e2, func: n4 });
        }
      }), Ue[Vn(i3, he2).name] = [{ name: "wrapper", func: i3 }], N2.prototype.clone = Qc, N2.prototype.reverse = Vc, N2.prototype.value = kc, a5.prototype.at = Ol, a5.prototype.chain = Rl, a5.prototype.commit = bl, a5.prototype.next = Tl, a5.prototype.plant = Hl, a5.prototype.reverse = Dl, a5.prototype.toJSON = a5.prototype.valueOf = a5.prototype.value = Nl, a5.prototype.first = a5.prototype.head, en2 && (a5.prototype[en2] = Ll), a5;
    }, De = Rc();
    pe ? ((pe.exports = De)._ = De, Lr2._ = De) : j4._ = De;
  }).call(_n2);
})(qi, qi.exports);
var Vg = Object.defineProperty;
var kg = Object.defineProperties;
var jg = Object.getOwnPropertyDescriptors;
var Ra = Object.getOwnPropertySymbols;
var tv = Object.prototype.hasOwnProperty;
var ev = Object.prototype.propertyIsEnumerable;
var ba = (P3, s2, i3) => s2 in P3 ? Vg(P3, s2, { enumerable: true, configurable: true, writable: true, value: i3 }) : P3[s2] = i3;
var lr2 = (P3, s2) => {
  for (var i3 in s2 || (s2 = {})) tv.call(s2, i3) && ba(P3, i3, s2[i3]);
  if (Ra) for (var i3 of Ra(s2)) ev.call(s2, i3) && ba(P3, i3, s2[i3]);
  return P3;
};
var nv = (P3, s2) => kg(P3, jg(s2));
function Lt3(P3, s2, i3) {
  var p4;
  const w5 = An(P3);
  return ((p4 = s2.rpcMap) == null ? void 0 : p4[w5.reference]) || `${Oa}?chainId=${w5.namespace}:${w5.reference}&projectId=${i3}`;
}
function Ae(P3) {
  return P3.includes(":") ? P3.split(":")[1] : P3;
}
function Ta(P3) {
  return P3.map((s2) => `${s2.split(":")[0]}:${s2.split(":")[1]}`);
}
function rv(P3, s2) {
  const i3 = Object.keys(s2.namespaces).filter((w5) => w5.includes(P3));
  if (!i3.length) return [];
  const p4 = [];
  return i3.forEach((w5) => {
    const I3 = s2.namespaces[w5].accounts;
    p4.push(...I3);
  }), p4;
}
function Fi(P3 = {}, s2 = {}) {
  const i3 = La(P3), p4 = La(s2);
  return qi.exports.merge(i3, p4);
}
function La(P3) {
  var s2, i3, p4, w5;
  const I3 = {};
  if (!Xr(P3)) return I3;
  for (const [y6, J] of Object.entries(P3)) {
    const Ht2 = on(y6) ? [y6] : J.chains, Ke = J.methods || [], Ie2 = J.events || [], Dt2 = J.rpcMap || {}, Bt2 = xo(y6);
    I3[Bt2] = nv(lr2(lr2({}, I3[Bt2]), J), { chains: me(Ht2, (s2 = I3[Bt2]) == null ? void 0 : s2.chains), methods: me(Ke, (i3 = I3[Bt2]) == null ? void 0 : i3.methods), events: me(Ie2, (p4 = I3[Bt2]) == null ? void 0 : p4.events), rpcMap: lr2(lr2({}, Dt2), (w5 = I3[Bt2]) == null ? void 0 : w5.rpcMap) });
  }
  return I3;
}
function iv(P3) {
  return P3.includes(":") ? P3.split(":")[2] : P3;
}
function Ha(P3) {
  const s2 = {};
  for (const [i3, p4] of Object.entries(P3)) {
    const w5 = p4.methods || [], I3 = p4.events || [], y6 = p4.accounts || [], J = on(i3) ? [i3] : p4.chains ? p4.chains : Ta(p4.accounts);
    s2[i3] = { chains: J, methods: w5, events: I3, accounts: y6 };
  }
  return s2;
}
function Wi(P3) {
  return typeof P3 == "number" ? P3 : P3.includes("0x") ? parseInt(P3, 16) : (P3 = P3.includes(":") ? P3.split(":")[1] : P3, isNaN(Number(P3)) ? P3 : Number(P3));
}
var Da = {};
var F2 = (P3) => Da[P3];
var Mi2 = (P3, s2) => {
  Da[P3] = s2;
};
var sv = class {
  constructor(s2) {
    this.name = "polkadot", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${s2}`);
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p4;
      const w5 = Ae(i3);
      s2[w5] = this.createHttpProvider(w5, (p4 = this.namespace.rpcMap) == null ? void 0 : p4[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p4 = this.createHttpProvider(s2, i3);
    p4 && (this.httpProviders[s2] = p4);
  }
  createHttpProvider(s2, i3) {
    const p4 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    if (!p4) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f3(p4, F2("disableProviderPing")));
  }
};
var uv = Object.defineProperty;
var av = Object.defineProperties;
var ov = Object.getOwnPropertyDescriptors;
var Na = Object.getOwnPropertySymbols;
var cv = Object.prototype.hasOwnProperty;
var fv = Object.prototype.propertyIsEnumerable;
var $a = (P3, s2, i3) => s2 in P3 ? uv(P3, s2, { enumerable: true, configurable: true, writable: true, value: i3 }) : P3[s2] = i3;
var Ua = (P3, s2) => {
  for (var i3 in s2 || (s2 = {})) cv.call(s2, i3) && $a(P3, i3, s2[i3]);
  if (Na) for (var i3 of Na(s2)) fv.call(s2, i3) && $a(P3, i3, s2[i3]);
  return P3;
};
var qa = (P3, s2) => av(P3, ov(s2));
var hv = class {
  constructor(s2) {
    this.name = "eip155", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(s2) {
    switch (s2.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(s2);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(s2);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(s2);
    }
    return this.namespace.methods.includes(s2.request.method) ? await this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(parseInt(s2), i3), this.chainId = parseInt(s2), this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${s2}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  createHttpProvider(s2, i3) {
    const p4 = i3 || Lt3(`${this.name}:${s2}`, this.namespace, this.client.core.projectId);
    if (!p4) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f3(p4, F2("disableProviderPing")));
  }
  setHttpProvider(s2, i3) {
    const p4 = this.createHttpProvider(s2, i3);
    p4 && (this.httpProviders[s2] = p4);
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p4;
      const w5 = parseInt(Ae(i3));
      s2[w5] = this.createHttpProvider(w5, (p4 = this.namespace.rpcMap) == null ? void 0 : p4[i3]);
    }), s2;
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const s2 = this.chainId, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  async handleSwitchChain(s2) {
    var i3, p4;
    let w5 = s2.request.params ? (i3 = s2.request.params[0]) == null ? void 0 : i3.chainId : "0x0";
    w5 = w5.startsWith("0x") ? w5 : `0x${w5}`;
    const I3 = parseInt(w5, 16);
    if (this.isChainApproved(I3)) this.setDefaultChain(`${I3}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: s2.topic, request: { method: s2.request.method, params: [{ chainId: w5 }] }, chainId: (p4 = this.namespace.chains) == null ? void 0 : p4[0] }), this.setDefaultChain(`${I3}`);
    else throw new Error(`Failed to switch to chain 'eip155:${I3}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(s2) {
    return this.namespace.chains.includes(`${this.name}:${s2}`);
  }
  async getCapabilities(s2) {
    var i3, p4, w5;
    const I3 = (p4 = (i3 = s2.request) == null ? void 0 : i3.params) == null ? void 0 : p4[0];
    if (!I3) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const y6 = this.client.session.get(s2.topic), J = ((w5 = y6 == null ? void 0 : y6.sessionProperties) == null ? void 0 : w5.capabilities) || {};
    if (J != null && J[I3]) return J == null ? void 0 : J[I3];
    const Ht2 = await this.client.request(s2);
    try {
      await this.client.session.update(s2.topic, { sessionProperties: qa(Ua({}, y6.sessionProperties || {}), { capabilities: qa(Ua({}, J || {}), { [I3]: Ht2 }) }) });
    } catch (Ke) {
      console.warn("Failed to update session with capabilities", Ke);
    }
    return Ht2;
  }
  async getCallStatus(s2) {
    var i3, p4;
    const w5 = this.client.session.get(s2.topic), I3 = (i3 = w5.sessionProperties) == null ? void 0 : i3.bundler_name;
    if (I3) {
      const J = this.getBundlerUrl(s2.chainId, I3);
      try {
        return await this.getUserOperationReceipt(J, s2);
      } catch (Ht2) {
        console.warn("Failed to fetch call status from bundler", Ht2, J);
      }
    }
    const y6 = (p4 = w5.sessionProperties) == null ? void 0 : p4.bundler_url;
    if (y6) try {
      return await this.getUserOperationReceipt(y6, s2);
    } catch (J) {
      console.warn("Failed to fetch call status from custom bundler", J, y6);
    }
    if (this.namespace.methods.includes(s2.request.method)) return await this.client.request(s2);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(s2, i3) {
    var p4;
    const w5 = new URL(s2), I3 = await fetch(w5, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(formatJsonRpcRequest("eth_getUserOperationReceipt", [(p4 = i3.request.params) == null ? void 0 : p4[0]])) });
    if (!I3.ok) throw new Error(`Failed to fetch user operation receipt - ${I3.status}`);
    return await I3.json();
  }
  getBundlerUrl(s2, i3) {
    return `${Qg}?projectId=${this.client.core.projectId}&chainId=${s2}&bundler=${i3}`;
  }
};
var lv = class {
  constructor(s2) {
    this.name = "solana", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${s2}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p4;
      const w5 = Ae(i3);
      s2[w5] = this.createHttpProvider(w5, (p4 = this.namespace.rpcMap) == null ? void 0 : p4[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p4 = this.createHttpProvider(s2, i3);
    p4 && (this.httpProviders[s2] = p4);
  }
  createHttpProvider(s2, i3) {
    const p4 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    if (!p4) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f3(p4, F2("disableProviderPing")));
  }
};
var pv = class {
  constructor(s2) {
    this.name = "cosmos", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p4;
      const w5 = Ae(i3);
      s2[w5] = this.createHttpProvider(w5, (p4 = this.namespace.rpcMap) == null ? void 0 : p4[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p4 = this.createHttpProvider(s2, i3);
    p4 && (this.httpProviders[s2] = p4);
  }
  createHttpProvider(s2, i3) {
    const p4 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    if (!p4) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f3(p4, F2("disableProviderPing")));
  }
};
var dv = class {
  constructor(s2) {
    this.name = "algorand", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    if (!this.httpProviders[s2]) {
      const p4 = i3 || Lt3(`${this.name}:${s2}`, this.namespace, this.client.core.projectId);
      if (!p4) throw new Error(`No RPC url provided for chainId: ${s2}`);
      this.setHttpProvider(s2, p4);
    }
    this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p4;
      s2[i3] = this.createHttpProvider(i3, (p4 = this.namespace.rpcMap) == null ? void 0 : p4[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p4 = this.createHttpProvider(s2, i3);
    p4 && (this.httpProviders[s2] = p4);
  }
  createHttpProvider(s2, i3) {
    const p4 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    return typeof p4 > "u" ? void 0 : new o3(new f3(p4, F2("disableProviderPing")));
  }
};
var gv = class {
  constructor(s2) {
    this.name = "cip34", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      const p4 = this.getCardanoRPCUrl(i3), w5 = Ae(i3);
      s2[w5] = this.createHttpProvider(w5, p4);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  getCardanoRPCUrl(s2) {
    const i3 = this.namespace.rpcMap;
    if (i3) return i3[s2];
  }
  setHttpProvider(s2, i3) {
    const p4 = this.createHttpProvider(s2, i3);
    p4 && (this.httpProviders[s2] = p4);
  }
  createHttpProvider(s2, i3) {
    const p4 = i3 || this.getCardanoRPCUrl(s2);
    if (!p4) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f3(p4, F2("disableProviderPing")));
  }
};
var vv = class {
  constructor(s2) {
    this.name = "elrond", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${s2}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p4;
      const w5 = Ae(i3);
      s2[w5] = this.createHttpProvider(w5, (p4 = this.namespace.rpcMap) == null ? void 0 : p4[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p4 = this.createHttpProvider(s2, i3);
    p4 && (this.httpProviders[s2] = p4);
  }
  createHttpProvider(s2, i3) {
    const p4 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    if (!p4) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f3(p4, F2("disableProviderPing")));
  }
};
var _v = class {
  constructor(s2) {
    this.name = "multiversx", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${s2}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p4;
      const w5 = Ae(i3);
      s2[w5] = this.createHttpProvider(w5, (p4 = this.namespace.rpcMap) == null ? void 0 : p4[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p4 = this.createHttpProvider(s2, i3);
    p4 && (this.httpProviders[s2] = p4);
  }
  createHttpProvider(s2, i3) {
    const p4 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    if (!p4) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f3(p4, F2("disableProviderPing")));
  }
};
var mv = class {
  constructor(s2) {
    this.name = "near", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    if (this.chainId = s2, !this.httpProviders[s2]) {
      const p4 = i3 || Lt3(`${this.name}:${s2}`, this.namespace);
      if (!p4) throw new Error(`No RPC url provided for chainId: ${s2}`);
      this.setHttpProvider(s2, p4);
    }
    this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p4;
      s2[i3] = this.createHttpProvider(i3, (p4 = this.namespace.rpcMap) == null ? void 0 : p4[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p4 = this.createHttpProvider(s2, i3);
    p4 && (this.httpProviders[s2] = p4);
  }
  createHttpProvider(s2, i3) {
    const p4 = i3 || Lt3(s2, this.namespace);
    return typeof p4 > "u" ? void 0 : new o3(new f3(p4, F2("disableProviderPing")));
  }
};
var wv = class {
  constructor(s2) {
    this.name = ze, this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(s2.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(s2.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(s2.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(s2.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider(s2.chainId).request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${s2}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var s2, i3;
    const p4 = {};
    return (i3 = (s2 = this.namespace) == null ? void 0 : s2.accounts) == null || i3.forEach((w5) => {
      const I3 = An(w5);
      p4[`${I3.namespace}:${I3.reference}`] = this.createHttpProvider(w5);
    }), p4;
  }
  getHttpProvider(s2) {
    const i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p4 = this.createHttpProvider(s2, i3);
    p4 && (this.httpProviders[s2] = p4);
  }
  createHttpProvider(s2, i3) {
    const p4 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    if (!p4) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f3(p4, F2("disableProviderPing")));
  }
};
var Pv = Object.defineProperty;
var Cv = Object.defineProperties;
var Av = Object.getOwnPropertyDescriptors;
var Fa = Object.getOwnPropertySymbols;
var Iv = Object.prototype.hasOwnProperty;
var xv = Object.prototype.propertyIsEnumerable;
var Wa = (P3, s2, i3) => s2 in P3 ? Pv(P3, s2, { enumerable: true, configurable: true, writable: true, value: i3 }) : P3[s2] = i3;
var pr3 = (P3, s2) => {
  for (var i3 in s2 || (s2 = {})) Iv.call(s2, i3) && Wa(P3, i3, s2[i3]);
  if (Fa) for (var i3 of Fa(s2)) xv.call(s2, i3) && Wa(P3, i3, s2[i3]);
  return P3;
};
var Bi = (P3, s2) => Cv(P3, Av(s2));
var dr2 = class _dr {
  constructor(s2) {
    this.events = new import_events10.default(), this.rpcProviders = {}, this.shouldAbortPairingAttempt = false, this.maxPairingAttempts = 10, this.disableProviderPing = false, this.providerOpts = s2, this.logger = typeof (s2 == null ? void 0 : s2.logger) < "u" && typeof (s2 == null ? void 0 : s2.logger) != "string" ? s2.logger : (0, import_pino.default)(k({ level: (s2 == null ? void 0 : s2.logger) || ya })), this.disableProviderPing = (s2 == null ? void 0 : s2.disableProviderPing) || false;
  }
  static async init(s2) {
    const i3 = new _dr(s2);
    return await i3.initialize(), i3;
  }
  async request(s2, i3, p4) {
    const [w5, I3] = this.validateChain(i3);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(w5).request({ request: pr3({}, s2), chainId: `${w5}:${I3}`, topic: this.session.topic, expiry: p4 });
  }
  sendAsync(s2, i3, p4, w5) {
    const I3 = (/* @__PURE__ */ new Date()).getTime();
    this.request(s2, p4, w5).then((y6) => i3(null, formatJsonRpcResult(I3, y6))).catch((y6) => i3(y6, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var s2;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (s2 = this.session) == null ? void 0 : s2.topic, reason: er("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(s2) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(s2), await this.cleanupPendingPairings(), !s2.skipPairing) return await this.pair(s2.pairingTopic);
  }
  async authenticate(s2, i3) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(s2), await this.cleanupPendingPairings();
    const { uri: p4, response: w5 } = await this.client.authenticate(s2, i3);
    p4 && (this.uri = p4, this.events.emit("display_uri", p4));
    const I3 = await w5();
    if (this.session = I3.session, this.session) {
      const y6 = Ha(this.session.namespaces);
      this.namespaces = Fi(this.namespaces, y6), this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return I3;
  }
  on(s2, i3) {
    this.events.on(s2, i3);
  }
  once(s2, i3) {
    this.events.once(s2, i3);
  }
  removeListener(s2, i3) {
    this.events.removeListener(s2, i3);
  }
  off(s2, i3) {
    this.events.off(s2, i3);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(s2) {
    this.shouldAbortPairingAttempt = false;
    let i3 = 0;
    do {
      if (this.shouldAbortPairingAttempt) throw new Error("Pairing aborted");
      if (i3 >= this.maxPairingAttempts) throw new Error("Max auto pairing attempts reached");
      const { uri: p4, approval: w5 } = await this.client.connect({ pairingTopic: s2, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties });
      p4 && (this.uri = p4, this.events.emit("display_uri", p4)), await w5().then((I3) => {
        this.session = I3;
        const y6 = Ha(I3.namespaces);
        this.namespaces = Fi(this.namespaces, y6), this.persist("namespaces", this.namespaces);
      }).catch((I3) => {
        if (I3.message !== it2) throw I3;
        i3++;
      });
    } while (!this.session);
    return this.onConnect(), this.session;
  }
  setDefaultChain(s2, i3) {
    try {
      if (!this.session) return;
      const [p4, w5] = this.validateChain(s2), I3 = this.getProvider(p4);
      I3.name === ze ? I3.setDefaultChain(`${p4}:${w5}`, i3) : I3.setDefaultChain(w5, i3);
    } catch (p4) {
      if (!/Please call connect/.test(p4.message)) throw p4;
    }
  }
  async cleanupPendingPairings(s2 = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const i3 = this.client.pairing.getAll();
    if (Nr(i3)) {
      for (const p4 of i3) s2.deletePairings ? this.client.core.expirer.set(p4.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(p4.topic);
      this.logger.info(`Inactive pairings cleared: ${i3.length}`);
    }
  }
  abortPairingAttempt() {
    this.shouldAbortPairingAttempt = true;
  }
  async checkStorage() {
    if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
      const s2 = this.client.session.keys.length - 1;
      this.session = this.client.session.get(this.client.session.keys[s2]), this.createProviders();
    }
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    this.client = this.providerOpts.client || await _e2.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || ya, relayUrl: this.providerOpts.relayUrl || Yg, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const s2 = [...new Set(Object.keys(this.session.namespaces).map((i3) => xo(i3)))];
    Mi2("client", this.client), Mi2("events", this.events), Mi2("disableProviderPing", this.disableProviderPing), s2.forEach((i3) => {
      if (!this.session) return;
      const p4 = rv(i3, this.session), w5 = Ta(p4), I3 = Fi(this.namespaces, this.optionalNamespaces), y6 = Bi(pr3({}, I3[i3]), { accounts: p4, chains: w5 });
      switch (i3) {
        case "eip155":
          this.rpcProviders[i3] = new hv({ namespace: y6 });
          break;
        case "algorand":
          this.rpcProviders[i3] = new dv({ namespace: y6 });
          break;
        case "solana":
          this.rpcProviders[i3] = new lv({ namespace: y6 });
          break;
        case "cosmos":
          this.rpcProviders[i3] = new pv({ namespace: y6 });
          break;
        case "polkadot":
          this.rpcProviders[i3] = new sv({ namespace: y6 });
          break;
        case "cip34":
          this.rpcProviders[i3] = new gv({ namespace: y6 });
          break;
        case "elrond":
          this.rpcProviders[i3] = new vv({ namespace: y6 });
          break;
        case "multiversx":
          this.rpcProviders[i3] = new _v({ namespace: y6 });
          break;
        case "near":
          this.rpcProviders[i3] = new mv({ namespace: y6 });
          break;
        default:
          this.rpcProviders[ze] ? this.rpcProviders[ze].updateNamespace(y6) : this.rpcProviders[ze] = new wv({ namespace: y6 });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (s2) => {
      this.events.emit("session_ping", s2);
    }), this.client.on("session_event", (s2) => {
      const { params: i3 } = s2, { event: p4 } = i3;
      if (p4.name === "accountsChanged") {
        const w5 = p4.data;
        w5 && Nr(w5) && this.events.emit("accountsChanged", w5.map(iv));
      } else if (p4.name === "chainChanged") {
        const w5 = i3.chainId, I3 = i3.event.data, y6 = xo(w5), J = Wi(w5) !== Wi(I3) ? `${y6}:${Wi(I3)}` : w5;
        this.onChainChanged(J);
      } else this.events.emit(p4.name, p4.data);
      this.events.emit("session_event", s2);
    }), this.client.on("session_update", ({ topic: s2, params: i3 }) => {
      var p4;
      const { namespaces: w5 } = i3, I3 = (p4 = this.client) == null ? void 0 : p4.session.get(s2);
      this.session = Bi(pr3({}, I3), { namespaces: w5 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: s2, params: i3 });
    }), this.client.on("session_delete", async (s2) => {
      await this.cleanup(), this.events.emit("session_delete", s2), this.events.emit("disconnect", Bi(pr3({}, er("USER_DISCONNECTED")), { data: s2.topic }));
    }), this.on(Tt2.DEFAULT_CHAIN_CHANGED, (s2) => {
      this.onChainChanged(s2, true);
    });
  }
  getProvider(s2) {
    return this.rpcProviders[s2] || this.rpcProviders[ze];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((s2) => {
      var i3;
      this.getProvider(s2).updateNamespace((i3 = this.session) == null ? void 0 : i3.namespaces[s2]);
    });
  }
  setNamespaces(s2) {
    const { namespaces: i3, optionalNamespaces: p4, sessionProperties: w5 } = s2;
    i3 && Object.keys(i3).length && (this.namespaces = i3), p4 && Object.keys(p4).length && (this.optionalNamespaces = p4), this.sessionProperties = w5, this.persist("namespaces", i3), this.persist("optionalNamespaces", p4);
  }
  validateChain(s2) {
    const [i3, p4] = (s2 == null ? void 0 : s2.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [i3, p4];
    if (i3 && !Object.keys(this.namespaces || {}).map((y6) => xo(y6)).includes(i3)) throw new Error(`Namespace '${i3}' is not configured. Please call connect() first with namespace config.`);
    if (i3 && p4) return [i3, p4];
    const w5 = xo(Object.keys(this.namespaces)[0]), I3 = this.rpcProviders[w5].getDefaultChain();
    return [w5, I3];
  }
  async requestAccounts() {
    const [s2] = this.validateChain();
    return await this.getProvider(s2).requestAccounts();
  }
  onChainChanged(s2, i3 = false) {
    if (!this.namespaces) return;
    const [p4, w5] = this.validateChain(s2);
    w5 && (i3 || this.getProvider(p4).setDefaultChain(w5), this.namespaces[p4] ? this.namespaces[p4].defaultChain = w5 : this.namespaces[`${p4}:${w5}`] ? this.namespaces[`${p4}:${w5}`].defaultChain = w5 : this.namespaces[`${p4}:${w5}`] = { defaultChain: w5 }, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", w5));
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({ deletePairings: true });
  }
  persist(s2, i3) {
    this.client.core.storage.setItem(`${Sa}/${s2}`, i3);
  }
  async getFromStore(s2) {
    return await this.client.core.storage.getItem(`${Sa}/${s2}`);
  }
};

// node_modules/@reown/appkit/dist/esm/src/auth-provider/W3MFrameProviderSingleton.js
var W3mFrameProviderSingleton = class _W3mFrameProviderSingleton {
  // eslint-disable-next-line @typescript-eslint/no-empty-function -- This is a singleton
  constructor() {
  }
  static getInstance({ projectId, chainId, onTimeout }) {
    if (!_W3mFrameProviderSingleton.instance) {
      _W3mFrameProviderSingleton.instance = new W3mFrameProvider({ projectId, chainId, onTimeout });
    }
    return _W3mFrameProviderSingleton.instance;
  }
};

// node_modules/@reown/appkit/dist/esm/src/client.js
var accountState = {
  currentTab: 0,
  tokenBalance: [],
  smartAccountDeployed: false,
  addressLabels: /* @__PURE__ */ new Map(),
  allAccounts: []
};
var networkState = {
  supportsAllNetworks: true,
  smartAccountEnabledNetworks: []
};
var OPTIONAL_METHODS = [
  "eth_accounts",
  "eth_requestAccounts",
  "eth_sendRawTransaction",
  "eth_sign",
  "eth_signTransaction",
  "eth_signTypedData",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "eth_sendTransaction",
  "personal_sign",
  "wallet_switchEthereumChain",
  "wallet_addEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode",
  // EIP-5792
  "wallet_getCallsStatus",
  "wallet_sendCalls",
  "wallet_getCapabilities",
  // EIP-7715
  "wallet_grantPermissions",
  "wallet_revokePermissions"
];
var isInitialized = false;
var AppKit = class {
  constructor(options) {
    this.chainNamespaces = [];
    this.initPromise = void 0;
    this.setStatus = (status, chain) => {
      AccountController.setStatus(status, chain);
    };
    this.getIsConnectedState = () => Boolean(ChainController.state.activeCaipAddress);
    this.setAllAccounts = (addresses, chain) => {
      AccountController.setAllAccounts(addresses, chain);
      OptionsController.setHasMultipleAddresses((addresses == null ? void 0 : addresses.length) > 1);
    };
    this.addAddressLabel = (address, label, chain) => {
      AccountController.addAddressLabel(address, label, chain);
    };
    this.removeAddressLabel = (address, chain) => {
      AccountController.removeAddressLabel(address, chain);
    };
    this.getCaipAddress = (chainNamespace) => {
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return ChainController.state.activeCaipAddress;
      }
      return ChainController.getAccountProp("caipAddress", chainNamespace);
    };
    this.getAddressByChainNamespace = (chainNamespace) => ChainController.getAccountProp("address", chainNamespace);
    this.getAddress = (chainNamespace) => {
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return AccountController.state.address;
      }
      return ChainController.getAccountProp("address", chainNamespace);
    };
    this.getProvider = () => AccountController.state.provider;
    this.getPreferredAccountType = () => AccountController.state.preferredAccountType;
    this.setCaipAddress = (caipAddress, chain) => {
      AccountController.setCaipAddress(caipAddress, chain);
    };
    this.setProvider = (provider, chain) => {
      AccountController.setProvider(provider, chain);
    };
    this.setBalance = (balance, balanceSymbol, chain) => {
      AccountController.setBalance(balance, balanceSymbol, chain);
    };
    this.setProfileName = (profileName, chain) => {
      AccountController.setProfileName(profileName, chain);
    };
    this.setProfileImage = (profileImage, chain) => {
      AccountController.setProfileImage(profileImage, chain);
    };
    this.resetAccount = (chain) => {
      AccountController.resetAccount(chain);
    };
    this.setCaipNetwork = (caipNetwork) => {
      ChainController.setActiveCaipNetwork(caipNetwork);
    };
    this.getCaipNetwork = (chainNamespace) => {
      var _a;
      if (chainNamespace) {
        return (_a = ChainController.getRequestedCaipNetworks(chainNamespace).filter((c5) => c5.chainNamespace === chainNamespace)) == null ? void 0 : _a[0];
      }
      return ChainController.state.activeCaipNetwork;
    };
    this.getCaipNetworkId = () => {
      const network = this.getCaipNetwork();
      if (network) {
        return network.id;
      }
      return void 0;
    };
    this.getCaipNetworks = (namespace) => ChainController.getRequestedCaipNetworks(namespace);
    this.getActiveChainNamespace = () => ChainController.state.activeChain;
    this.setRequestedCaipNetworks = (requestedCaipNetworks, chain) => {
      ChainController.setRequestedCaipNetworks(requestedCaipNetworks, chain);
    };
    this.getApprovedCaipNetworkIds = () => ChainController.getAllApprovedCaipNetworkIds();
    this.setApprovedCaipNetworksData = (namespace) => ChainController.setApprovedCaipNetworksData(namespace);
    this.resetNetwork = (namespace) => {
      ChainController.resetNetwork(namespace);
    };
    this.setConnectors = (connectors) => {
      const allConnectors = [...ConnectorController.getConnectors(), ...connectors];
      ConnectorController.setConnectors(allConnectors);
    };
    this.addConnector = (connector) => {
      ConnectorController.addConnector(connector);
    };
    this.getConnectors = () => ConnectorController.getConnectors();
    this.resetWcConnection = () => {
      ConnectionController.resetWcConnection();
    };
    this.fetchIdentity = (request) => BlockchainApiController.fetchIdentity(request);
    this.setAddressExplorerUrl = (addressExplorerUrl, chain) => {
      AccountController.setAddressExplorerUrl(addressExplorerUrl, chain);
    };
    this.setSmartAccountDeployed = (isDeployed, chain) => {
      AccountController.setSmartAccountDeployed(isDeployed, chain);
    };
    this.setConnectedWalletInfo = (connectedWalletInfo, chain) => {
      AccountController.setConnectedWalletInfo(connectedWalletInfo, chain);
    };
    this.setSmartAccountEnabledNetworks = (smartAccountEnabledNetworks, chain) => {
      ChainController.setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain);
    };
    this.setPreferredAccountType = (preferredAccountType, chain) => {
      AccountController.setPreferredAccountType(preferredAccountType, chain);
    };
    this.getReownName = (address) => EnsController.getNamesForAddress(address);
    this.setEIP6963Enabled = (enabled) => {
      OptionsController.setEIP6963Enabled(enabled);
    };
    this.setClientId = (clientId) => {
      BlockchainApiController.setClientId(clientId);
    };
    this.getConnectorImage = (connector) => AssetUtil.getConnectorImage(connector);
    this.handleUnsafeRPCRequest = () => {
      if (this.isOpen()) {
        if (this.isTransactionStackEmpty()) {
          return;
        }
        this.redirect("ApproveTransaction");
      } else {
        this.open({ view: "ApproveTransaction" });
      }
    };
    this.options = options;
    this.initialize(options);
  }
  static getInstance() {
    return this.instance;
  }
  async initialize(options) {
    this.caipNetworks = this.extendCaipNetworks(options);
    this.defaultCaipNetwork = this.extendDefaultCaipNetwork(options);
    await this.initControllers(options);
    this.createAuthProvider();
    await this.createUniversalProvider();
    this.createClients();
    ChainController.initialize(options.adapters ?? []);
    this.chainAdapters = await this.createAdapters(options.adapters);
    await this.initChainAdapters();
    this.syncRequestedNetworks();
    await this.initOrContinue();
    await this.syncExistingConnection();
    this.version = options.sdkVersion;
  }
  // -- Public -------------------------------------------------------------------
  async open(options) {
    await this.initOrContinue();
    ModalController.open(options);
  }
  async close() {
    await this.initOrContinue();
    ModalController.close();
  }
  setLoading(loading) {
    ModalController.setLoading(loading);
  }
  // -- Adapter Methods ----------------------------------------------------------
  getError() {
    return "";
  }
  getChainId() {
    var _a;
    return (_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.id;
  }
  switchNetwork(appKitNetwork) {
    var _a;
    const network = (_a = this.caipNetworks) == null ? void 0 : _a.find((n4) => n4.id === appKitNetwork.id);
    if (!network) {
      AlertController.open(ErrorUtil.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, "error");
      return;
    }
    ChainController.switchActiveNetwork(network);
  }
  getWalletProvider() {
    return ChainController.state.activeChain ? ProviderUtil.state.providers[ChainController.state.activeChain] : null;
  }
  getWalletProviderType() {
    return ChainController.state.activeChain ? ProviderUtil.state.providerIds[ChainController.state.activeChain] : null;
  }
  subscribeProvider() {
    return null;
  }
  getThemeMode() {
    return ThemeController.state.themeMode;
  }
  getThemeVariables() {
    return ThemeController.state.themeVariables;
  }
  setThemeMode(themeMode) {
    ThemeController.setThemeMode(themeMode);
    setColorTheme(ThemeController.state.themeMode);
  }
  setThemeVariables(themeVariables) {
    ThemeController.setThemeVariables(themeVariables);
    setThemeVariables(ThemeController.state.themeVariables);
  }
  subscribeTheme(callback) {
    return ThemeController.subscribe(callback);
  }
  getWalletInfo() {
    return AccountController.state.connectedWalletInfo;
  }
  subscribeAccount(callback) {
    function updateVal() {
      callback({
        caipAddress: ChainController.state.activeCaipAddress,
        address: CoreHelperUtil.getPlainAddress(ChainController.state.activeCaipAddress),
        isConnected: Boolean(ChainController.state.activeCaipAddress),
        status: AccountController.state.status
      });
    }
    ChainController.subscribe(updateVal);
    AccountController.subscribe(updateVal);
  }
  subscribeNetwork(callback) {
    return ChainController.subscribe(({ activeCaipNetwork }) => {
      callback({
        caipNetwork: activeCaipNetwork,
        chainId: activeCaipNetwork == null ? void 0 : activeCaipNetwork.id,
        caipNetworkId: activeCaipNetwork == null ? void 0 : activeCaipNetwork.caipNetworkId
      });
    });
  }
  subscribeWalletInfo(callback) {
    return AccountController.subscribeKey("connectedWalletInfo", callback);
  }
  subscribeShouldUpdateToAddress(callback) {
    AccountController.subscribeKey("shouldUpdateToAddress", callback);
  }
  subscribeCaipNetworkChange(callback) {
    ChainController.subscribeKey("activeCaipNetwork", callback);
  }
  getState() {
    return PublicStateController.state;
  }
  subscribeState(callback) {
    return PublicStateController.subscribe(callback);
  }
  showErrorMessage(message) {
    SnackController.showError(message);
  }
  showSuccessMessage(message) {
    SnackController.showSuccess(message);
  }
  getEvent() {
    return { ...EventsController.state };
  }
  subscribeEvents(callback) {
    return EventsController.subscribe(callback);
  }
  replace(route) {
    RouterController.replace(route);
  }
  redirect(route) {
    RouterController.push(route);
  }
  popTransactionStack(cancel) {
    RouterController.popTransactionStack(cancel);
  }
  isOpen() {
    return ModalController.state.open;
  }
  isTransactionStackEmpty() {
    return RouterController.state.transactionStack.length === 0;
  }
  isTransactionShouldReplaceView() {
    var _a;
    return (_a = RouterController.state.transactionStack[RouterController.state.transactionStack.length - 1]) == null ? void 0 : _a.replace;
  }
  // -- Private ------------------------------------------------------------------
  async initControllers(options) {
    var _a;
    OptionsController.setDebug(options.debug);
    OptionsController.setProjectId(options.projectId);
    OptionsController.setSdkVersion(options.sdkVersion);
    if (!options.projectId) {
      AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
      return;
    }
    this.adapters = options.adapters;
    const defaultMetaData = this.getDefaultMetaData();
    if (!options.metadata && defaultMetaData) {
      options.metadata = defaultMetaData;
    }
    this.setDefaultNetwork();
    OptionsController.setAllWallets(options.allWallets);
    OptionsController.setIncludeWalletIds(options.includeWalletIds);
    OptionsController.setExcludeWalletIds(options.excludeWalletIds);
    if (options.excludeWalletIds) {
      ApiController.searchWalletByIds({ ids: options.excludeWalletIds });
    }
    OptionsController.setFeaturedWalletIds(options.featuredWalletIds);
    OptionsController.setTokens(options.tokens);
    OptionsController.setTermsConditionsUrl(options.termsConditionsUrl);
    OptionsController.setPrivacyPolicyUrl(options.privacyPolicyUrl);
    OptionsController.setCustomWallets(options.customWallets);
    OptionsController.setFeatures(options.features);
    OptionsController.setEnableWalletConnect(options.enableWalletConnect !== false);
    OptionsController.setEnableWallets(options.enableWallets !== false);
    if (options.metadata) {
      OptionsController.setMetadata(options.metadata);
    }
    if (options.themeMode) {
      ThemeController.setThemeMode(options.themeMode);
    }
    if (options.themeVariables) {
      ThemeController.setThemeVariables(options.themeVariables);
    }
    if (options.disableAppend) {
      OptionsController.setDisableAppend(Boolean(options.disableAppend));
    }
    if (options.siwx) {
      OptionsController.setSIWX(options.siwx);
    }
    const evmAdapter = (_a = options.adapters) == null ? void 0 : _a.find((adapter) => adapter.namespace === ConstantsUtil.CHAIN.EVM);
    if (evmAdapter) {
      if (options.siweConfig) {
        const { SIWEController } = await import("./exports-JUL67YGQ.js");
        SIWEController.setSIWEClient(options.siweConfig);
      }
    }
  }
  getDefaultMetaData() {
    var _a, _b, _c;
    if (typeof window !== "undefined" && typeof document !== "undefined") {
      return {
        name: ((_a = document.getElementsByTagName("title")[0]) == null ? void 0 : _a.textContent) || "",
        description: ((_b = document.querySelector('meta[property="og:description"]')) == null ? void 0 : _b.content) || "",
        url: window.location.origin,
        icons: [((_c = document.querySelector('link[rel~="icon"]')) == null ? void 0 : _c.href) || ""]
      };
    }
    return null;
  }
  extendCaipNetworks(options) {
    const extendedNetworks = CaipNetworksUtil.extendCaipNetworks(options.networks, {
      customNetworkImageUrls: options.chainImages,
      projectId: options.projectId
    });
    return extendedNetworks;
  }
  extendDefaultCaipNetwork(options) {
    const defaultNetwork = options.networks.find((n4) => {
      var _a;
      return n4.id === ((_a = options.defaultNetwork) == null ? void 0 : _a.id);
    });
    const extendedNetwork = defaultNetwork ? CaipNetworksUtil.extendCaipNetwork(defaultNetwork, {
      customNetworkImageUrls: options.chainImages,
      projectId: options.projectId
    }) : void 0;
    return extendedNetwork;
  }
  createClients() {
    this.connectionControllerClient = {
      connectWalletConnect: async (onUri) => {
        var _a, _b, _c, _d, _e3, _f, _g, _h2, _i2, _j, _k, _l, _m, _n3, _o, _p, _q, _r2, _s3;
        const adapter = this.getAdapter(ChainController.state.activeChain);
        (_a = this.universalProvider) == null ? void 0 : _a.on("display_uri", (uri) => {
          onUri(uri);
        });
        if (this.options.siweConfig) {
          const siweParams = await ((_c = (_b = this.options.siweConfig) == null ? void 0 : _b.getMessageParams) == null ? void 0 : _c.call(_b));
          const isSiweEnabled = (_e3 = (_d = this.options.siweConfig) == null ? void 0 : _d.options) == null ? void 0 : _e3.enabled;
          const isProviderSupported = typeof ((_f = this.universalProvider) == null ? void 0 : _f.authenticate) === "function";
          const isSiweParamsValid = siweParams && Object.keys(siweParams || {}).length > 0;
          const clientId = await ((_j = (_i2 = (_h2 = (_g = this.universalProvider) == null ? void 0 : _g.client) == null ? void 0 : _h2.core) == null ? void 0 : _i2.crypto) == null ? void 0 : _j.getClientId());
          if (clientId) {
            this.setClientId(clientId);
            if (this.options.siweConfig && isSiweEnabled && siweParams && isProviderSupported && isSiweParamsValid && ChainController.state.activeChain === ConstantsUtil.CHAIN.EVM) {
              const { SIWEController, getDidChainId, getDidAddress } = await import("./exports-JUL67YGQ.js");
              const chains = (_k = this.caipNetworks) == null ? void 0 : _k.filter((network) => network.chainNamespace === ConstantsUtil.CHAIN.EVM).map((chain) => chain.caipNetworkId);
              siweParams.chains = (_l = this.caipNetworks) == null ? void 0 : _l.filter((network) => network.chainNamespace === ConstantsUtil.CHAIN.EVM).map((chain) => chain.id);
              const result = await ((_o = this.universalProvider) == null ? void 0 : _o.authenticate({
                nonce: await ((_n3 = (_m = this.options.siweConfig) == null ? void 0 : _m.getNonce) == null ? void 0 : _n3.call(_m)),
                methods: [...OPTIONAL_METHODS],
                ...siweParams,
                chains
              }));
              const signedCacao = (_p = result == null ? void 0 : result.auths) == null ? void 0 : _p[0];
              if (signedCacao) {
                const { p: p4, s: s2 } = signedCacao;
                const cacaoChainId = getDidChainId(p4.iss);
                const address = getDidAddress(p4.iss);
                if (address && cacaoChainId) {
                  SIWEController.setSession({
                    address,
                    chainId: parseInt(cacaoChainId, 10)
                  });
                }
                try {
                  const message = (_q = this.universalProvider) == null ? void 0 : _q.client.formatAuthMessage({
                    request: p4,
                    iss: p4.iss
                  });
                  await SIWEController.verifyMessage({
                    message,
                    signature: s2.s,
                    cacao: signedCacao
                  });
                } catch (error) {
                  console.error("Error verifying message", error);
                  await ((_r2 = this.universalProvider) == null ? void 0 : _r2.disconnect().catch(console.error));
                  await SIWEController.signOut().catch(console.error);
                  throw error;
                }
              }
            }
          }
        } else {
          await (adapter == null ? void 0 : adapter.connectWalletConnect(onUri, (_s3 = this.getCaipNetwork()) == null ? void 0 : _s3.id));
        }
        await this.syncWalletConnectAccount();
      },
      connectExternal: async ({ id, info, type, provider, chain, caipNetwork }) => {
        var _a, _b, _c, _d, _e3, _f, _g, _h2, _i2;
        if (chain && chain !== ChainController.state.activeChain && !caipNetwork) {
          const toConnectNetwork = (_a = this.caipNetworks) == null ? void 0 : _a.find((network) => network.chainNamespace === chain);
          if (toConnectNetwork) {
            this.setCaipNetwork(toConnectNetwork);
          }
        }
        const adapter = chain ? this.getAdapter(chain) : this.getAdapter(ChainController.state.activeChain);
        const res = await (adapter == null ? void 0 : adapter.connect({
          id,
          info,
          type,
          provider,
          chainId: (caipNetwork == null ? void 0 : caipNetwork.id) || ((_b = this.getCaipNetwork()) == null ? void 0 : _b.id),
          rpcUrl: ((_e3 = (_d = (_c = caipNetwork == null ? void 0 : caipNetwork.rpcUrls) == null ? void 0 : _c.default) == null ? void 0 : _d.http) == null ? void 0 : _e3[0]) || ((_i2 = (_h2 = (_g = (_f = this.getCaipNetwork()) == null ? void 0 : _f.rpcUrls) == null ? void 0 : _g.default) == null ? void 0 : _h2.http) == null ? void 0 : _i2[0])
        }));
        if (res) {
          this.syncProvider({
            ...res,
            chainNamespace: chain || ChainController.state.activeChain
          });
          await this.syncAccount({
            ...res,
            chainNamespace: chain || ChainController.state.activeChain
          });
        }
      },
      reconnectExternal: async ({ id, info, type, provider }) => {
        var _a;
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (adapter == null ? void 0 : adapter.reconnect) {
          await (adapter == null ? void 0 : adapter.reconnect({ id, info, type, provider, chainId: (_a = this.getCaipNetwork()) == null ? void 0 : _a.id }));
        }
      },
      disconnect: async () => {
        var _a, _b;
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
        if ((_b = (_a = this.options.siweConfig) == null ? void 0 : _a.options) == null ? void 0 : _b.signOutOnDisconnect) {
          const { SIWEController } = await import("./exports-JUL67YGQ.js");
          await SIWEController.signOut();
        }
        const providerType = ProviderUtil.state.providerIds[ChainController.state.activeChain];
        await (adapter == null ? void 0 : adapter.disconnect({ provider, providerType }));
        this.setStatus("disconnected", ChainController.state.activeChain);
        localStorage.removeItem(SafeLocalStorageKeys.CONNECTED_CONNECTOR);
        localStorage.removeItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID);
        ChainController.state.chains.forEach((chain) => {
          this.resetAccount(chain.namespace);
        });
      },
      checkInstalled: (ids) => {
        if (!ids) {
          return Boolean(window.ethereum);
        }
        return ids.some((id) => {
          var _a;
          return Boolean((_a = window.ethereum) == null ? void 0 : _a[String(id)]);
        });
      },
      signMessage: async (message) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const result = await (adapter == null ? void 0 : adapter.signMessage({
          message,
          address: AccountController.state.address,
          provider: ProviderUtil.getProvider(ChainController.state.activeChain)
        }));
        return (result == null ? void 0 : result.signature) || "";
      },
      sendTransaction: async (args) => {
        if (args.chainNamespace === "eip155") {
          const adapter = this.getAdapter(ChainController.state.activeChain);
          const result = await (adapter == null ? void 0 : adapter.sendTransaction(args));
          return (result == null ? void 0 : result.hash) || "";
        }
        return "";
      },
      estimateGas: async (args) => {
        if (args.chainNamespace === "eip155") {
          const adapter = this.getAdapter(ChainController.state.activeChain);
          const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
          const caipNetwork = this.getCaipNetwork();
          if (!caipNetwork) {
            throw new Error("CaipNetwork is undefined");
          }
          const result = await (adapter == null ? void 0 : adapter.estimateGas({
            ...args,
            provider,
            caipNetwork
          }));
          return (result == null ? void 0 : result.gas) || 0n;
        }
        return 0n;
      },
      getEnsAvatar: async () => {
        var _a;
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const result = await (adapter == null ? void 0 : adapter.getProfile({
          address: AccountController.state.address,
          chainId: Number((_a = this.getCaipNetwork()) == null ? void 0 : _a.id)
        }));
        return (result == null ? void 0 : result.profileImage) || false;
      },
      getEnsAddress: async (name) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const caipNetwork = this.getCaipNetwork();
        if (!caipNetwork) {
          return false;
        }
        const result = await (adapter == null ? void 0 : adapter.getEnsAddress({
          name,
          caipNetwork
        }));
        return (result == null ? void 0 : result.address) || false;
      },
      writeContract: async (args) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const caipNetwork = this.getCaipNetwork();
        const caipAddress = this.getCaipAddress();
        const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
        if (!caipNetwork || !caipAddress) {
          throw new Error("CaipNetwork or CaipAddress is undefined");
        }
        const result = await (adapter == null ? void 0 : adapter.writeContract({ ...args, caipNetwork, provider, caipAddress }));
        return result == null ? void 0 : result.hash;
      },
      parseUnits: (value, decimals) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return (adapter == null ? void 0 : adapter.parseUnits({ value, decimals })) ?? 0n;
      },
      formatUnits: (value, decimals) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return (adapter == null ? void 0 : adapter.formatUnits({ value, decimals })) ?? "0";
      },
      getCapabilities: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        await (adapter == null ? void 0 : adapter.getCapabilities(params));
      },
      grantPermissions: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return await (adapter == null ? void 0 : adapter.grantPermissions(params));
      },
      revokePermissions: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (adapter == null ? void 0 : adapter.revokePermissions) {
          return await adapter.revokePermissions(params);
        }
        return "0x";
      }
    };
    this.networkControllerClient = {
      switchCaipNetwork: async (caipNetwork) => {
        var _a, _b, _c;
        if (!caipNetwork) {
          return;
        }
        if (AccountController.state.address && caipNetwork.chainNamespace === ChainController.state.activeChain) {
          const adapter = this.getAdapter(ChainController.state.activeChain);
          const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
          const providerType = ProviderUtil.state.providerIds[ChainController.state.activeChain];
          await (adapter == null ? void 0 : adapter.switchNetwork({ caipNetwork, provider, providerType }));
          this.setCaipNetwork(caipNetwork);
          await this.syncAccount({
            address: AccountController.state.address,
            chainId: (_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.id,
            chainNamespace: caipNetwork.chainNamespace
          });
        } else if (AccountController.state.address) {
          const providerType = ProviderUtil.state.providerIds[ChainController.state.activeChain];
          if (providerType === "AUTH") {
            try {
              ChainController.state.activeChain = caipNetwork.chainNamespace;
              await ((_c = (_b = this.connectionControllerClient) == null ? void 0 : _b.connectExternal) == null ? void 0 : _c.call(_b, {
                id: "ID_AUTH",
                provider: this.authProvider,
                chain: caipNetwork.chainNamespace,
                chainId: caipNetwork.id,
                type: "AUTH",
                caipNetwork
              }));
            } catch (error) {
              const adapter = this.getAdapter(caipNetwork.chainNamespace);
              await (adapter == null ? void 0 : adapter.switchNetwork({
                caipNetwork,
                provider: this.authProvider,
                providerType
              }));
            }
          } else if (providerType === "WALLET_CONNECT") {
            this.setCaipNetwork(caipNetwork);
            this.syncWalletConnectAccount();
          } else {
            this.setCaipNetwork(caipNetwork);
            const address = this.getAddressByChainNamespace(caipNetwork.chainNamespace);
            if (address) {
              this.syncAccount({
                address,
                chainId: caipNetwork.id,
                chainNamespace: caipNetwork.chainNamespace
              });
            }
          }
        } else {
          this.setCaipNetwork(caipNetwork);
        }
      },
      // eslint-disable-next-line @typescript-eslint/require-await
      getApprovedCaipNetworksData: async () => {
        var _a, _b;
        const providerType = ProviderUtil.state.providerIds[ChainController.state.activeChain];
        if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
          const namespaces = (_b = (_a = this.universalProvider) == null ? void 0 : _a.session) == null ? void 0 : _b.namespaces;
          return {
            supportsAllNetworks: false,
            approvedCaipNetworkIds: this.getChainsFromNamespaces(namespaces)
          };
        }
        return { supportsAllNetworks: true, approvedCaipNetworkIds: [] };
      }
    };
    if (this.networkControllerClient && this.connectionControllerClient) {
      ConnectionController.setClient(this.connectionControllerClient);
    }
  }
  async handleDisconnect() {
    var _a;
    await ((_a = this.connectionControllerClient) == null ? void 0 : _a.disconnect());
  }
  async listenAuthConnector(provider) {
    var _a, _b, _c;
    this.setLoading(true);
    const isLoginEmailUsed = provider.getLoginEmailUsed();
    this.setLoading(isLoginEmailUsed);
    const { isConnected } = await provider.isConnected();
    if (isConnected && ((_a = this.connectionControllerClient) == null ? void 0 : _a.connectExternal)) {
      (_c = this.connectionControllerClient) == null ? void 0 : _c.connectExternal({
        id: "ID_AUTH",
        info: {
          name: "ID_AUTH"
        },
        type: "AUTH",
        provider,
        chainId: (_b = ChainController.state.activeCaipNetwork) == null ? void 0 : _b.id
      });
    } else {
      this.setLoading(false);
    }
    provider.onRpcRequest((request) => {
      if (W3mFrameHelpers.checkIfRequestExists(request)) {
        if (!W3mFrameHelpers.checkIfRequestIsSafe(request)) {
          this.handleUnsafeRPCRequest();
        }
      } else {
        this.open();
        console.error(W3mFrameRpcConstants.RPC_METHOD_NOT_ALLOWED_MESSAGE, {
          method: request.method
        });
        setTimeout(() => {
          this.showErrorMessage(W3mFrameRpcConstants.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE);
        }, 300);
        provider.rejectRpcRequests();
      }
    });
    provider.onRpcError(() => {
      const isModalOpen = this.isOpen();
      if (isModalOpen) {
        if (this.isTransactionStackEmpty()) {
          this.close();
        } else {
          this.popTransactionStack(true);
        }
      }
    });
    provider.onRpcSuccess((_3, request) => {
      const isSafeRequest = W3mFrameHelpers.checkIfRequestIsSafe(request);
      if (isSafeRequest) {
        return;
      }
      if (this.isTransactionStackEmpty()) {
        this.close();
      } else {
        this.popTransactionStack();
      }
    });
    provider.onNotConnected(() => {
      const connectedConnector = SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTED_CONNECTOR);
      const isConnectedWithAuth = connectedConnector === "ID_AUTH";
      if (!isConnected && isConnectedWithAuth) {
        this.setCaipAddress(void 0, ChainController.state.activeChain);
        this.setLoading(false);
      }
    });
    provider.onIsConnected(() => {
      provider.connect();
    });
    provider.onConnect(async (user) => {
      this.syncProvider({
        type: "AUTH",
        provider,
        id: "ID_AUTH",
        chainNamespace: ChainController.state.activeChain
      });
      const caipAddress = ChainController.state.activeChain === "eip155" ? `eip155:${user.chainId}:${user.address}` : `${user.chainId}:${user.address}`;
      this.setCaipAddress(caipAddress, ChainController.state.activeChain);
      this.setSmartAccountDeployed(Boolean(user.smartAccountDeployed), ChainController.state.activeChain);
      this.setPreferredAccountType(user.preferredAccountType, ChainController.state.activeChain);
      this.setAllAccounts(user.accounts || [
        {
          address: user.address,
          type: user.preferredAccountType || "eoa"
        }
      ], ChainController.state.activeChain);
      await provider.getSmartAccountEnabledNetworks();
      this.setLoading(false);
    });
    provider.onGetSmartAccountEnabledNetworks((networks) => {
      this.setSmartAccountEnabledNetworks(networks, ChainController.state.activeChain);
    });
    provider.onSetPreferredAccount(({ address, type }) => {
      if (!address) {
        return;
      }
      this.setPreferredAccountType(type, ChainController.state.activeChain);
    });
  }
  listenWalletConnect() {
    if (this.universalProvider) {
      this.universalProvider.on("disconnect", () => {
        this.chainNamespaces.forEach((namespace) => {
          this.resetAccount(namespace);
        });
        ConnectionController.resetWcConnection();
      });
      this.universalProvider.on("chainChanged", (chainId) => {
        var _a;
        const caipNetwork = (_a = this.caipNetworks) == null ? void 0 : _a.find(
          // eslint-disable-next-line eqeqeq
          (c5) => c5.chainNamespace === ChainController.state.activeChain && c5.id == chainId
        );
        const currentCaipNetwork = this.getCaipNetwork();
        if (!caipNetwork) {
          const namespace = this.getActiveChainNamespace() || ConstantsUtil.CHAIN.EVM;
          ChainController.setActiveCaipNetwork({
            id: chainId,
            caipNetworkId: `${namespace}:${chainId}`,
            name: "Unknown Network",
            chainNamespace: namespace,
            nativeCurrency: {
              name: "",
              decimals: 0,
              symbol: ""
            },
            rpcUrls: {
              default: {
                http: []
              }
            }
          });
          return;
        }
        if (!currentCaipNetwork || (currentCaipNetwork == null ? void 0 : currentCaipNetwork.id) !== (caipNetwork == null ? void 0 : caipNetwork.id)) {
          this.setCaipNetwork(caipNetwork);
        }
      });
    }
  }
  listenAdapter(chainNamespace) {
    const adapter = this.getAdapter(chainNamespace);
    adapter == null ? void 0 : adapter.on("switchNetwork", ({ address, chainId }) => {
      var _a;
      if (chainId && ((_a = this.caipNetworks) == null ? void 0 : _a.find((n4) => n4.id === chainId))) {
        if (ChainController.state.activeChain === chainNamespace && address) {
          this.syncAccount({ address, chainId, chainNamespace });
        } else if (ChainController.state.activeChain === chainNamespace && AccountController.state.address) {
          this.syncAccount({
            address: AccountController.state.address,
            chainId,
            chainNamespace
          });
        }
      } else {
        ChainController.showUnsupportedChainUI();
      }
    });
    adapter == null ? void 0 : adapter.on("disconnect", () => {
      if (ChainController.state.activeChain === chainNamespace) {
        this.handleDisconnect();
      }
    });
    adapter == null ? void 0 : adapter.on("accountChanged", ({ address, chainId }) => {
      var _a, _b;
      if (ChainController.state.activeChain === chainNamespace && chainId) {
        this.syncAccount({
          address,
          chainId,
          chainNamespace
        });
      } else if (ChainController.state.activeChain === chainNamespace && ((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.id)) {
        this.syncAccount({
          address,
          chainId: (_b = ChainController.state.activeCaipNetwork) == null ? void 0 : _b.id,
          chainNamespace
        });
      }
    });
  }
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const [chainNamespace, chainId] = account.split(":");
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  }
  async syncWalletConnectAccount() {
    const adapter = this.getAdapter(ChainController.state.activeChain);
    StorageUtil.setConnectedNamespace(ChainController.state.activeChain);
    this.chainNamespaces.forEach(async (chainNamespace) => {
      var _a, _b, _c, _d, _e3, _f, _g, _h2;
      const caipAddress = (_d = (_c = (_b = (_a = this.universalProvider) == null ? void 0 : _a.session) == null ? void 0 : _b.namespaces) == null ? void 0 : _c[chainNamespace]) == null ? void 0 : _d.accounts[0];
      if (caipAddress) {
        ProviderUtil.setProviderId(chainNamespace, ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT);
        if (this.caipNetworks && ChainController.state.activeCaipNetwork && (adapter == null ? void 0 : adapter.adapterType) === "solana") {
          const provider = adapter == null ? void 0 : adapter.getWalletConnectProvider({
            caipNetworks: this.caipNetworks,
            provider: this.universalProvider,
            activeCaipNetwork: ChainController.state.activeCaipNetwork
          });
          ProviderUtil.setProvider(chainNamespace, provider);
        } else {
          ProviderUtil.setProvider(chainNamespace, this.universalProvider);
        }
        StorageUtil.setConnectedConnector(ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT);
        let address = "";
        if (caipAddress.split(":").length === 3) {
          address = caipAddress.split(":")[2];
        } else {
          address = AccountController.state.address;
        }
        if ((adapter == null ? void 0 : adapter.adapterType) === "wagmi") {
          try {
            await (adapter == null ? void 0 : adapter.connect({
              id: "walletConnect",
              type: "WALLET_CONNECT",
              chainId: (_e3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _e3.id
            }));
          } catch (error) {
            adapter == null ? void 0 : adapter.switchNetwork({
              provider: this.universalProvider,
              caipNetwork: ChainController.state.activeCaipNetwork
            });
          }
        }
        this.syncWalletConnectAccounts(chainNamespace);
        await this.syncAccount({
          address,
          chainId: ChainController.state.activeChain === chainNamespace ? (_f = ChainController.state.activeCaipNetwork) == null ? void 0 : _f.id : (_h2 = (_g = this.caipNetworks) == null ? void 0 : _g.find((n4) => n4.chainNamespace === chainNamespace)) == null ? void 0 : _h2.id,
          chainNamespace
        });
      }
    });
    await ChainController.setApprovedCaipNetworksData(ChainController.state.activeChain);
  }
  syncWalletConnectAccounts(chainNamespace) {
    var _a, _b, _c, _d, _e3;
    const addresses = (_e3 = (_d = (_c = (_b = (_a = this.universalProvider) == null ? void 0 : _a.session) == null ? void 0 : _b.namespaces) == null ? void 0 : _c[chainNamespace]) == null ? void 0 : _d.accounts) == null ? void 0 : _e3.map((account) => {
      const [, , address] = account.split(":");
      return address;
    }).filter((address, index2, self2) => self2.indexOf(address) === index2);
    if (addresses) {
      this.setAllAccounts(addresses.map((address) => ({ address, type: "eoa" })), chainNamespace);
    }
  }
  syncProvider({ type, provider, id, chainNamespace }) {
    ProviderUtil.setProviderId(chainNamespace, type);
    ProviderUtil.setProvider(chainNamespace, provider);
    StorageUtil.setConnectedConnector(id);
    StorageUtil.setConnectedNamespace(ChainController.state.activeChain);
  }
  async syncAccount({ address, chainId, chainNamespace }) {
    var _a, _b;
    this.setPreferredAccountType(AccountController.state.preferredAccountType ? AccountController.state.preferredAccountType : "eoa", ChainController.state.activeChain);
    this.setCaipAddress(`${chainNamespace}:${chainId}:${address}`, chainNamespace);
    this.setStatus("connected", chainNamespace);
    if (chainNamespace === ChainController.state.activeChain) {
      const caipNetwork = (_a = this.caipNetworks) == null ? void 0 : _a.find((n4) => n4.id === chainId && n4.chainNamespace === chainNamespace);
      if (caipNetwork) {
        this.setCaipNetwork(caipNetwork);
      } else {
        this.setCaipNetwork((_b = this.caipNetworks) == null ? void 0 : _b.find((n4) => n4.chainNamespace === chainNamespace));
      }
      this.syncConnectedWalletInfo(chainNamespace);
      const adapter = this.getAdapter(chainNamespace);
      const balance = await (adapter == null ? void 0 : adapter.getBalance({
        address,
        chainId,
        caipNetwork: caipNetwork || this.getCaipNetwork(),
        tokens: this.options.tokens
      }));
      if (balance) {
        this.setBalance(balance.balance, balance.symbol, chainNamespace);
      }
      await this.syncIdentity({ address, chainId: Number(chainId), chainNamespace });
    }
  }
  syncConnectedWalletInfo(chainNamespace) {
    var _a;
    const currentActiveWallet = SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTED_CONNECTOR);
    const providerType = ProviderUtil.state.providerIds[chainNamespace];
    if (providerType === ConstantsUtil3.CONNECTOR_TYPE_ANNOUNCED || providerType === ConstantsUtil3.CONNECTOR_TYPE_INJECTED) {
      if (currentActiveWallet) {
        const connector = this.getConnectors().find((c5) => c5.id === currentActiveWallet);
        if (connector == null ? void 0 : connector.info) {
          this.setConnectedWalletInfo({ ...connector.info }, chainNamespace);
        }
      }
    } else if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
      const provider = ProviderUtil.getProvider(chainNamespace);
      if (provider == null ? void 0 : provider.session) {
        this.setConnectedWalletInfo({
          ...provider.session.peer.metadata,
          name: provider.session.peer.metadata.name,
          icon: (_a = provider.session.peer.metadata.icons) == null ? void 0 : _a[0]
        }, chainNamespace);
      }
    } else if (providerType === ConstantsUtil3.COINBASE_CONNECTOR_ID) {
      const connector = this.getConnectors().find((c5) => c5.id === ConstantsUtil3.COINBASE_CONNECTOR_ID);
      this.setConnectedWalletInfo({ name: "Coinbase Wallet", icon: this.getConnectorImage(connector) }, chainNamespace);
    } else if (currentActiveWallet) {
      this.setConnectedWalletInfo({ name: currentActiveWallet }, chainNamespace);
    }
  }
  async syncIdentity({ address, chainId, chainNamespace }) {
    try {
      const { name, avatar } = await this.fetchIdentity({
        address
      });
      this.setProfileName(name, chainNamespace);
      this.setProfileImage(avatar, chainNamespace);
      if (!name) {
        await this.syncReownName(address, chainNamespace);
        const adapter = this.getAdapter(chainNamespace);
        const result = await (adapter == null ? void 0 : adapter.getProfile({
          address,
          chainId: Number(chainId)
        }));
        if (result == null ? void 0 : result.profileName) {
          this.setProfileName(result.profileName, chainNamespace);
          if (result.profileImage) {
            this.setProfileImage(result.profileImage, chainNamespace);
          }
        } else {
          await this.syncReownName(address, chainNamespace);
          this.setProfileImage(null, chainNamespace);
        }
      }
    } catch {
      if (chainId === 1) {
        await this.syncReownName(address, chainNamespace);
      } else {
        await this.syncReownName(address, chainNamespace);
        this.setProfileImage(null, chainNamespace);
      }
    }
  }
  async syncReownName(address, chainNamespace) {
    try {
      const registeredWcNames = await this.getReownName(address);
      if (registeredWcNames[0]) {
        const wcName = registeredWcNames[0];
        this.setProfileName(wcName.name, chainNamespace);
      } else {
        this.setProfileName(null, chainNamespace);
      }
    } catch {
      this.setProfileName(null, chainNamespace);
    }
  }
  syncRequestedNetworks() {
    var _a;
    const uniqueChainNamespaces = [
      ...new Set((_a = this.caipNetworks) == null ? void 0 : _a.map((caipNetwork) => caipNetwork.chainNamespace))
    ];
    this.chainNamespaces = uniqueChainNamespaces;
    uniqueChainNamespaces.forEach((chainNamespace) => {
      var _a2;
      return this.setRequestedCaipNetworks(((_a2 = this.caipNetworks) == null ? void 0 : _a2.filter((caipNetwork) => caipNetwork.chainNamespace === chainNamespace)) ?? [], chainNamespace);
    });
  }
  async syncExistingConnection() {
    var _a, _b, _c, _d, _e3;
    const connectedConnector = SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTED_CONNECTOR);
    const connectedNamespace = SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTED_NAMESPACE);
    if (connectedConnector === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT && connectedNamespace) {
      this.syncWalletConnectAccount();
    } else if (connectedConnector && connectedConnector !== ConstantsUtil3.CONNECTOR_TYPE_W3M_AUTH && connectedNamespace) {
      const adapter = this.getAdapter(connectedNamespace);
      const res = await (adapter == null ? void 0 : adapter.syncConnection({
        id: connectedConnector,
        chainId: (_a = this.getCaipNetwork()) == null ? void 0 : _a.id,
        namespace: connectedNamespace,
        rpcUrl: (_e3 = (_d = (_c = (_b = this.getCaipNetwork()) == null ? void 0 : _b.rpcUrls) == null ? void 0 : _c.default) == null ? void 0 : _d.http) == null ? void 0 : _e3[0]
      }));
      if (res) {
        this.syncProvider({ ...res, chainNamespace: connectedNamespace });
        await this.syncAccount({ ...res, chainNamespace: connectedNamespace });
      }
    }
  }
  getAdapter(namespace) {
    var _a;
    return (_a = this.chainAdapters) == null ? void 0 : _a[namespace];
  }
  createUniversalProvider() {
    var _a;
    if (!this.universalProviderInitPromise && typeof window !== "undefined" && ((_a = this.options) == null ? void 0 : _a.projectId)) {
      this.universalProviderInitPromise = this.initializeUniversalAdapter();
    }
    return this.universalProviderInitPromise;
  }
  async initializeUniversalAdapter() {
    var _a, _b, _c, _d, _e3, _f, _g, _h2, _i2;
    const universalProviderOptions = {
      projectId: (_a = this.options) == null ? void 0 : _a.projectId,
      metadata: {
        name: ((_b = this.options) == null ? void 0 : _b.metadata) ? (_c = this.options) == null ? void 0 : _c.metadata.name : "",
        description: ((_d = this.options) == null ? void 0 : _d.metadata) ? (_e3 = this.options) == null ? void 0 : _e3.metadata.description : "",
        url: ((_f = this.options) == null ? void 0 : _f.metadata) ? (_g = this.options) == null ? void 0 : _g.metadata.url : "",
        icons: ((_h2 = this.options) == null ? void 0 : _h2.metadata) ? (_i2 = this.options) == null ? void 0 : _i2.metadata.icons : [""]
      }
    };
    this.universalProvider = await dr2.init(universalProviderOptions);
  }
  async getUniversalProvider() {
    if (!this.universalProvider) {
      try {
        await this.createUniversalProvider();
      } catch (error) {
        throw new Error("AppKit:getUniversalProvider - Cannot create provider");
      }
    }
    return this.universalProvider;
  }
  createAuthProvider() {
    var _a, _b, _c, _d, _e3, _f, _g, _h2, _i2, _j;
    const emailEnabled = ((_b = (_a = this.options) == null ? void 0 : _a.features) == null ? void 0 : _b.email) === void 0 ? ConstantsUtil2.DEFAULT_FEATURES.email : (_d = (_c = this.options) == null ? void 0 : _c.features) == null ? void 0 : _d.email;
    const socialsEnabled = ((_f = (_e3 = this.options) == null ? void 0 : _e3.features) == null ? void 0 : _f.socials) ? ((_i2 = (_h2 = (_g = this.options) == null ? void 0 : _g.features) == null ? void 0 : _h2.socials) == null ? void 0 : _i2.length) > 0 : ConstantsUtil2.DEFAULT_FEATURES.socials;
    if (((_j = this.options) == null ? void 0 : _j.projectId) && (emailEnabled || socialsEnabled)) {
      this.authProvider = W3mFrameProviderSingleton.getInstance({
        projectId: this.options.projectId
      });
      this.listenAuthConnector(this.authProvider);
    }
  }
  async createAdapters(blueprints) {
    if (!this.universalProvider) {
      this.universalProvider = await this.getUniversalProvider();
    }
    this.syncRequestedNetworks();
    return this.chainNamespaces.reduce((adapters, namespace) => {
      var _a;
      const blueprint = blueprints == null ? void 0 : blueprints.find((b3) => b3.namespace === namespace);
      if (blueprint) {
        adapters[namespace] = blueprint;
        adapters[namespace].namespace = namespace;
        adapters[namespace].construct({
          namespace,
          projectId: (_a = this.options) == null ? void 0 : _a.projectId,
          networks: this.caipNetworks
        });
        if (this.universalProvider) {
          adapters[namespace].setUniversalProvider(this.universalProvider);
        }
        if (this.authProvider) {
          adapters[namespace].setAuthProvider(this.authProvider);
        }
        adapters[namespace].syncConnectors(this.options, this);
      } else {
        adapters[namespace] = new UniversalAdapter({
          namespace,
          networks: this.caipNetworks
        });
        if (this.universalProvider) {
          adapters[namespace].setUniversalProvider(this.universalProvider);
        }
        if (this.authProvider) {
          adapters[namespace].setAuthProvider(this.authProvider);
        }
      }
      ChainController.state.chains.set(namespace, {
        namespace,
        connectionControllerClient: this.connectionControllerClient,
        networkControllerClient: this.networkControllerClient,
        networkState,
        accountState,
        caipNetworks: this.caipNetworks ?? []
      });
      return adapters;
    }, {});
  }
  async initChainAdapters() {
    await Promise.all(
      // eslint-disable-next-line @typescript-eslint/require-await
      this.chainNamespaces.map(async (namespace) => {
        var _a, _b;
        if (this.options) {
          this.listenAdapter(namespace);
          this.setConnectors(((_b = (_a = this.chainAdapters) == null ? void 0 : _a[namespace]) == null ? void 0 : _b.connectors) || []);
        }
      })
    );
    this.listenWalletConnect();
  }
  setDefaultNetwork() {
    var _a, _b;
    const previousNetwork = SafeLocalStorage.getItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID);
    const caipNetwork = previousNetwork && ((_a = this.caipNetworks) == null ? void 0 : _a.length) ? this.caipNetworks.find((n4) => n4.caipNetworkId === previousNetwork) : void 0;
    const network = caipNetwork || this.defaultCaipNetwork || ((_b = this.caipNetworks) == null ? void 0 : _b[0]);
    if (network) {
      ChainController.setActiveCaipNetwork(network);
    }
  }
  async initOrContinue() {
    if (!this.initPromise && !isInitialized && CoreHelperUtil.isClient()) {
      isInitialized = true;
      this.initPromise = new Promise(async (resolve) => {
        await Promise.all([
          import("./esm-ZBF6S3AH.js"),
          import("./w3m-modal-OMUB73NO.js")
        ]);
        const modal = document.createElement("w3m-modal");
        if (!OptionsController.state.disableAppend) {
          document.body.insertAdjacentElement("beforeend", modal);
        }
        resolve();
      });
    }
    return this.initPromise;
  }
};

// node_modules/@reown/appkit/dist/esm/exports/constants.js
var PACKAGE_VERSION = "1.4.1";

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-account-button/index.js
var __decorate = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAccountButtonBase = class extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.balance = "show";
    this.charsStart = 4;
    this.charsEnd = 6;
    this.caipAddress = ChainController.state.activeCaipAddress;
    this.balanceVal = AccountController.state.balance;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.profileName = AccountController.state.profileName;
    this.profileImage = AccountController.state.profileImage;
    this.network = ChainController.state.activeCaipNetwork;
    this.networkImage = AssetUtil.getNetworkImage(this.network);
    this.isSupported = true;
    this.unsubscribe.push(...[
      AssetController.subscribeNetworkImages(() => {
        this.networkImage = AssetUtil.getNetworkImage(this.network);
      }),
      ChainController.subscribeKey("activeCaipAddress", (val) => {
        this.caipAddress = val;
      }),
      AccountController.subscribeKey("balance", (val) => this.balanceVal = val),
      AccountController.subscribeKey("balanceSymbol", (val) => this.balanceSymbol = val),
      AccountController.subscribeKey("profileName", (val) => this.profileName = val),
      AccountController.subscribeKey("profileImage", (val) => this.profileImage = val),
      ChainController.subscribeKey("activeCaipNetwork", (val) => {
        this.network = val;
        this.networkImage = AssetUtil.getNetworkImage(val);
        this.isSupported = (val == null ? void 0 : val.chainNamespace) ? ChainController.checkIfSupportedNetwork(val == null ? void 0 : val.chainNamespace) : true;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!ChainController.state.activeChain) {
      return null;
    }
    const showBalance = this.balance === "show";
    return html`
      <wui-account-button
        .disabled=${Boolean(this.disabled)}
        .isUnsupportedChain=${!this.isSupported}
        address=${ifDefined(CoreHelperUtil.getPlainAddress(this.caipAddress))}
        profileName=${ifDefined(this.profileName)}
        networkSrc=${ifDefined(this.networkImage)}
        avatarSrc=${ifDefined(this.profileImage)}
        balance=${showBalance ? CoreHelperUtil.formatBalance(this.balanceVal, this.balanceSymbol) : ""}
        @click=${this.onClick.bind(this)}
        data-testid="account-button"
        .charsStart=${this.charsStart}
        .charsEnd=${this.charsEnd}
      >
      </wui-account-button>
    `;
  }
  onClick() {
    if (this.isSupported) {
      ModalController.open();
    } else {
      ModalController.open({ view: "UnsupportedChain" });
    }
  }
};
__decorate([
  property({ type: Boolean })
], W3mAccountButtonBase.prototype, "disabled", void 0);
__decorate([
  property()
], W3mAccountButtonBase.prototype, "balance", void 0);
__decorate([
  property()
], W3mAccountButtonBase.prototype, "charsStart", void 0);
__decorate([
  property()
], W3mAccountButtonBase.prototype, "charsEnd", void 0);
__decorate([
  state()
], W3mAccountButtonBase.prototype, "caipAddress", void 0);
__decorate([
  state()
], W3mAccountButtonBase.prototype, "balanceVal", void 0);
__decorate([
  state()
], W3mAccountButtonBase.prototype, "balanceSymbol", void 0);
__decorate([
  state()
], W3mAccountButtonBase.prototype, "profileName", void 0);
__decorate([
  state()
], W3mAccountButtonBase.prototype, "profileImage", void 0);
__decorate([
  state()
], W3mAccountButtonBase.prototype, "network", void 0);
__decorate([
  state()
], W3mAccountButtonBase.prototype, "networkImage", void 0);
__decorate([
  state()
], W3mAccountButtonBase.prototype, "isSupported", void 0);
var W3mAccountButton = class W3mAccountButton2 extends W3mAccountButtonBase {
};
W3mAccountButton = __decorate([
  customElement("w3m-account-button")
], W3mAccountButton);
var AppKitAccountButton = class AppKitAccountButton2 extends W3mAccountButtonBase {
};
AppKitAccountButton = __decorate([
  customElement("appkit-account-button")
], AppKitAccountButton);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-button/styles.js
var styles_default = css`
  :host {
    display: block;
    width: max-content;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-button/index.js
var __decorate2 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mButtonBase = class extends LitElement {
  constructor() {
    super(...arguments);
    this.unsubscribe = [];
    this.disabled = false;
    this.balance = void 0;
    this.size = void 0;
    this.label = void 0;
    this.loadingLabel = void 0;
    this.charsStart = 4;
    this.charsEnd = 6;
    this.caipAddress = ChainController.state.activeCaipAddress;
    this.isLoading = ModalController.state.loading;
  }
  firstUpdated() {
    this.unsubscribe.push(ChainController.subscribeKey("activeCaipAddress", (val) => this.caipAddress = val), ModalController.subscribeKey("loading", (val) => this.isLoading = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return this.caipAddress && !this.isLoading ? html`
          <appkit-account-button
            .disabled=${Boolean(this.disabled)}
            balance=${ifDefined(this.balance)}
            .charsStart=${ifDefined(this.charsStart)}
            .charsEnd=${ifDefined(this.charsEnd)}
          >
          </appkit-account-button>
        ` : html`
          <appkit-connect-button
            size=${ifDefined(this.size)}
            label=${ifDefined(this.label)}
            loadingLabel=${ifDefined(this.loadingLabel)}
          ></appkit-connect-button>
        `;
  }
};
W3mButtonBase.styles = styles_default;
__decorate2([
  property({ type: Boolean })
], W3mButtonBase.prototype, "disabled", void 0);
__decorate2([
  property()
], W3mButtonBase.prototype, "balance", void 0);
__decorate2([
  property()
], W3mButtonBase.prototype, "size", void 0);
__decorate2([
  property()
], W3mButtonBase.prototype, "label", void 0);
__decorate2([
  property()
], W3mButtonBase.prototype, "loadingLabel", void 0);
__decorate2([
  property()
], W3mButtonBase.prototype, "charsStart", void 0);
__decorate2([
  property()
], W3mButtonBase.prototype, "charsEnd", void 0);
__decorate2([
  state()
], W3mButtonBase.prototype, "caipAddress", void 0);
__decorate2([
  state()
], W3mButtonBase.prototype, "isLoading", void 0);
var W3mButton = class W3mButton2 extends W3mButtonBase {
};
W3mButton = __decorate2([
  customElement("w3m-button")
], W3mButton);
var AppKitButton = class AppKitButton2 extends W3mButtonBase {
};
AppKitButton = __decorate2([
  customElement("appkit-button")
], AppKitButton);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-connect-button/index.js
var __decorate3 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectButtonBase = class extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.size = "md";
    this.label = "Connect Wallet";
    this.loadingLabel = "Connecting...";
    this.open = ModalController.state.open;
    this.loading = ModalController.state.loading;
    this.unsubscribe.push(ModalController.subscribe((val) => {
      this.open = val.open;
      this.loading = val.loading;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const isLoading = this.loading || this.open;
    return html`
      <wui-connect-button
        size=${ifDefined(this.size)}
        .loading=${isLoading}
        @click=${this.onClick.bind(this)}
        data-testid="connect-button"
      >
        ${isLoading ? this.loadingLabel : this.label}
      </wui-connect-button>
    `;
  }
  onClick() {
    if (this.open) {
      ModalController.close();
    } else if (!this.loading) {
      ModalController.open();
    }
  }
};
__decorate3([
  property()
], W3mConnectButtonBase.prototype, "size", void 0);
__decorate3([
  property()
], W3mConnectButtonBase.prototype, "label", void 0);
__decorate3([
  property()
], W3mConnectButtonBase.prototype, "loadingLabel", void 0);
__decorate3([
  state()
], W3mConnectButtonBase.prototype, "open", void 0);
__decorate3([
  state()
], W3mConnectButtonBase.prototype, "loading", void 0);
var W3mConnectButton = class W3mConnectButton2 extends W3mConnectButtonBase {
};
W3mConnectButton = __decorate3([
  customElement("w3m-connect-button")
], W3mConnectButton);
var AppKitConnectButton = class AppKitConnectButton2 extends W3mConnectButtonBase {
};
AppKitConnectButton = __decorate3([
  customElement("appkit-connect-button")
], AppKitConnectButton);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-network-button/styles.js
var styles_default2 = css`
  :host {
    display: block;
    width: max-content;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-network-button/index.js
var __decorate4 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mNetworkButtonBase = class extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.network = ChainController.state.activeCaipNetwork;
    this.networkImage = AssetUtil.getNetworkImage(this.network);
    this.caipAddress = ChainController.state.activeCaipAddress;
    this.loading = ModalController.state.loading;
    this.isSupported = true;
    this.unsubscribe.push(...[
      AssetController.subscribeNetworkImages(() => {
        this.networkImage = AssetUtil.getNetworkImage(this.network);
      }),
      ChainController.subscribeKey("activeCaipAddress", (val) => {
        this.caipAddress = val;
      }),
      ChainController.subscribeKey("activeCaipNetwork", (val) => {
        this.network = val;
        this.networkImage = AssetUtil.getNetworkImage(val);
        this.isSupported = (val == null ? void 0 : val.chainNamespace) ? ChainController.checkIfSupportedNetwork(val.chainNamespace) : true;
      }),
      ModalController.subscribeKey("loading", (val) => this.loading = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const isSupported = this.network ? ChainController.checkIfSupportedNetwork(this.network.chainNamespace) : true;
    return html`
      <wui-network-button
        .disabled=${Boolean(this.disabled || this.loading)}
        .isUnsupportedChain=${!isSupported}
        imageSrc=${ifDefined(this.networkImage)}
        @click=${this.onClick.bind(this)}
      >
        ${this.getLabel()}
        <slot></slot>
      </wui-network-button>
    `;
  }
  getLabel() {
    if (this.network) {
      if (!this.isSupported) {
        return "Switch Network";
      }
      return this.network.name;
    }
    if (this.label) {
      return this.label;
    }
    if (this.caipAddress) {
      return "Unknown Network";
    }
    return "Select Network";
  }
  onClick() {
    if (!this.loading) {
      EventsController.sendEvent({ type: "track", event: "CLICK_NETWORKS" });
      ModalController.open({ view: "Networks" });
    }
  }
};
W3mNetworkButtonBase.styles = styles_default2;
__decorate4([
  property({ type: Boolean })
], W3mNetworkButtonBase.prototype, "disabled", void 0);
__decorate4([
  property({ type: String })
], W3mNetworkButtonBase.prototype, "label", void 0);
__decorate4([
  state()
], W3mNetworkButtonBase.prototype, "network", void 0);
__decorate4([
  state()
], W3mNetworkButtonBase.prototype, "networkImage", void 0);
__decorate4([
  state()
], W3mNetworkButtonBase.prototype, "caipAddress", void 0);
__decorate4([
  state()
], W3mNetworkButtonBase.prototype, "loading", void 0);
__decorate4([
  state()
], W3mNetworkButtonBase.prototype, "isSupported", void 0);
var W3mNetworkButton = class W3mNetworkButton2 extends W3mNetworkButtonBase {
};
W3mNetworkButton = __decorate4([
  customElement("w3m-network-button")
], W3mNetworkButton);
var AppKitNetworkButton = class AppKitNetworkButton2 extends W3mNetworkButtonBase {
};
AppKitNetworkButton = __decorate4([
  customElement("appkit-network-button")
], AppKitNetworkButton);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-router/styles.js
var styles_default3 = css`
  :host {
    --prev-height: 0px;
    --new-height: 0px;
    display: block;
  }

  div.w3m-router-container {
    transform: translateY(0);
    opacity: 1;
  }

  div.w3m-router-container[view-direction='prev'] {
    animation:
      slide-left-out 150ms forwards ease,
      slide-left-in 150ms forwards ease;
    animation-delay: 0ms, 200ms;
  }

  div.w3m-router-container[view-direction='next'] {
    animation:
      slide-right-out 150ms forwards ease,
      slide-right-in 150ms forwards ease;
    animation-delay: 0ms, 200ms;
  }

  @keyframes slide-left-out {
    from {
      transform: translateX(0px);
      opacity: 1;
    }
    to {
      transform: translateX(10px);
      opacity: 0;
    }
  }

  @keyframes slide-left-in {
    from {
      transform: translateX(-10px);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }

  @keyframes slide-right-out {
    from {
      transform: translateX(0px);
      opacity: 1;
    }
    to {
      transform: translateX(-10px);
      opacity: 0;
    }
  }

  @keyframes slide-right-in {
    from {
      transform: translateX(10px);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/ConstantsUtil.js
var ConstantsUtil4 = {
  ACCOUNT_TABS: [{ label: "Tokens" }, { label: "NFTs" }, { label: "Activity" }],
  SECURE_SITE_ORIGIN: process.env["NEXT_PUBLIC_SECURE_SITE_ORIGIN"] || "https://secure.walletconnect.org",
  VIEW_DIRECTION: {
    Next: "next",
    Prev: "prev"
  },
  ANIMATION_DURATIONS: {
    HeaderText: 120,
    ModalHeight: 150,
    ViewTransition: 150
  }
};

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-router/index.js
var __decorate5 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mRouter = class W3mRouter2 extends LitElement {
  constructor() {
    super();
    this.resizeObserver = void 0;
    this.prevHeight = "0px";
    this.prevHistoryLength = 1;
    this.unsubscribe = [];
    this.view = RouterController.state.view;
    this.viewDirection = "";
    this.unsubscribe.push(RouterController.subscribeKey("view", (val) => this.onViewChange(val)));
  }
  firstUpdated() {
    this.resizeObserver = new ResizeObserver(([content]) => {
      const height = `${content == null ? void 0 : content.contentRect.height}px`;
      if (this.prevHeight !== "0px") {
        this.style.setProperty("--prev-height", this.prevHeight);
        this.style.setProperty("--new-height", height);
        this.style.animation = "w3m-view-height 150ms forwards ease";
        this.style.height = "auto";
      }
      setTimeout(() => {
        this.prevHeight = height;
        this.style.animation = "unset";
      }, ConstantsUtil4.ANIMATION_DURATIONS.ModalHeight);
    });
    this.resizeObserver.observe(this.getWrapper());
  }
  disconnectedCallback() {
    var _a;
    (_a = this.resizeObserver) == null ? void 0 : _a.unobserve(this.getWrapper());
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`<div class="w3m-router-container" view-direction="${this.viewDirection}">
      ${this.viewTemplate()}
    </div>`;
  }
  viewTemplate() {
    switch (this.view) {
      case "AccountSettings":
        return html`<w3m-account-settings-view></w3m-account-settings-view>`;
      case "Account":
        return html`<w3m-account-view></w3m-account-view>`;
      case "AllWallets":
        return html`<w3m-all-wallets-view></w3m-all-wallets-view>`;
      case "ApproveTransaction":
        return html`<w3m-approve-transaction-view></w3m-approve-transaction-view>`;
      case "BuyInProgress":
        return html`<w3m-buy-in-progress-view></w3m-buy-in-progress-view>`;
      case "ChooseAccountName":
        return html`<w3m-choose-account-name-view></w3m-choose-account-name-view>`;
      case "Connect":
        return html`<w3m-connect-view></w3m-connect-view>`;
      case "Create":
        return html`<w3m-connect-view walletGuide="explore"></w3m-connect-view>`;
      case "ConnectingWalletConnect":
        return html`<w3m-connecting-wc-view></w3m-connecting-wc-view>`;
      case "ConnectingExternal":
        return html`<w3m-connecting-external-view></w3m-connecting-external-view>`;
      case "ConnectingSiwe":
        return html`<w3m-connecting-siwe-view></w3m-connecting-siwe-view>`;
      case "ConnectWallets":
        return html`<w3m-connect-wallets-view></w3m-connect-wallets-view>`;
      case "ConnectSocials":
        return html`<w3m-connect-socials-view></w3m-connect-socials-view>`;
      case "ConnectingSocial":
        return html`<w3m-connecting-social-view></w3m-connecting-social-view>`;
      case "Downloads":
        return html`<w3m-downloads-view></w3m-downloads-view>`;
      case "EmailVerifyOtp":
        return html`<w3m-email-verify-otp-view></w3m-email-verify-otp-view>`;
      case "EmailVerifyDevice":
        return html`<w3m-email-verify-device-view></w3m-email-verify-device-view>`;
      case "GetWallet":
        return html`<w3m-get-wallet-view></w3m-get-wallet-view>`;
      case "Networks":
        return html`<w3m-networks-view></w3m-networks-view>`;
      case "SwitchNetwork":
        return html`<w3m-network-switch-view></w3m-network-switch-view>`;
      case "Profile":
        return html`<w3m-profile-view></w3m-profile-view>`;
      case "SwitchAddress":
        return html`<w3m-switch-address-view></w3m-switch-address-view>`;
      case "Transactions":
        return html`<w3m-transactions-view></w3m-transactions-view>`;
      case "OnRampProviders":
        return html`<w3m-onramp-providers-view></w3m-onramp-providers-view>`;
      case "OnRampActivity":
        return html`<w3m-onramp-activity-view></w3m-onramp-activity-view>`;
      case "OnRampTokenSelect":
        return html`<w3m-onramp-token-select-view></w3m-onramp-token-select-view>`;
      case "OnRampFiatSelect":
        return html`<w3m-onramp-fiat-select-view></w3m-onramp-fiat-select-view>`;
      case "UpgradeEmailWallet":
        return html`<w3m-upgrade-wallet-view></w3m-upgrade-wallet-view>`;
      case "UpgradeToSmartAccount":
        return html`<w3m-upgrade-to-smart-account-view></w3m-upgrade-to-smart-account-view>`;
      case "UpdateEmailWallet":
        return html`<w3m-update-email-wallet-view></w3m-update-email-wallet-view>`;
      case "UpdateEmailPrimaryOtp":
        return html`<w3m-update-email-primary-otp-view></w3m-update-email-primary-otp-view>`;
      case "UpdateEmailSecondaryOtp":
        return html`<w3m-update-email-secondary-otp-view></w3m-update-email-secondary-otp-view>`;
      case "UnsupportedChain":
        return html`<w3m-unsupported-chain-view></w3m-unsupported-chain-view>`;
      case "Swap":
        return html`<w3m-swap-view></w3m-swap-view>`;
      case "SwapSelectToken":
        return html`<w3m-swap-select-token-view></w3m-swap-select-token-view>`;
      case "SwapPreview":
        return html`<w3m-swap-preview-view></w3m-swap-preview-view>`;
      case "WalletSend":
        return html`<w3m-wallet-send-view></w3m-wallet-send-view>`;
      case "WalletSendSelectToken":
        return html`<w3m-wallet-send-select-token-view></w3m-wallet-send-select-token-view>`;
      case "WalletSendPreview":
        return html`<w3m-wallet-send-preview-view></w3m-wallet-send-preview-view>`;
      case "WhatIsABuy":
        return html`<w3m-what-is-a-buy-view></w3m-what-is-a-buy-view>`;
      case "WalletReceive":
        return html`<w3m-wallet-receive-view></w3m-wallet-receive-view>`;
      case "WalletCompatibleNetworks":
        return html`<w3m-wallet-compatible-networks-view></w3m-wallet-compatible-networks-view>`;
      case "WhatIsAWallet":
        return html`<w3m-what-is-a-wallet-view></w3m-what-is-a-wallet-view>`;
      case "ConnectingMultiChain":
        return html`<w3m-connecting-multi-chain-view></w3m-connecting-multi-chain-view>`;
      case "WhatIsANetwork":
        return html`<w3m-what-is-a-network-view></w3m-what-is-a-network-view>`;
      case "ConnectingFarcaster":
        return html`<w3m-connecting-farcaster-view></w3m-connecting-farcaster-view>`;
      case "SwitchActiveChain":
        return html`<w3m-switch-active-chain-view></w3m-switch-active-chain-view>`;
      case "RegisterAccountName":
        return html`<w3m-register-account-name-view></w3m-register-account-name-view>`;
      case "RegisterAccountNameSuccess":
        return html`<w3m-register-account-name-success-view></w3m-register-account-name-success-view>`;
      case "SmartSessionCreated":
        return html`<w3m-smart-session-created-view></w3m-smart-session-created-view>`;
      case "SmartSessionList":
        return html`<w3m-smart-session-list-view></w3m-smart-session-list-view>`;
      case "SIWXSignMessage":
        return html`<w3m-siwx-sign-message-view></w3m-siwx-sign-message-view>`;
      default:
        return html`<w3m-connect-view></w3m-connect-view>`;
    }
  }
  onViewChange(newView) {
    TooltipController.hide();
    let direction = ConstantsUtil4.VIEW_DIRECTION.Next;
    const { history } = RouterController.state;
    if (history.length < this.prevHistoryLength) {
      direction = ConstantsUtil4.VIEW_DIRECTION.Prev;
    }
    this.prevHistoryLength = history.length;
    this.viewDirection = direction;
    setTimeout(() => {
      this.view = newView;
    }, ConstantsUtil4.ANIMATION_DURATIONS.ViewTransition);
  }
  getWrapper() {
    var _a;
    return (_a = this.shadowRoot) == null ? void 0 : _a.querySelector("div");
  }
};
W3mRouter.styles = styles_default3;
__decorate5([
  state()
], W3mRouter.prototype, "view", void 0);
__decorate5([
  state()
], W3mRouter.prototype, "viewDirection", void 0);
W3mRouter = __decorate5([
  customElement("w3m-router")
], W3mRouter);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-onramp-widget/styles.js
var styles_default4 = css`
  :host > wui-flex {
    width: 100%;
    max-width: 360px;
  }

  :host > wui-flex > wui-flex {
    border-radius: var(--wui-border-radius-l);
    width: 100%;
  }

  .amounts-container {
    width: 100%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-onramp-widget/index.js
var __decorate6 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var PAYMENT_CURRENCY_SYMBOLS = {
  USD: "$",
  EUR: "€",
  GBP: "£"
};
var BUY_PRESET_AMOUNTS = [100, 250, 500, 1e3];
var W3mOnrampWidget = class W3mOnrampWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.caipAddress = ChainController.state.activeCaipAddress;
    this.loading = ModalController.state.loading;
    this.paymentCurrency = OnRampController.state.paymentCurrency;
    this.paymentAmount = OnRampController.state.paymentAmount;
    this.purchaseAmount = OnRampController.state.purchaseAmount;
    this.quoteLoading = OnRampController.state.quotesLoading;
    this.unsubscribe.push(...[
      ChainController.subscribeKey("activeCaipAddress", (val) => this.caipAddress = val),
      ModalController.subscribeKey("loading", (val) => {
        this.loading = val;
      }),
      OnRampController.subscribe((val) => {
        this.paymentCurrency = val.paymentCurrency;
        this.paymentAmount = val.paymentAmount;
        this.purchaseAmount = val.purchaseAmount;
        this.quoteLoading = val.quotesLoading;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`
      <wui-flex flexDirection="column" justifyContent="center" alignItems="center">
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <w3m-onramp-input
            type="Fiat"
            @inputChange=${this.onPaymentAmountChange.bind(this)}
            .value=${this.paymentAmount || 0}
          ></w3m-onramp-input>
          <w3m-onramp-input
            type="Token"
            .value=${this.purchaseAmount || 0}
            .loading=${this.quoteLoading}
          ></w3m-onramp-input>
          <wui-flex justifyContent="space-evenly" class="amounts-container" gap="xs">
            ${BUY_PRESET_AMOUNTS.map((amount) => {
      var _a;
      return html`<wui-button
                  variant=${this.paymentAmount === amount ? "accent" : "neutral"}
                  size="md"
                  textVariant="paragraph-600"
                  fullWidth
                  @click=${() => this.selectPresetAmount(amount)}
                  >${`${PAYMENT_CURRENCY_SYMBOLS[((_a = this.paymentCurrency) == null ? void 0 : _a.id) || "USD"]} ${amount}`}</wui-button
                >`;
    })}
          </wui-flex>
          ${this.templateButton()}
        </wui-flex>
      </wui-flex>
    `;
  }
  templateButton() {
    return this.caipAddress ? html`<wui-button
          @click=${this.getQuotes.bind(this)}
          variant="main"
          fullWidth
          size="lg"
          borderRadius="xs"
        >
          Get quotes
        </wui-button>` : html`<wui-button
          @click=${this.openModal.bind(this)}
          variant="accent"
          fullWidth
          size="lg"
          borderRadius="xs"
        >
          Connect wallet
        </wui-button>`;
  }
  getQuotes() {
    if (!this.loading) {
      ModalController.open({ view: "OnRampProviders" });
    }
  }
  openModal() {
    ModalController.open({ view: "Connect" });
  }
  async onPaymentAmountChange(event) {
    OnRampController.setPaymentAmount(Number(event.detail));
    await OnRampController.getQuote();
  }
  async selectPresetAmount(amount) {
    OnRampController.setPaymentAmount(amount);
    await OnRampController.getQuote();
  }
};
W3mOnrampWidget.styles = styles_default4;
__decorate6([
  property({ type: Boolean })
], W3mOnrampWidget.prototype, "disabled", void 0);
__decorate6([
  state()
], W3mOnrampWidget.prototype, "caipAddress", void 0);
__decorate6([
  state()
], W3mOnrampWidget.prototype, "loading", void 0);
__decorate6([
  state()
], W3mOnrampWidget.prototype, "paymentCurrency", void 0);
__decorate6([
  state()
], W3mOnrampWidget.prototype, "paymentAmount", void 0);
__decorate6([
  state()
], W3mOnrampWidget.prototype, "purchaseAmount", void 0);
__decorate6([
  state()
], W3mOnrampWidget.prototype, "quoteLoading", void 0);
W3mOnrampWidget = __decorate6([
  customElement("w3m-onramp-widget")
], W3mOnrampWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-account-settings-view/index.js
var __decorate7 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAccountSettingsView = class W3mAccountSettingsView2 extends LitElement {
  constructor() {
    super();
    this.usubscribe = [];
    this.networkImages = AssetController.state.networkImages;
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.network = ChainController.state.activeCaipNetwork;
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.disconnecting = false;
    this.loading = false;
    this.switched = false;
    this.text = "";
    this.usubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileImage = val.profileImage;
          this.profileName = val.profileName;
          this.preferredAccountType = val.preferredAccountType;
        } else {
          ModalController.close();
        }
      }),
      AccountController.subscribeKey("preferredAccountType", (val) => this.preferredAccountType = val),
      ChainController.subscribeKey("activeCaipNetwork", (val) => {
        if (val == null ? void 0 : val.id) {
          this.network = val;
        }
      })
    ]);
  }
  disconnectedCallback() {
    this.usubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a, _b, _c;
    if (!this.address) {
      throw new Error("w3m-account-settings-view: No account provided");
    }
    const networkImage = this.networkImages[((_b = (_a = this.network) == null ? void 0 : _a.assets) == null ? void 0 : _b.imageId) ?? ""];
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="l"
        .padding=${["0", "xl", "m", "xl"]}
      >
        <wui-avatar
          alt=${this.address}
          address=${this.address}
          imageSrc=${ifDefined(this.profileImage)}
          size="2lg"
        ></wui-avatar>
        <wui-flex flexDirection="column" alignItems="center">
          <wui-flex gap="3xs" alignItems="center" justifyContent="center">
            <wui-text variant="title-6-600" color="fg-100" data-testid="account-settings-address">
              ${UiHelperUtil.getTruncateString({
      string: this.address,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}
            </wui-text>
            <wui-icon-link
              size="md"
              icon="copy"
              iconColor="fg-200"
              @click=${this.onCopyAddress}
            ></wui-icon-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>
      <wui-flex flexDirection="column" gap="m">
        <wui-flex flexDirection="column" gap="xs" .padding=${["0", "l", "m", "l"]}>
          ${this.authCardTemplate()}
          <w3m-account-auth-button></w3m-account-auth-button>
          <wui-list-item
            .variant=${networkImage ? "image" : "icon"}
            iconVariant="overlay"
            icon="networkPlaceholder"
            imageSrc=${ifDefined(networkImage)}
            ?chevron=${this.isAllowedNetworkSwitch()}
            @click=${this.onNetworks.bind(this)}
            data-testid="account-switch-network-button"
          >
            <wui-text variant="paragraph-500" color="fg-100">
              ${((_c = this.network) == null ? void 0 : _c.name) ?? "Unknown"}
            </wui-text>
          </wui-list-item>
          ${this.togglePreferredAccountBtnTemplate()} ${this.chooseNameButtonTemplate()}
          <wui-list-item
            variant="icon"
            iconVariant="overlay"
            icon="disconnect"
            ?chevron=${false}
            .loading=${this.disconnecting}
            @click=${this.onDisconnect.bind(this)}
            data-testid="disconnect-button"
          >
            <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
          </wui-list-item>
        </wui-flex>
      </wui-flex>
    `;
  }
  chooseNameButtonTemplate() {
    const type = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    const hasNetworkSupport = ChainController.checkIfNamesSupported();
    if (!hasNetworkSupport || !authConnector || type !== "ID_AUTH" || this.profileName) {
      return null;
    }
    return html`
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="id"
        iconSize="sm"
        ?chevron=${true}
        @click=${this.onChooseName.bind(this)}
        data-testid="account-choose-name-button"
      >
        <wui-text variant="paragraph-500" color="fg-100">Choose account name </wui-text>
      </wui-list-item>
    `;
  }
  authCardTemplate() {
    const type = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    const { origin } = location;
    if (!authConnector || type !== "ID_AUTH" || origin.includes(ConstantsUtil2.SECURE_SITE)) {
      return null;
    }
    return html`
      <wui-notice-card
        @click=${this.onGoToUpgradeView.bind(this)}
        label="Upgrade your wallet"
        description="Transition to a self-custodial wallet"
        icon="wallet"
        data-testid="w3m-wallet-upgrade-card"
      ></wui-notice-card>
    `;
  }
  isAllowedNetworkSwitch() {
    const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const isMultiNetwork = requestedCaipNetworks ? requestedCaipNetworks.length > 1 : false;
    const isValidNetwork = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.find(({ id }) => {
      var _a;
      return id === ((_a = this.network) == null ? void 0 : _a.id);
    });
    return isMultiNetwork || !isValidNetwork;
  }
  onCopyAddress() {
    try {
      if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
  togglePreferredAccountBtnTemplate() {
    const networkEnabled = ChainController.checkIfSmartAccountEnabled();
    const type = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector || type !== "ID_AUTH" || !networkEnabled) {
      return null;
    }
    if (!this.switched) {
      this.text = this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT ? "Switch to your EOA" : "Switch to your smart account";
    }
    return html`
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="swapHorizontalBold"
        iconSize="sm"
        ?chevron=${true}
        ?loading=${this.loading}
        @click=${this.changePreferredAccountType.bind(this)}
        data-testid="account-toggle-preferred-account-type"
      >
        <wui-text variant="paragraph-500" color="fg-100">${this.text}</wui-text>
      </wui-list-item>
    `;
  }
  onChooseName() {
    RouterController.push("ChooseAccountName");
  }
  async changePreferredAccountType() {
    const smartAccountEnabled = ChainController.checkIfSmartAccountEnabled();
    const accountTypeTarget = this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT || !smartAccountEnabled ? W3mFrameRpcConstants.ACCOUNT_TYPES.EOA : W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT;
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector) {
      return;
    }
    this.loading = true;
    await ConnectionController.setPreferredAccountType(accountTypeTarget);
    this.text = accountTypeTarget === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT ? "Switch to your EOA" : "Switch to your smart account";
    this.switched = true;
    SendController.resetSend();
    this.loading = false;
    this.requestUpdate();
  }
  onNetworks() {
    if (this.isAllowedNetworkSwitch()) {
      RouterController.push("Networks");
    }
  }
  async onDisconnect() {
    try {
      this.disconnecting = true;
      await ConnectionController.disconnect();
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_SUCCESS" });
      ModalController.close();
    } catch {
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_ERROR" });
      SnackController.showError("Failed to disconnect");
    } finally {
      this.disconnecting = false;
    }
  }
  onGoToUpgradeView() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_UPGRADE_FROM_MODAL" });
    RouterController.push("UpgradeEmailWallet");
  }
};
__decorate7([
  state()
], W3mAccountSettingsView.prototype, "address", void 0);
__decorate7([
  state()
], W3mAccountSettingsView.prototype, "profileImage", void 0);
__decorate7([
  state()
], W3mAccountSettingsView.prototype, "profileName", void 0);
__decorate7([
  state()
], W3mAccountSettingsView.prototype, "network", void 0);
__decorate7([
  state()
], W3mAccountSettingsView.prototype, "preferredAccountType", void 0);
__decorate7([
  state()
], W3mAccountSettingsView.prototype, "disconnecting", void 0);
__decorate7([
  state()
], W3mAccountSettingsView.prototype, "loading", void 0);
__decorate7([
  state()
], W3mAccountSettingsView.prototype, "switched", void 0);
__decorate7([
  state()
], W3mAccountSettingsView.prototype, "text", void 0);
W3mAccountSettingsView = __decorate7([
  customElement("w3m-account-settings-view")
], W3mAccountSettingsView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-account-view/index.js
var __decorate8 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAccountView = class W3mAccountView2 extends LitElement {
  render() {
    const connectedConnectorType = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    return html`
      ${authConnector && connectedConnectorType === "ID_AUTH" ? this.walletFeaturesTemplate() : this.defaultTemplate()}
    `;
  }
  walletFeaturesTemplate() {
    return html`<w3m-account-wallet-features-widget></w3m-account-wallet-features-widget>`;
  }
  defaultTemplate() {
    return html`<w3m-account-default-widget></w3m-account-default-widget>`;
  }
};
W3mAccountView = __decorate8([
  customElement("w3m-account-view")
], W3mAccountView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-all-wallets-view/index.js
var __decorate9 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAllWalletsView = class W3mAllWalletsView2 extends LitElement {
  constructor() {
    super(...arguments);
    this.search = "";
    this.onDebouncedSearch = CoreHelperUtil.debounce((value) => {
      this.search = value;
    });
  }
  render() {
    const isSearch = this.search.length >= 2;
    return html`
      <wui-flex .padding=${["0", "s", "s", "s"]} gap="xs">
        <wui-search-bar @inputChange=${this.onInputChange.bind(this)}></wui-search-bar>
        <wui-certified-switch
          ?checked=${this.badge}
          @click=${this.onClick.bind(this)}
          data-testid="wui-certified-switch"
        ></wui-certified-switch>
        ${this.qrButtonTemplate()}
      </wui-flex>
      ${isSearch || this.badge ? html`<w3m-all-wallets-search
            query=${this.search}
            badge=${ifDefined(this.badge)}
          ></w3m-all-wallets-search>` : html`<w3m-all-wallets-list badge=${ifDefined(this.badge)}></w3m-all-wallets-list>`}
    `;
  }
  onInputChange(event) {
    this.onDebouncedSearch(event.detail);
  }
  onClick() {
    if (this.badge === "certified") {
      this.badge = void 0;
      return;
    }
    this.badge = "certified";
    SnackController.showSvg("Only WalletConnect certified", {
      icon: "walletConnectBrown",
      iconColor: "accent-100"
    });
  }
  qrButtonTemplate() {
    if (CoreHelperUtil.isMobile()) {
      return html`
        <wui-icon-box
          size="lg"
          iconSize="xl"
          iconColor="accent-100"
          backgroundColor="accent-100"
          icon="qrCode"
          background="transparent"
          border
          borderColor="wui-accent-glass-010"
          @click=${this.onWalletConnectQr.bind(this)}
        ></wui-icon-box>
      `;
    }
    return null;
  }
  onWalletConnectQr() {
    RouterController.push("ConnectingWalletConnect");
  }
};
__decorate9([
  state()
], W3mAllWalletsView.prototype, "search", void 0);
__decorate9([
  state()
], W3mAllWalletsView.prototype, "badge", void 0);
W3mAllWalletsView = __decorate9([
  customElement("w3m-all-wallets-view")
], W3mAllWalletsView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-buy-in-progress-view/styles.js
var styles_default5 = css`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-visual {
    width: var(--wui-wallet-image-size-lg);
    height: var(--wui-wallet-image-size-lg);
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    position: relative;
    overflow: hidden;
  }

  wui-visual::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition:
      opacity var(--wui-ease-out-power-2) var(--wui-duration-lg),
      transform var(--wui-ease-out-power-2) var(--wui-duration-lg);
    will-change: opacity, transform;
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }

  wui-link {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-buy-in-progress-view/index.js
var __decorate10 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mBuyInProgressView = class W3mBuyInProgressView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedOnRampProvider = OnRampController.state.selectedProvider;
    this.uri = ConnectionController.state.wcUri;
    this.ready = false;
    this.showRetry = false;
    this.buffering = false;
    this.error = false;
    this.startTime = null;
    this.isMobile = false;
    this.onRetry = void 0;
    this.unsubscribe.push(...[
      OnRampController.subscribeKey("selectedProvider", (val) => {
        this.selectedOnRampProvider = val;
      })
    ]);
    this.watchTransactions();
  }
  disconnectedCallback() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
    }
  }
  render() {
    var _a, _b;
    let label = "Continue in external window";
    if (this.error) {
      label = "Buy failed";
    } else if (this.selectedOnRampProvider) {
      label = `Buy in ${(_a = this.selectedOnRampProvider) == null ? void 0 : _a.label}`;
    }
    const subLabel = this.error ? "Buy can be declined from your side or due to and error on the provider app" : `We’ll notify you once your Buy is processed`;
    return html`
      <wui-flex
        data-error=${ifDefined(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-visual
            name=${ifDefined((_b = this.selectedOnRampProvider) == null ? void 0 : _b.name)}
            size="lg"
            class="provider-image"
          >
          </wui-visual>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${this.error ? "error-100" : "fg-100"}>
            ${label}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        ${this.error ? this.tryAgainTemplate() : null}
      </wui-flex>

      <wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
        <wui-link @click=${this.onCopyUri} color="fg-200">
          <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
          Copy link
        </wui-link>
      </wui-flex>
    `;
  }
  watchTransactions() {
    if (!this.selectedOnRampProvider) {
      return;
    }
    switch (this.selectedOnRampProvider.name) {
      case "coinbase":
        this.startTime = Date.now();
        this.initializeCoinbaseTransactions();
        break;
      default:
        break;
    }
  }
  async initializeCoinbaseTransactions() {
    await this.watchCoinbaseTransactions();
    this.intervalId = setInterval(() => this.watchCoinbaseTransactions(), 4e3);
  }
  async watchCoinbaseTransactions() {
    try {
      const address = AccountController.state.address;
      const projectId = OptionsController.state.projectId;
      if (!address) {
        throw new Error("No address found");
      }
      const coinbaseResponse = await BlockchainApiController.fetchTransactions({
        account: address,
        onramp: "coinbase",
        projectId
      });
      const newTransactions = coinbaseResponse.data.filter((tx) => new Date(tx.metadata.minedAt) > new Date(this.startTime) || tx.metadata.status === "ONRAMP_TRANSACTION_STATUS_IN_PROGRESS");
      if (newTransactions.length) {
        clearInterval(this.intervalId);
        RouterController.replace("OnRampActivity");
      } else if (this.startTime && Date.now() - this.startTime >= 18e4) {
        clearInterval(this.intervalId);
        this.error = true;
      }
    } catch (error) {
      SnackController.showError(error);
    }
  }
  onTryAgain() {
    if (!this.selectedOnRampProvider) {
      return;
    }
    this.error = false;
    CoreHelperUtil.openHref(this.selectedOnRampProvider.url, "popupWindow", "width=600,height=800,scrollbars=yes");
  }
  tryAgainTemplate() {
    var _a;
    if (!((_a = this.selectedOnRampProvider) == null ? void 0 : _a.url)) {
      return null;
    }
    return html`<wui-button size="md" variant="accent" @click=${this.onTryAgain.bind(this)}>
      <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
      Try again
    </wui-button>`;
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return html`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  onCopyUri() {
    var _a;
    if (!((_a = this.selectedOnRampProvider) == null ? void 0 : _a.url)) {
      SnackController.showError("No link found");
      RouterController.goBack();
      return;
    }
    try {
      CoreHelperUtil.copyToClopboard(this.selectedOnRampProvider.url);
      SnackController.showSuccess("Link copied");
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mBuyInProgressView.styles = styles_default5;
__decorate10([
  state()
], W3mBuyInProgressView.prototype, "intervalId", void 0);
__decorate10([
  state()
], W3mBuyInProgressView.prototype, "selectedOnRampProvider", void 0);
__decorate10([
  state()
], W3mBuyInProgressView.prototype, "uri", void 0);
__decorate10([
  state()
], W3mBuyInProgressView.prototype, "ready", void 0);
__decorate10([
  state()
], W3mBuyInProgressView.prototype, "showRetry", void 0);
__decorate10([
  state()
], W3mBuyInProgressView.prototype, "buffering", void 0);
__decorate10([
  state()
], W3mBuyInProgressView.prototype, "error", void 0);
__decorate10([
  state()
], W3mBuyInProgressView.prototype, "startTime", void 0);
__decorate10([
  property({ type: Boolean })
], W3mBuyInProgressView.prototype, "isMobile", void 0);
__decorate10([
  property()
], W3mBuyInProgressView.prototype, "onRetry", void 0);
W3mBuyInProgressView = __decorate10([
  customElement("w3m-buy-in-progress-view")
], W3mBuyInProgressView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connect-view/styles.js
var styles_default6 = css`
  :host {
    --connect-scroll--top-opacity: 0;
    --connect-scroll--bottom-opacity: 0;
  }

  .connect {
    max-height: clamp(360px, 470px, 80vh);
    scrollbar-width: none;
    overflow-y: scroll;
    overflow-x: hidden;
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
    mask-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, calc(1 - var(--connect-scroll--top-opacity))) 0px,
      rgba(200, 200, 200, calc(1 - var(--connect-scroll--top-opacity))) 1px,
      black 40px,
      black calc(100% - 40px),
      rgba(155, 155, 155, calc(1 - var(--connect-scroll--bottom-opacity))) calc(100% - 1px),
      rgba(0, 0, 0, calc(1 - var(--connect-scroll--bottom-opacity))) 100%
    );
  }

  .guide {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
  }

  .connect::-webkit-scrollbar {
    display: none;
  }

  .all-wallets {
    flex-flow: column;
  }

  .connect.disabled,
  .guide.disabled {
    opacity: 0.3;
    pointer-events: none;
    user-select: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connect-view/index.js
var __decorate11 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectView = class W3mConnectView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.authConnector = this.connectors.find((c5) => c5.type === "AUTH");
    this.features = OptionsController.state.features;
    this.walletGuide = "get-started";
    this.checked = false;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => {
      this.connectors = val;
      this.authConnector = this.connectors.find((c5) => c5.type === "AUTH");
    }), OptionsController.subscribeKey("features", (val) => this.features = val));
  }
  disconnectedCallback() {
    var _a;
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    const connectEl = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector(".connect");
    connectEl == null ? void 0 : connectEl.removeEventListener("scroll", this.handleConnectListScroll.bind(this));
  }
  firstUpdated() {
    var _a;
    const connectEl = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector(".connect");
    requestAnimationFrame(this.handleConnectListScroll.bind(this));
    connectEl == null ? void 0 : connectEl.addEventListener("scroll", this.handleConnectListScroll.bind(this));
  }
  render() {
    var _a, _b;
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    const legalCheckbox = (_a = OptionsController.state.features) == null ? void 0 : _a.legalCheckbox;
    const legalUrl = termsConditionsUrl || privacyPolicyUrl;
    const showLegalCheckbox = Boolean(legalUrl) && Boolean(legalCheckbox) && this.walletGuide === "get-started";
    const disabled = showLegalCheckbox && !this.checked;
    const classes = {
      connect: true,
      disabled
    };
    const socials = (_b = this.features) == null ? void 0 : _b.socials;
    const enableWallets = OptionsController.state.enableWallets;
    const socialsExist = socials && socials.length;
    const socialOrEmailLoginEnabled = socialsExist || this.authConnector;
    const tabIndex = disabled ? -1 : void 0;
    return html`
      <wui-flex flexDirection="column">
        ${this.legalCheckboxTemplate()}
        <wui-flex flexDirection="column" class=${classMap(classes)}>
          <wui-flex
            flexDirection="column"
            .padding=${socialOrEmailLoginEnabled && enableWallets && this.walletGuide === "get-started" ? ["3xs", "s", "0", "s"] : ["3xs", "s", "s", "s"]}
          >
            <w3m-email-login-widget
              walletGuide=${this.walletGuide}
              tabIdx=${ifDefined(tabIndex)}
            ></w3m-email-login-widget>
            <w3m-social-login-widget tabIdx=${ifDefined(tabIndex)}></w3m-social-login-widget>
            ${this.walletListTemplate(tabIndex)}
          </wui-flex>
        </wui-flex>
        ${this.guideTemplate(disabled)}
        <w3m-legal-footer></w3m-legal-footer>
      </wui-flex>
    `;
  }
  walletListTemplate(tabIndex) {
    var _a, _b;
    const socials = (_a = this.features) == null ? void 0 : _a.socials;
    const emailShowWallets = (_b = this.features) == null ? void 0 : _b.emailShowWallets;
    const enableWallets = OptionsController.state.enableWallets;
    if (!enableWallets) {
      return null;
    }
    if (CoreHelperUtil.isTelegram() && CoreHelperUtil.isIos()) {
      ConnectionController.connectWalletConnect().catch((_e3) => ({}));
    }
    if (this.walletGuide === "explore") {
      return null;
    }
    if (this.authConnector && socials) {
      if (this.authConnector && emailShowWallets) {
        return html`
          <wui-flex flexDirection="column" gap="xs" .margin=${["xs", "0", "0", "0"]}>
            <w3m-connector-list tabIdx=${ifDefined(tabIndex)}></w3m-connector-list>
            <wui-flex class="all-wallets">
              <w3m-all-wallets-widget tabIdx=${ifDefined(tabIndex)}></w3m-all-wallets-widget>
            </wui-flex>
          </wui-flex>
        `;
      }
      return html`<wui-list-button
        tabIdx=${ifDefined(tabIndex)}
        @click=${this.onContinueWalletClick.bind(this)}
        text="Continue with a wallet"
      ></wui-list-button>`;
    }
    return html`<w3m-wallet-login-list tabIdx=${ifDefined(tabIndex)}></w3m-wallet-login-list>`;
  }
  guideTemplate(disabled = false) {
    var _a;
    const socials = (_a = this.features) == null ? void 0 : _a.socials;
    const enableWallets = OptionsController.state.enableWallets;
    const socialsExist = socials && socials.length;
    const classes = {
      guide: true,
      disabled
    };
    const tabIndex = disabled ? -1 : void 0;
    if (!this.authConnector && !socialsExist) {
      return null;
    }
    if (!enableWallets) {
      return null;
    }
    if (this.walletGuide === "explore") {
      return html`
        <wui-flex
          flexDirection="column"
          .padding=${["0", "0", "xl", "0"]}
          class=${classMap(classes)}
        >
          <w3m-wallet-guide walletGuide=${this.walletGuide}></w3m-wallet-guide>
        </wui-flex>
      `;
    }
    return html`
      <wui-flex
        flexDirection="column"
        .padding=${["xl", "0", "xl", "0"]}
        class=${classMap(classes)}
      >
        <w3m-wallet-guide
          tabIdx=${ifDefined(tabIndex)}
          walletGuide=${this.walletGuide}
        ></w3m-wallet-guide>
      </wui-flex>
    `;
  }
  legalCheckboxTemplate() {
    if (this.walletGuide === "explore") {
      return null;
    }
    return html`<w3m-legal-checkbox
      @checkboxChange=${this.onCheckboxChange.bind(this)}
      data-testid="w3m-legal-checkbox"
    ></w3m-legal-checkbox>`;
  }
  handleConnectListScroll() {
    var _a;
    const connectEl = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector(".connect");
    if (!connectEl || connectEl.scrollHeight <= 470) {
      return;
    }
    connectEl.style.setProperty("--connect-scroll--top-opacity", MathUtil.interpolate([0, 50], [0, 1], connectEl.scrollTop).toString());
    connectEl.style.setProperty("--connect-scroll--bottom-opacity", MathUtil.interpolate([0, 50], [0, 1], connectEl.scrollHeight - connectEl.scrollTop - connectEl.offsetHeight).toString());
  }
  onContinueWalletClick() {
    RouterController.push("ConnectWallets");
  }
  onCheckboxChange(event) {
    this.checked = Boolean(event.detail);
  }
};
W3mConnectView.styles = styles_default6;
__decorate11([
  state()
], W3mConnectView.prototype, "connectors", void 0);
__decorate11([
  state()
], W3mConnectView.prototype, "authConnector", void 0);
__decorate11([
  state()
], W3mConnectView.prototype, "features", void 0);
__decorate11([
  property()
], W3mConnectView.prototype, "walletGuide", void 0);
__decorate11([
  state()
], W3mConnectView.prototype, "checked", void 0);
W3mConnectView = __decorate11([
  customElement("w3m-connect-view")
], W3mConnectView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/w3m-connecting-widget/styles.js
var styles_default7 = css`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition-property: opacity, transform;
    transition-duration: var(--wui-duration-lg);
    transition-timing-function: var(--wui-ease-out-power-2);
    will-change: opacity, transform;
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/w3m-connecting-widget/index.js
var __decorate12 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingWidget = class extends LitElement {
  constructor() {
    var _a, _b, _c, _d, _e3;
    super();
    this.wallet = (_a = RouterController.state.data) == null ? void 0 : _a.wallet;
    this.connector = (_b = RouterController.state.data) == null ? void 0 : _b.connector;
    this.timeout = void 0;
    this.secondaryBtnIcon = "refresh";
    this.onConnect = void 0;
    this.onRender = void 0;
    this.onAutoConnect = void 0;
    this.isWalletConnect = true;
    this.unsubscribe = [];
    this.imageSrc = AssetUtil.getWalletImage(this.wallet) ?? AssetUtil.getConnectorImage(this.connector);
    this.name = ((_c = this.wallet) == null ? void 0 : _c.name) ?? ((_d = this.connector) == null ? void 0 : _d.name) ?? "Wallet";
    this.isRetrying = false;
    this.uri = ConnectionController.state.wcUri;
    this.error = ConnectionController.state.wcError;
    this.ready = false;
    this.showRetry = false;
    this.secondaryBtnLabel = "Try again";
    this.secondaryLabel = "Accept connection request in the wallet";
    this.buffering = false;
    this.isMobile = false;
    this.onRetry = void 0;
    this.unsubscribe.push(...[
      ConnectionController.subscribeKey("wcUri", (val) => {
        var _a2;
        this.uri = val;
        if (this.isRetrying && this.onRetry) {
          this.isRetrying = false;
          (_a2 = this.onConnect) == null ? void 0 : _a2.call(this);
        }
      }),
      ConnectionController.subscribeKey("wcError", (val) => this.error = val),
      ConnectionController.subscribeKey("buffering", (val) => this.buffering = val)
    ]);
    if (CoreHelperUtil.isTelegram() && CoreHelperUtil.isIos() && ConnectionController.state.wcUri) {
      (_e3 = this.onConnect) == null ? void 0 : _e3.call(this);
    }
  }
  firstUpdated() {
    var _a;
    (_a = this.onAutoConnect) == null ? void 0 : _a.call(this);
    this.showRetry = !this.onAutoConnect;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    clearTimeout(this.timeout);
  }
  render() {
    var _a;
    (_a = this.onRender) == null ? void 0 : _a.call(this);
    this.onShowRetry();
    const subLabel = this.error ? "Connection can be declined if a previous request is still active" : this.secondaryLabel;
    let label = `Continue in ${this.name}`;
    if (this.buffering) {
      label = "Connecting...";
    }
    if (this.error) {
      label = "Connection declined";
    }
    return html`
      <wui-flex
        data-error=${ifDefined(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-wallet-image size="lg" imageSrc=${ifDefined(this.imageSrc)}></wui-wallet-image>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${this.error ? "error-100" : "fg-100"}>
            ${label}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        ${this.secondaryBtnLabel ? html`
              <wui-button
                variant="accent"
                size="md"
                ?disabled=${this.isRetrying || !this.error && this.buffering}
                @click=${this.onTryAgain.bind(this)}
                data-testid="w3m-connecting-widget-secondary-button"
              >
                <wui-icon color="inherit" slot="iconLeft" name=${this.secondaryBtnIcon}></wui-icon>
                ${this.secondaryBtnLabel}
              </wui-button>
            ` : null}
      </wui-flex>

      ${this.isWalletConnect ? html`
            <wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
              <wui-link @click=${this.onCopyUri} color="fg-200" data-testid="wui-link-copy">
                <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
                Copy link
              </wui-link>
            </wui-flex>
          ` : null}

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
  onShowRetry() {
    var _a;
    if (this.error && !this.showRetry) {
      this.showRetry = true;
      const retryButton = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector("wui-button");
      retryButton == null ? void 0 : retryButton.animate([{ opacity: 0 }, { opacity: 1 }], {
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  onTryAgain() {
    var _a, _b;
    if (!this.buffering) {
      ConnectionController.setWcError(false);
      if (this.onRetry) {
        this.isRetrying = true;
        (_a = this.onRetry) == null ? void 0 : _a.call(this);
      } else {
        (_b = this.onConnect) == null ? void 0 : _b.call(this);
      }
    }
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return html`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  onCopyUri() {
    try {
      if (this.uri) {
        CoreHelperUtil.copyToClopboard(this.uri);
        SnackController.showSuccess("Link copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mConnectingWidget.styles = styles_default7;
__decorate12([
  state()
], W3mConnectingWidget.prototype, "isRetrying", void 0);
__decorate12([
  state()
], W3mConnectingWidget.prototype, "uri", void 0);
__decorate12([
  state()
], W3mConnectingWidget.prototype, "error", void 0);
__decorate12([
  state()
], W3mConnectingWidget.prototype, "ready", void 0);
__decorate12([
  state()
], W3mConnectingWidget.prototype, "showRetry", void 0);
__decorate12([
  state()
], W3mConnectingWidget.prototype, "secondaryBtnLabel", void 0);
__decorate12([
  state()
], W3mConnectingWidget.prototype, "secondaryLabel", void 0);
__decorate12([
  state()
], W3mConnectingWidget.prototype, "buffering", void 0);
__decorate12([
  property({ type: Boolean })
], W3mConnectingWidget.prototype, "isMobile", void 0);
__decorate12([
  property()
], W3mConnectingWidget.prototype, "onRetry", void 0);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-external-view/index.js
var __decorate13 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingExternalView = class W3mConnectingExternalView2 extends W3mConnectingWidget {
  constructor() {
    super();
    this.externalViewUnsubscribe = [];
    if (!this.connector) {
      throw new Error("w3m-connecting-view: No connector provided");
    }
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: {
        name: this.connector.name ?? "Unknown",
        platform: "browser"
      }
    });
    this.onConnect = this.onConnectProxy.bind(this);
    this.onAutoConnect = this.onConnectProxy.bind(this);
    this.isWalletConnect = false;
    this.externalViewUnsubscribe.push(ChainController.subscribeKey("activeCaipAddress", (val) => {
      if (val) {
        ModalController.close();
      }
    }));
  }
  disconnectedCallback() {
    this.externalViewUnsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  async onConnectProxy() {
    try {
      this.error = false;
      if (this.connector) {
        if (this.connector.id !== ConstantsUtil3.COINBASE_SDK_CONNECTOR_ID || !this.error) {
          await ConnectionController.connectExternal(this.connector, this.connector.chain);
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: { method: "browser", name: this.connector.name || "Unknown" }
          });
        }
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (error == null ? void 0 : error.message) ?? "Unknown" }
      });
      this.error = true;
    }
  }
};
W3mConnectingExternalView = __decorate13([
  customElement("w3m-connecting-external-view")
], W3mConnectingExternalView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-multi-chain-view/styles.js
var styles_default8 = css`
  wui-flex,
  wui-list-wallet {
    width: 100%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-multi-chain-view/index.js
var __decorate14 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingMultiChainView = class W3mConnectingMultiChainView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.activeConnector = ChainController.state.activeConnector;
    this.unsubscribe.push(...[ChainController.subscribeKey("activeConnector", (val) => this.activeConnector = val)]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a;
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["m", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-wallet-image
            size="lg"
            imageSrc=${ifDefined(AssetUtil.getConnectorImage(this.activeConnector))}
          ></wui-wallet-image>
        </wui-flex>
        <wui-flex
          flexDirection="column"
          alignItems="center"
          gap="xs"
          .padding=${["0", "s", "0", "s"]}
        >
          <wui-text variant="paragraph-500" color="fg-100">
            Select Chain for ${(_a = this.activeConnector) == null ? void 0 : _a.name}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200"
            >Select which chain to connect to your multi chain wallet</wui-text
          >
        </wui-flex>
        <wui-flex
          flexGrow="1"
          flexDirection="column"
          alignItems="center"
          gap="xs"
          .padding=${["xs", "0", "xs", "0"]}
        >
          ${this.networksTemplate()}
        </wui-flex>
      </wui-flex>
    `;
  }
  networksTemplate() {
    var _a, _b;
    return (_b = (_a = this.activeConnector) == null ? void 0 : _a.connectors) == null ? void 0 : _b.map((connector) => connector.name ? html`
            <wui-list-wallet
              imageSrc=${ifDefined(AssetUtil.getChainImage(connector.chain))}
              name=${ConstantsUtil.CHAIN_NAME_MAP[connector.chain]}
              @click=${() => this.onConnector(connector)}
            ></wui-list-wallet>
          ` : null);
  }
  onConnector(provider) {
    var _a, _b;
    const connector = (_b = (_a = this.activeConnector) == null ? void 0 : _a.connectors) == null ? void 0 : _b.find((p4) => p4.chain === provider.chain);
    if (!connector) {
      SnackController.showError("Failed to find connector");
      return;
    }
    if (connector.id === "walletConnect") {
      if (CoreHelperUtil.isMobile()) {
        RouterController.push("AllWallets");
      } else {
        RouterController.push("ConnectingWalletConnect");
      }
    } else {
      RouterController.push("ConnectingExternal", {
        connector
      });
    }
  }
};
W3mConnectingMultiChainView.styles = styles_default8;
__decorate14([
  state()
], W3mConnectingMultiChainView.prototype, "activeConnector", void 0);
W3mConnectingMultiChainView = __decorate14([
  customElement("w3m-connecting-multi-chain-view")
], W3mConnectingMultiChainView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-wc-view/index.js
var __decorate15 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingWcView = class W3mConnectingWcView2 extends LitElement {
  constructor() {
    var _a;
    super();
    this.interval = void 0;
    this.lastRetry = Date.now();
    this.wallet = (_a = RouterController.state.data) == null ? void 0 : _a.wallet;
    this.platform = void 0;
    this.platforms = [];
    this.isSiweEnabled = OptionsController.state.isSiweEnabled;
    this.determinePlatforms();
    this.initializeConnection();
    this.interval = setInterval(this.initializeConnection.bind(this), ConstantsUtil2.TEN_SEC_MS);
  }
  disconnectedCallback() {
    clearTimeout(this.interval);
  }
  render() {
    if (!this.wallet) {
      return html`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
    }
    return html`
      ${this.headerTemplate()}
      <div>${this.platformTemplate()}</div>
    `;
  }
  async initializeConnection(retry = false) {
    if (this.platform === "browser") {
      return;
    }
    try {
      const { wcPairingExpiry, status } = ConnectionController.state;
      if (retry || CoreHelperUtil.isPairingExpired(wcPairingExpiry) || status === "connecting") {
        await ConnectionController.connectWalletConnect();
        this.finalizeConnection();
        if (!this.isSiweEnabled) {
          ModalController.close();
        }
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (error == null ? void 0 : error.message) ?? "Unknown" }
      });
      ConnectionController.setWcError(true);
      if (CoreHelperUtil.isAllowedRetry(this.lastRetry)) {
        SnackController.showError(error.message ?? "Declined");
        this.lastRetry = Date.now();
        this.initializeConnection(true);
      } else {
        SnackController.showError(error.message ?? "Connection error");
      }
    }
  }
  finalizeConnection() {
    var _a;
    const { wcLinking, recentWallet } = ConnectionController.state;
    if (wcLinking) {
      StorageUtil.setWalletConnectDeepLink(wcLinking);
    }
    if (recentWallet) {
      StorageUtil.setAppKitRecent(recentWallet);
    }
    EventsController.sendEvent({
      type: "track",
      event: "CONNECT_SUCCESS",
      properties: {
        method: wcLinking ? "mobile" : "qrcode",
        name: ((_a = this.wallet) == null ? void 0 : _a.name) || "Unknown"
      }
    });
  }
  determinePlatforms() {
    if (!this.wallet) {
      this.platforms.push("qrcode");
      this.platform = "qrcode";
      return;
    }
    if (this.platform) {
      return;
    }
    const { mobile_link, desktop_link, webapp_link, injected, rdns, name } = this.wallet;
    const injectedIds = injected == null ? void 0 : injected.map(({ injected_id }) => injected_id).filter(Boolean);
    const browserIds = [...rdns ? [rdns] : injectedIds ?? [], name];
    const isBrowser = OptionsController.state.isUniversalProvider ? false : browserIds.length;
    const isMobileWc = mobile_link;
    const isWebWc = webapp_link;
    const isBrowserInstalled = ConnectionController.checkInstalled(browserIds);
    const isBrowserWc = isBrowser && isBrowserInstalled;
    const isDesktopWc = desktop_link && !CoreHelperUtil.isMobile();
    if (isBrowserWc) {
      this.platforms.push("browser");
    }
    if (isMobileWc) {
      this.platforms.push(CoreHelperUtil.isMobile() ? "mobile" : "qrcode");
    }
    if (isWebWc) {
      this.platforms.push("web");
    }
    if (isDesktopWc) {
      this.platforms.push("desktop");
    }
    if (!isBrowserWc && isBrowser) {
      this.platforms.push("unsupported");
    }
    this.platform = this.platforms[0];
  }
  platformTemplate() {
    switch (this.platform) {
      case "browser":
        return html`<w3m-connecting-wc-browser></w3m-connecting-wc-browser>`;
      case "web":
        return html`<w3m-connecting-wc-web></w3m-connecting-wc-web>`;
      case "desktop":
        return html`
          <w3m-connecting-wc-desktop .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-desktop>
        `;
      case "mobile":
        return html`
          <w3m-connecting-wc-mobile isMobile .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-mobile>
        `;
      case "qrcode":
        return html`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
      default:
        return html`<w3m-connecting-wc-unsupported></w3m-connecting-wc-unsupported>`;
    }
  }
  headerTemplate() {
    const multiPlatform = this.platforms.length > 1;
    if (!multiPlatform) {
      return null;
    }
    return html`
      <w3m-connecting-header
        .platforms=${this.platforms}
        .onSelectPlatfrom=${this.onSelectPlatform.bind(this)}
      >
      </w3m-connecting-header>
    `;
  }
  async onSelectPlatform(platform) {
    var _a;
    const container = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector("div");
    if (container) {
      await container.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.platform = platform;
      container.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
};
__decorate15([
  state()
], W3mConnectingWcView.prototype, "platform", void 0);
__decorate15([
  state()
], W3mConnectingWcView.prototype, "platforms", void 0);
__decorate15([
  state()
], W3mConnectingWcView.prototype, "isSiweEnabled", void 0);
W3mConnectingWcView = __decorate15([
  customElement("w3m-connecting-wc-view")
], W3mConnectingWcView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-choose-account-name-view/styles.js
var styles_default9 = css`
  .continue-button-container {
    width: 100%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-choose-account-name-view/index.js
var __decorate16 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mChooseAccountNameView = class W3mChooseAccountNameView2 extends LitElement {
  constructor() {
    super(...arguments);
    this.loading = false;
  }
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="xxl"
        .padding=${["0", "0", "l", "0"]}
      >
        ${this.onboardingTemplate()} ${this.buttonsTemplate()}
        <wui-link
          @click=${() => {
      CoreHelperUtil.openHref(NavigationUtil.URLS.FAQ, "_blank");
    }}
        >
          Learn more about names
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-link>
      </wui-flex>
    `;
  }
  onboardingTemplate() {
    return html` <wui-flex
      flexDirection="column"
      gap="xxl"
      alignItems="center"
      .padding=${["0", "xxl", "0", "xxl"]}
    >
      <wui-flex gap="s" alignItems="center" justifyContent="center">
        <wui-icon-box
          icon="id"
          size="xl"
          iconSize="xxl"
          iconColor="fg-200"
          backgroundColor="fg-200"
        ></wui-icon-box>
      </wui-flex>
      <wui-flex flexDirection="column" alignItems="center" gap="s">
        <wui-text align="center" variant="medium-600" color="fg-100">
          Choose your account name
        </wui-text>
        <wui-text align="center" variant="paragraph-400" color="fg-100">
          Finally say goodbye to 0x addresses, name your account to make it easier to exchange
          assets
        </wui-text>
      </wui-flex>
    </wui-flex>`;
  }
  buttonsTemplate() {
    return html`<wui-flex
      .padding=${["0", "2l", "0", "2l"]}
      gap="s"
      class="continue-button-container"
    >
      <wui-button
        fullWidth
        .loading=${this.loading}
        size="lg"
        borderRadius="xs"
        @click=${this.handleContinue.bind(this)}
        >Choose name
      </wui-button>
    </wui-flex>`;
  }
  handleContinue() {
    RouterController.push("RegisterAccountName");
    EventsController.sendEvent({
      type: "track",
      event: "OPEN_ENS_FLOW",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
  }
};
W3mChooseAccountNameView.styles = styles_default9;
__decorate16([
  state()
], W3mChooseAccountNameView.prototype, "loading", void 0);
W3mChooseAccountNameView = __decorate16([
  customElement("w3m-choose-account-name-view")
], W3mChooseAccountNameView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-downloads-view/index.js
var __decorate17 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mDownloadsView = class W3mDownloadsView2 extends LitElement {
  constructor() {
    var _a;
    super(...arguments);
    this.wallet = (_a = RouterController.state.data) == null ? void 0 : _a.wallet;
  }
  render() {
    if (!this.wallet) {
      throw new Error("w3m-downloads-view");
    }
    return html`
      <wui-flex gap="xs" flexDirection="column" .padding=${["s", "s", "l", "s"]}>
        ${this.chromeTemplate()} ${this.iosTemplate()} ${this.androidTemplate()}
        ${this.homepageTemplate()}
      </wui-flex>
    `;
  }
  chromeTemplate() {
    var _a;
    if (!((_a = this.wallet) == null ? void 0 : _a.chrome_store)) {
      return null;
    }
    return html`<wui-list-item
      variant="icon"
      icon="chromeStore"
      iconVariant="square"
      @click=${this.onChromeStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Chrome Extension</wui-text>
    </wui-list-item>`;
  }
  iosTemplate() {
    var _a;
    if (!((_a = this.wallet) == null ? void 0 : _a.app_store)) {
      return null;
    }
    return html`<wui-list-item
      variant="icon"
      icon="appStore"
      iconVariant="square"
      @click=${this.onAppStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">iOS App</wui-text>
    </wui-list-item>`;
  }
  androidTemplate() {
    var _a;
    if (!((_a = this.wallet) == null ? void 0 : _a.play_store)) {
      return null;
    }
    return html`<wui-list-item
      variant="icon"
      icon="playStore"
      iconVariant="square"
      @click=${this.onPlayStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Android App</wui-text>
    </wui-list-item>`;
  }
  homepageTemplate() {
    var _a;
    if (!((_a = this.wallet) == null ? void 0 : _a.homepage)) {
      return null;
    }
    return html`
      <wui-list-item
        variant="icon"
        icon="browser"
        iconVariant="square-blue"
        @click=${this.onHomePage.bind(this)}
        chevron
      >
        <wui-text variant="paragraph-500" color="fg-100">Website</wui-text>
      </wui-list-item>
    `;
  }
  onChromeStore() {
    var _a;
    if ((_a = this.wallet) == null ? void 0 : _a.chrome_store) {
      CoreHelperUtil.openHref(this.wallet.chrome_store, "_blank");
    }
  }
  onAppStore() {
    var _a;
    if ((_a = this.wallet) == null ? void 0 : _a.app_store) {
      CoreHelperUtil.openHref(this.wallet.app_store, "_blank");
    }
  }
  onPlayStore() {
    var _a;
    if ((_a = this.wallet) == null ? void 0 : _a.play_store) {
      CoreHelperUtil.openHref(this.wallet.play_store, "_blank");
    }
  }
  onHomePage() {
    var _a;
    if ((_a = this.wallet) == null ? void 0 : _a.homepage) {
      CoreHelperUtil.openHref(this.wallet.homepage, "_blank");
    }
  }
};
W3mDownloadsView = __decorate17([
  customElement("w3m-downloads-view")
], W3mDownloadsView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-get-wallet-view/index.js
var __decorate18 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var EXPLORER = "https://walletconnect.com/explorer";
var W3mGetWalletView = class W3mGetWalletView2 extends LitElement {
  render() {
    return html`
      <wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.recommendedWalletsTemplate()}
        <wui-list-wallet
          name="Explore all"
          showAllWallets
          walletIcon="allWallets"
          icon="externalLink"
          @click=${() => {
      CoreHelperUtil.openHref("https://walletconnect.com/explorer?type=wallet", "_blank");
    }}
        ></wui-list-wallet>
      </wui-flex>
    `;
  }
  recommendedWalletsTemplate() {
    const { recommended, featured } = ApiController.state;
    const { customWallets } = OptionsController.state;
    const wallets = [...featured, ...customWallets ?? [], ...recommended].slice(0, 4);
    return wallets.map((wallet) => html`
        <wui-list-wallet
          name=${wallet.name ?? "Unknown"}
          tagVariant="main"
          imageSrc=${ifDefined(AssetUtil.getWalletImage(wallet))}
          @click=${() => {
      CoreHelperUtil.openHref(wallet.homepage ?? EXPLORER, "_blank");
    }}
        ></wui-list-wallet>
      `);
  }
};
W3mGetWalletView = __decorate18([
  customElement("w3m-get-wallet-view")
], W3mGetWalletView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-register-account-name-view/styles.js
var styles_default10 = css`
  wui-flex {
    width: 100%;
  }

  .suggestion {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }

  .suggestion:hover {
    background-color: var(--wui-color-gray-glass-005);
    cursor: pointer;
  }

  .suggested-name {
    max-width: 75%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  form {
    width: 100%;
  }

  wui-icon-link {
    position: absolute;
    right: 20px;
    transform: translateY(11px);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-register-account-name-view/index.js
var __decorate19 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mRegisterAccountNameView = class W3mRegisterAccountNameView2 extends LitElement {
  constructor() {
    super();
    this.formRef = createRef();
    this.usubscribe = [];
    this.name = "";
    this.error = "";
    this.loading = EnsController.state.loading;
    this.suggestions = EnsController.state.suggestions;
    this.registered = false;
    this.profileName = AccountController.state.profileName;
    this.onDebouncedNameInputChange = CoreHelperUtil.debounce((value) => {
      if (EnsController.validateName(value)) {
        this.error = "";
        this.name = value;
        EnsController.getSuggestions(value);
        EnsController.isNameRegistered(value).then((registered) => {
          this.registered = registered;
        });
      } else if (value.length < 4) {
        this.error = "Name must be at least 4 characters long";
      } else {
        this.error = "Can only contain letters, numbers and - characters";
      }
    });
    this.usubscribe.push(...[
      EnsController.subscribe((val) => {
        this.suggestions = val.suggestions;
        this.loading = val.loading;
      }),
      AccountController.subscribeKey("profileName", (val) => {
        this.profileName = val;
        if (val) {
          this.error = "You already own a name";
        }
      })
    ]);
  }
  firstUpdated() {
    var _a;
    (_a = this.formRef.value) == null ? void 0 : _a.addEventListener("keydown", this.onEnterKey.bind(this));
  }
  disconnectedCallback() {
    var _a;
    super.disconnectedCallback();
    this.usubscribe.forEach((unsub) => unsub());
    (_a = this.formRef.value) == null ? void 0 : _a.removeEventListener("keydown", this.onEnterKey.bind(this));
  }
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="m"
        .padding=${["0", "s", "m", "s"]}
      >
        <form ${ref2(this.formRef)} @submit=${this.onSubmitName.bind(this)}>
          <wui-ens-input
            @inputChange=${this.onNameInputChange.bind(this)}
            .errorMessage=${this.error}
            .value=${this.name}
          >
          </wui-ens-input>
          ${this.submitButtonTemplate()}
          <input type="submit" hidden />
        </form>
        ${this.templateSuggestions()}
      </wui-flex>
    `;
  }
  submitButtonTemplate() {
    const showSubmit = this.isAllowedToSubmit();
    return showSubmit ? html`
          <wui-icon-link
            size="sm"
            icon="chevronRight"
            iconcolor="accent-100"
            @click=${this.onSubmitName.bind(this)}
          >
          </wui-icon-link>
        ` : null;
  }
  onSelectSuggestion(name) {
    return () => {
      this.name = name;
      this.registered = false;
      this.requestUpdate();
    };
  }
  onNameInputChange(event) {
    this.onDebouncedNameInputChange(event.detail);
  }
  nameSuggestionTagTemplate() {
    if (this.loading) {
      return html`<wui-loading-spinner size="lg" color="fg-100"></wui-loading-spinner>`;
    }
    return this.registered ? html`<wui-tag variant="shade" size="lg">Registered</wui-tag>` : html`<wui-tag variant="success" size="lg">Available</wui-tag>`;
  }
  templateSuggestions() {
    if (!this.name || this.name.length < 4 || this.error) {
      return null;
    }
    const suggestions = this.registered ? this.suggestions.filter((s2) => s2.name !== this.name) : [];
    return html`<wui-flex flexDirection="column" gap="xxs" alignItems="center">
      <wui-flex
        data-testid="account-name-suggestion"
        .padding=${["m", "m", "m", "m"]}
        justifyContent="space-between"
        class="suggestion"
        @click=${this.onSubmitName.bind(this)}
      >
        <wui-text color="fg-100" variant="paragraph-400" class="suggested-name">
          ${this.name}</wui-text
        >${this.nameSuggestionTagTemplate()}
      </wui-flex>
      ${suggestions.map((suggestion) => this.availableNameTemplate(suggestion.name))}
    </wui-flex>`;
  }
  availableNameTemplate(suggestion) {
    return html` <wui-flex
      data-testid="account-name-suggestion"
      .padding=${["m", "m", "m", "m"]}
      justifyContent="space-between"
      class="suggestion"
      @click=${this.onSelectSuggestion(suggestion)}
    >
      <wui-text color="fg-100" variant="paragraph-400" class="suggested-name">
        ${suggestion}
      </wui-text>
      <wui-tag variant="success" size="lg">Available</wui-tag>
    </wui-flex>`;
  }
  isAllowedToSubmit() {
    return !this.loading && !this.registered && !this.error && !this.profileName && EnsController.validateName(this.name);
  }
  async onSubmitName() {
    try {
      if (!this.isAllowedToSubmit()) {
        return;
      }
      const ensName = `${this.name}${ConstantsUtil.WC_NAME_SUFFIX}`;
      EventsController.sendEvent({
        type: "track",
        event: "REGISTER_NAME_INITIATED",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          ensName
        }
      });
      await EnsController.registerName(ensName);
      EventsController.sendEvent({
        type: "track",
        event: "REGISTER_NAME_SUCCESS",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          ensName
        }
      });
    } catch (error) {
      SnackController.showError(error.message);
      EventsController.sendEvent({
        type: "track",
        event: "REGISTER_NAME_ERROR",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          ensName: `${this.name}${ConstantsUtil.WC_NAME_SUFFIX}`,
          error: (error == null ? void 0 : error.message) || "Unknown error"
        }
      });
    }
  }
  onEnterKey(event) {
    if (event.key === "Enter" && this.isAllowedToSubmit()) {
      this.onSubmitName();
    }
  }
};
W3mRegisterAccountNameView.styles = styles_default10;
__decorate19([
  property()
], W3mRegisterAccountNameView.prototype, "errorMessage", void 0);
__decorate19([
  state()
], W3mRegisterAccountNameView.prototype, "name", void 0);
__decorate19([
  state()
], W3mRegisterAccountNameView.prototype, "error", void 0);
__decorate19([
  state()
], W3mRegisterAccountNameView.prototype, "loading", void 0);
__decorate19([
  state()
], W3mRegisterAccountNameView.prototype, "suggestions", void 0);
__decorate19([
  state()
], W3mRegisterAccountNameView.prototype, "registered", void 0);
__decorate19([
  state()
], W3mRegisterAccountNameView.prototype, "profileName", void 0);
W3mRegisterAccountNameView = __decorate19([
  customElement("w3m-register-account-name-view")
], W3mRegisterAccountNameView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-register-account-name-success-view/styles.js
var styles_default11 = css`
  .continue-button-container {
    width: 100%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-register-account-name-success-view/index.js
var __decorate20 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mRegisterAccountNameSuccess = class W3mRegisterAccountNameSuccess2 extends LitElement {
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="xxl"
        .padding=${["0", "0", "l", "0"]}
      >
        ${this.onboardingTemplate()} ${this.buttonsTemplate()}
        <wui-link
          @click=${() => {
      CoreHelperUtil.openHref(NavigationUtil.URLS.FAQ, "_blank");
    }}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-link>
      </wui-flex>
    `;
  }
  onboardingTemplate() {
    return html` <wui-flex
      flexDirection="column"
      gap="xxl"
      alignItems="center"
      .padding=${["0", "xxl", "0", "xxl"]}
    >
      <wui-flex gap="s" alignItems="center" justifyContent="center">
        <wui-icon-box
          size="xl"
          iconcolor="success-100"
          backgroundcolor="success-100"
          icon="checkmark"
          background="opaque"
        ></wui-icon-box>
      </wui-flex>
      <wui-flex flexDirection="column" alignItems="center" gap="s">
        <wui-text align="center" variant="medium-600" color="fg-100">
          Account name chosen successfully
        </wui-text>
        <wui-text align="center" variant="paragraph-400" color="fg-100">
          You can now fund your account and trade crypto
        </wui-text>
      </wui-flex>
    </wui-flex>`;
  }
  buttonsTemplate() {
    return html`<wui-flex
      .padding=${["0", "2l", "0", "2l"]}
      gap="s"
      class="continue-button-container"
    >
      <wui-button fullWidth size="lg" borderRadius="xs" @click=${this.redirectToAccount.bind(this)}
        >Let's Go!
      </wui-button>
    </wui-flex>`;
  }
  redirectToAccount() {
    RouterController.replace("Account");
  }
};
W3mRegisterAccountNameSuccess.styles = styles_default11;
W3mRegisterAccountNameSuccess = __decorate20([
  customElement("w3m-register-account-name-success-view")
], W3mRegisterAccountNameSuccess);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-network-switch-view/styles.js
var styles_default12 = css`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: 4px;
    bottom: 0;
    opacity: 0;
    transform: scale(0.5);
    z-index: 1;
  }

  wui-button {
    display: none;
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  wui-button[data-retry='true'] {
    display: block;
    opacity: 1;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-network-switch-view/index.js
var __decorate21 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mNetworkSwitchView = class W3mNetworkSwitchView2 extends LitElement {
  constructor() {
    var _a;
    super();
    this.network = (_a = RouterController.state.data) == null ? void 0 : _a.network;
    this.unsubscribe = [];
    this.showRetry = false;
    this.error = false;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  firstUpdated() {
    this.onSwitchNetwork();
  }
  render() {
    if (!this.network) {
      throw new Error("w3m-network-switch-view: No network provided");
    }
    this.onShowRetry();
    const label = this.getLabel();
    const subLabel = this.getSubLabel();
    return html`
      <wui-flex
        data-error=${this.error}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "3xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-network-image
            size="lg"
            imageSrc=${ifDefined(AssetUtil.getNetworkImage(this.network))}
          ></wui-network-image>

          ${this.error ? null : html`<wui-loading-hexagon></wui-loading-hexagon>`}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            ?border=${true}
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100">${label}</wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        <wui-button
          data-retry=${this.showRetry}
          variant="accent"
          size="md"
          .disabled=${!this.error}
          @click=${this.onSwitchNetwork.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
          Try again
        </wui-button>
      </wui-flex>
    `;
  }
  getSubLabel() {
    const type = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    if (authConnector && type === "AUTH") {
      return "";
    }
    return this.error ? "Switch can be declined if chain is not supported by a wallet or previous request is still active" : "Accept connection request in your wallet";
  }
  getLabel() {
    var _a;
    const type = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    if (authConnector && type === "AUTH") {
      return `Switching to ${((_a = this.network) == null ? void 0 : _a.name) ?? "Unknown"} network...`;
    }
    return this.error ? "Switch declined" : "Approve in wallet";
  }
  onShowRetry() {
    var _a;
    if (this.error && !this.showRetry) {
      this.showRetry = true;
      const retryButton = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector("wui-button");
      retryButton == null ? void 0 : retryButton.animate([{ opacity: 0 }, { opacity: 1 }], {
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  async onSwitchNetwork() {
    try {
      this.error = false;
      if (this.network) {
        await ChainController.switchActiveNetwork(this.network);
      }
    } catch (error) {
      this.error = true;
    }
  }
};
W3mNetworkSwitchView.styles = styles_default12;
__decorate21([
  state()
], W3mNetworkSwitchView.prototype, "showRetry", void 0);
__decorate21([
  state()
], W3mNetworkSwitchView.prototype, "error", void 0);
W3mNetworkSwitchView = __decorate21([
  customElement("w3m-network-switch-view")
], W3mNetworkSwitchView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-networks-view/styles.js
var styles_default13 = css`
  .container {
    max-height: 360px;
    overflow: auto;
  }

  .container::-webkit-scrollbar {
    display: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-networks-view/index.js
var __decorate22 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mNetworksView = class W3mNetworksView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.network = ChainController.state.activeCaipNetwork;
    this.requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    this.search = "";
    this.onDebouncedSearch = CoreHelperUtil.debounce((value) => {
      this.search = value;
    }, 100);
    this.unsubscribe.push(ChainController.subscribeKey("activeCaipNetwork", (val) => this.network = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`
      ${this.templateSearchInput()}
      <wui-flex
        class="container"
        .padding=${["0", "s", "s", "s"]}
        flexDirection="column"
        gap="xs"
      >
        ${this.networksTemplate()}
      </wui-flex>

      <wui-separator></wui-separator>

      <wui-flex padding="s" flexDirection="column" gap="m" alignItems="center">
        <wui-text variant="small-400" color="fg-300" align="center">
          Your connected wallet may not support some of the networks available for this dApp
        </wui-text>
        <wui-link @click=${this.onNetworkHelp.bind(this)}>
          <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
          What is a network
        </wui-link>
      </wui-flex>
    `;
  }
  templateSearchInput() {
    return html`
      <wui-flex gap="xs" .padding=${["0", "s", "s", "s"]}>
        <wui-input-text
          @inputChange=${this.onInputChange.bind(this)}
          class="network-search-input"
          size="md"
          placeholder="Search network"
          icon="search"
        ></wui-input-text>
      </wui-flex>
    `;
  }
  onInputChange(event) {
    this.onDebouncedSearch(event.detail);
  }
  onNetworkHelp() {
    EventsController.sendEvent({ type: "track", event: "CLICK_NETWORK_HELP" });
    RouterController.push("WhatIsANetwork");
  }
  networksTemplate() {
    var _a;
    const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const approvedCaipNetworkIds = ChainController.getAllApprovedCaipNetworkIds();
    const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    if (this.search) {
      this.filteredNetworks = sortedNetworks == null ? void 0 : sortedNetworks.filter((network) => {
        var _a2;
        return (_a2 = network == null ? void 0 : network.name) == null ? void 0 : _a2.toLowerCase().includes(this.search.toLowerCase());
      });
    } else {
      this.filteredNetworks = sortedNetworks;
    }
    return (_a = this.filteredNetworks) == null ? void 0 : _a.map((network) => {
      var _a2;
      return html`
        <wui-list-network
          .selected=${((_a2 = this.network) == null ? void 0 : _a2.id) === network.id}
          imageSrc=${ifDefined(AssetUtil.getNetworkImage(network))}
          type="network"
          name=${network.name ?? network.id}
          @click=${() => this.onSwitchNetwork(network)}
          .disabled=${this.getNetworkDisabled(network)}
          data-testid=${`w3m-network-switch-${network.name ?? network.id}`}
        ></wui-list-network>
      `;
    });
  }
  getNetworkDisabled(network) {
    const networkNamespace = network.chainNamespace;
    const isNamespaceConnected = AccountController.getCaipAddress(networkNamespace);
    const approvedCaipNetworkIds = ChainController.getAllApprovedCaipNetworkIds();
    const supportsAllNetworks = ChainController.getNetworkProp("supportsAllNetworks", networkNamespace) !== false;
    const type = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    const isConnectedWithAuth = type === "ID_AUTH" && authConnector;
    if (!isNamespaceConnected || supportsAllNetworks || isConnectedWithAuth) {
      return false;
    }
    return !(approvedCaipNetworkIds == null ? void 0 : approvedCaipNetworkIds.includes(network.caipNetworkId));
  }
  onSwitchNetwork(network) {
    var _a;
    const routerData = RouterController.state.data;
    const isSameNetwork = network.id === ((_a = this.network) == null ? void 0 : _a.id);
    if (isSameNetwork) {
      return;
    }
    const isDifferentNamespace = network.chainNamespace !== ChainController.state.activeChain;
    const isNewNetworkConnected = ChainController.getAccountProp("caipAddress", network.chainNamespace);
    const isCurrentNetworkConnected = AccountController.state.caipAddress;
    const isAuthConnected = StorageUtil.getConnectedConnector() === "ID_AUTH";
    if (isDifferentNamespace && isCurrentNetworkConnected && !isNewNetworkConnected && !isAuthConnected) {
      RouterController.push("SwitchActiveChain", {
        switchToChain: network.chainNamespace,
        navigateTo: "Connect",
        navigateWithReplace: true,
        network
      });
    } else {
      RouterController.push("SwitchNetwork", { ...routerData, network });
    }
  }
};
W3mNetworksView.styles = styles_default13;
__decorate22([
  state()
], W3mNetworksView.prototype, "network", void 0);
__decorate22([
  state()
], W3mNetworksView.prototype, "requestedCaipNetworks", void 0);
__decorate22([
  state()
], W3mNetworksView.prototype, "filteredNetworks", void 0);
__decorate22([
  state()
], W3mNetworksView.prototype, "search", void 0);
W3mNetworksView = __decorate22([
  customElement("w3m-networks-view")
], W3mNetworksView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-onramp-activity-view/styles.js
var styles_default14 = css`
  :host > wui-flex {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
    padding: var(--wui-spacing-m);
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: flex-start;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }

  :host > wui-flex > wui-flex {
    width: 100%;
  }

  wui-transaction-list-item-loader {
    width: 100%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-onramp-activity-view/index.js
var __decorate23 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var LOADING_ITEM_COUNT = 7;
var W3mOnRampActivityView = class W3mOnRampActivityView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedOnRampProvider = OnRampController.state.selectedProvider;
    this.loading = false;
    this.coinbaseTransactions = TransactionsController.state.coinbaseTransactions;
    this.tokenImages = AssetController.state.tokenImages;
    this.unsubscribe.push(...[
      OnRampController.subscribeKey("selectedProvider", (val) => {
        this.selectedOnRampProvider = val;
      }),
      AssetController.subscribeKey("tokenImages", (val) => this.tokenImages = val),
      () => {
        clearTimeout(this.refetchTimeout);
      },
      TransactionsController.subscribe((val) => {
        this.coinbaseTransactions = { ...val.coinbaseTransactions };
      })
    ]);
    TransactionsController.clearCursor();
    this.fetchTransactions();
  }
  render() {
    return html`
      <wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.loading ? this.templateLoading() : this.templateTransactionsByYear()}
      </wui-flex>
    `;
  }
  templateTransactions(transactions) {
    return transactions == null ? void 0 : transactions.map((transaction) => {
      var _a, _b, _c;
      const date = DateUtil.formatDate((_a = transaction == null ? void 0 : transaction.metadata) == null ? void 0 : _a.minedAt);
      const transfer = transaction.transfers[0];
      const fungibleInfo = transfer == null ? void 0 : transfer.fungible_info;
      if (!fungibleInfo) {
        return null;
      }
      const icon = ((_b = fungibleInfo == null ? void 0 : fungibleInfo.icon) == null ? void 0 : _b.url) || ((_c = this.tokenImages) == null ? void 0 : _c[fungibleInfo.symbol || ""]);
      return html`
        <w3m-onramp-activity-item
          label="Bought"
          .completed=${transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_SUCCESS"}
          .inProgress=${transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_IN_PROGRESS"}
          .failed=${transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_FAILED"}
          purchaseCurrency=${ifDefined(fungibleInfo.symbol)}
          purchaseValue=${transfer.quantity.numeric}
          date=${date}
          icon=${ifDefined(icon)}
          symbol=${ifDefined(fungibleInfo.symbol)}
        ></w3m-onramp-activity-item>
      `;
    });
  }
  templateTransactionsByYear() {
    const sortedYearKeys = Object.keys(this.coinbaseTransactions).sort().reverse();
    return sortedYearKeys.map((year) => {
      const yearInt = parseInt(year, 10);
      const sortedMonthIndexes = new Array(12).fill(null).map((_3, idx) => idx).reverse();
      return sortedMonthIndexes.map((month) => {
        var _a;
        const groupTitle = TransactionUtil.getTransactionGroupTitle(yearInt, month);
        const transactions = (_a = this.coinbaseTransactions[yearInt]) == null ? void 0 : _a[month];
        if (!transactions) {
          return null;
        }
        return html`
          <wui-flex flexDirection="column">
            <wui-flex
              alignItems="center"
              flexDirection="row"
              .padding=${["xs", "s", "s", "s"]}
            >
              <wui-text variant="paragraph-500" color="fg-200">${groupTitle}</wui-text>
            </wui-flex>
            <wui-flex flexDirection="column" gap="xs">
              ${this.templateTransactions(transactions)}
            </wui-flex>
          </wui-flex>
        `;
      });
    });
  }
  async fetchTransactions() {
    const provider = "coinbase";
    if (provider === "coinbase") {
      await this.fetchCoinbaseTransactions();
    }
  }
  async fetchCoinbaseTransactions() {
    const address = AccountController.state.address;
    const projectId = OptionsController.state.projectId;
    if (!address) {
      throw new Error("No address found");
    }
    if (!projectId) {
      throw new Error("No projectId found");
    }
    this.loading = true;
    await TransactionsController.fetchTransactions(address, "coinbase");
    this.loading = false;
    this.refetchLoadingTransactions();
  }
  refetchLoadingTransactions() {
    var _a;
    const today = /* @__PURE__ */ new Date();
    const currentMonthTxs = ((_a = this.coinbaseTransactions[today.getFullYear()]) == null ? void 0 : _a[today.getMonth()]) || [];
    const loadingTransactions = currentMonthTxs.filter((transaction) => transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_IN_PROGRESS");
    if (loadingTransactions.length === 0) {
      clearTimeout(this.refetchTimeout);
      return;
    }
    this.refetchTimeout = setTimeout(async () => {
      const address = AccountController.state.address;
      await TransactionsController.fetchTransactions(address, "coinbase");
      this.refetchLoadingTransactions();
    }, 3e3);
  }
  templateLoading() {
    return Array(LOADING_ITEM_COUNT).fill(html` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `).map((item) => item);
  }
};
W3mOnRampActivityView.styles = styles_default14;
__decorate23([
  state()
], W3mOnRampActivityView.prototype, "selectedOnRampProvider", void 0);
__decorate23([
  state()
], W3mOnRampActivityView.prototype, "loading", void 0);
__decorate23([
  state()
], W3mOnRampActivityView.prototype, "coinbaseTransactions", void 0);
__decorate23([
  state()
], W3mOnRampActivityView.prototype, "tokenImages", void 0);
W3mOnRampActivityView = __decorate23([
  customElement("w3m-onramp-activity-view")
], W3mOnRampActivityView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-onramp-fiat-select-view/styles.js
var styles_default15 = css`
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-flex {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-flex.disabled {
    opacity: 0.3;
    pointer-events: none;
    user-select: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-onramp-fiat-select-view/index.js
var __decorate24 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mOnrampFiatSelectView = class W3mOnrampFiatSelectView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedCurrency = OnRampController.state.paymentCurrency;
    this.currencies = OnRampController.state.paymentCurrencies;
    this.currencyImages = AssetController.state.currencyImages;
    this.checked = false;
    this.unsubscribe.push(...[
      OnRampController.subscribe((val) => {
        this.selectedCurrency = val.paymentCurrency;
        this.currencies = val.paymentCurrencies;
      }),
      AssetController.subscribeKey("currencyImages", (val) => this.currencyImages = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a;
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    const legalCheckbox = (_a = OptionsController.state.features) == null ? void 0 : _a.legalCheckbox;
    const legalUrl = termsConditionsUrl || privacyPolicyUrl;
    const showLegalCheckbox = Boolean(legalUrl) && Boolean(legalCheckbox);
    const disabled = showLegalCheckbox && !this.checked;
    return html`
      <w3m-legal-checkbox @checkboxChange=${this.onCheckboxChange.bind(this)}></w3m-legal-checkbox>
      <wui-flex
        flexDirection="column"
        .padding=${["0", "s", "s", "s"]}
        gap="xs"
        class=${ifDefined(disabled ? "disabled" : void 0)}
      >
        ${this.currenciesTemplate(disabled)}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
  currenciesTemplate(disabled = false) {
    return this.currencies.map((currency) => {
      var _a;
      return html`
        <wui-list-item
          imageSrc=${ifDefined((_a = this.currencyImages) == null ? void 0 : _a[currency.id])}
          @click=${() => this.selectCurrency(currency)}
          variant="image"
          tabIdx=${ifDefined(disabled ? -1 : void 0)}
        >
          <wui-text variant="paragraph-500" color="fg-100">${currency.id}</wui-text>
        </wui-list-item>
      `;
    });
  }
  selectCurrency(currency) {
    if (!currency) {
      return;
    }
    OnRampController.setPaymentCurrency(currency);
    ModalController.close();
  }
  onCheckboxChange(event) {
    this.checked = Boolean(event.detail);
  }
};
W3mOnrampFiatSelectView.styles = styles_default15;
__decorate24([
  state()
], W3mOnrampFiatSelectView.prototype, "selectedCurrency", void 0);
__decorate24([
  state()
], W3mOnrampFiatSelectView.prototype, "currencies", void 0);
__decorate24([
  state()
], W3mOnrampFiatSelectView.prototype, "currencyImages", void 0);
__decorate24([
  state()
], W3mOnrampFiatSelectView.prototype, "checked", void 0);
W3mOnrampFiatSelectView = __decorate24([
  customElement("w3m-onramp-fiat-select-view")
], W3mOnrampFiatSelectView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-onramp-providers-view/index.js
var __decorate25 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mOnRampProvidersView = class W3mOnRampProvidersView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.providers = OnRampController.state.providers;
    this.unsubscribe.push(...[
      OnRampController.subscribeKey("providers", (val) => {
        this.providers = val;
      })
    ]);
  }
  firstUpdated() {
    const urlPromises = this.providers.map(async (provider) => {
      if (provider.name === "coinbase") {
        return await this.getCoinbaseOnRampURL();
      }
      return Promise.resolve(provider == null ? void 0 : provider.url);
    });
    Promise.all(urlPromises).then((urls) => {
      this.providers = this.providers.map((provider, index2) => ({
        ...provider,
        url: urls[index2] || ""
      }));
    });
  }
  render() {
    return html`
      <wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.onRampProvidersTemplate()}
      </wui-flex>
      <w3m-onramp-providers-footer></w3m-onramp-providers-footer>
    `;
  }
  onRampProvidersTemplate() {
    return this.providers.filter((provider) => provider.supportedChains.includes(ChainController.state.activeChain ?? "eip155")).map((provider) => html`
          <w3m-onramp-provider-item
            label=${provider.label}
            name=${provider.name}
            feeRange=${provider.feeRange}
            @click=${() => {
      this.onClickProvider(provider);
    }}
            ?disabled=${!provider.url}
          ></w3m-onramp-provider-item>
        `);
  }
  onClickProvider(provider) {
    OnRampController.setSelectedProvider(provider);
    RouterController.push("BuyInProgress");
    CoreHelperUtil.openHref(provider.url, "popupWindow", "width=600,height=800,scrollbars=yes");
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_BUY_PROVIDER",
      properties: {
        provider: provider.name,
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
  }
  async getCoinbaseOnRampURL() {
    const address = AccountController.state.address;
    const network = ChainController.state.activeCaipNetwork;
    if (!address) {
      throw new Error("No address found");
    }
    if (!(network == null ? void 0 : network.name)) {
      throw new Error("No network found");
    }
    const defaultNetwork = ConstantsUtil2.WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP[network.name] ?? ConstantsUtil2.WC_COINBASE_PAY_SDK_FALLBACK_CHAIN;
    const purchaseCurrency = OnRampController.state.purchaseCurrency;
    const assets = purchaseCurrency ? [purchaseCurrency.symbol] : OnRampController.state.purchaseCurrencies.map((currency) => currency.symbol);
    return await BlockchainApiController.generateOnRampURL({
      defaultNetwork,
      destinationWallets: [
        { address, blockchains: ConstantsUtil2.WC_COINBASE_PAY_SDK_CHAINS, assets }
      ],
      partnerUserId: address,
      purchaseAmount: OnRampController.state.purchaseAmount
    });
  }
};
__decorate25([
  state()
], W3mOnRampProvidersView.prototype, "providers", void 0);
W3mOnRampProvidersView = __decorate25([
  customElement("w3m-onramp-providers-view")
], W3mOnRampProvidersView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-onramp-tokens-select-view/styles.js
var styles_default16 = css`
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-flex {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-flex.disabled {
    opacity: 0.3;
    pointer-events: none;
    user-select: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-onramp-tokens-select-view/index.js
var __decorate26 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mOnrampTokensView = class W3mOnrampTokensView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedCurrency = OnRampController.state.purchaseCurrencies;
    this.tokens = OnRampController.state.purchaseCurrencies;
    this.tokenImages = AssetController.state.tokenImages;
    this.checked = false;
    this.unsubscribe.push(...[
      OnRampController.subscribe((val) => {
        this.selectedCurrency = val.purchaseCurrencies;
        this.tokens = val.purchaseCurrencies;
      }),
      AssetController.subscribeKey("tokenImages", (val) => this.tokenImages = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a;
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    const legalCheckbox = (_a = OptionsController.state.features) == null ? void 0 : _a.legalCheckbox;
    const legalUrl = termsConditionsUrl || privacyPolicyUrl;
    const showLegalCheckbox = Boolean(legalUrl) && Boolean(legalCheckbox);
    const disabled = showLegalCheckbox && !this.checked;
    return html`
      <w3m-legal-checkbox @checkboxChange=${this.onCheckboxChange.bind(this)}></w3m-legal-checkbox>
      <wui-flex
        flexDirection="column"
        .padding=${["0", "s", "s", "s"]}
        gap="xs"
        class=${ifDefined(disabled ? "disabled" : void 0)}
      >
        ${this.currenciesTemplate(disabled)}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
  currenciesTemplate(disabled = false) {
    return this.tokens.map((token) => {
      var _a;
      return html`
        <wui-list-item
          imageSrc=${ifDefined((_a = this.tokenImages) == null ? void 0 : _a[token.symbol])}
          @click=${() => this.selectToken(token)}
          variant="image"
          tabIdx=${ifDefined(disabled ? -1 : void 0)}
        >
          <wui-flex gap="3xs" alignItems="center">
            <wui-text variant="paragraph-500" color="fg-100">${token.name}</wui-text>
            <wui-text variant="small-400" color="fg-200">${token.symbol}</wui-text>
          </wui-flex>
        </wui-list-item>
      `;
    });
  }
  selectToken(currency) {
    if (!currency) {
      return;
    }
    OnRampController.setPurchaseCurrency(currency);
    ModalController.close();
  }
  onCheckboxChange(event) {
    this.checked = Boolean(event.detail);
  }
};
W3mOnrampTokensView.styles = styles_default16;
__decorate26([
  state()
], W3mOnrampTokensView.prototype, "selectedCurrency", void 0);
__decorate26([
  state()
], W3mOnrampTokensView.prototype, "tokens", void 0);
__decorate26([
  state()
], W3mOnrampTokensView.prototype, "tokenImages", void 0);
__decorate26([
  state()
], W3mOnrampTokensView.prototype, "checked", void 0);
W3mOnrampTokensView = __decorate26([
  customElement("w3m-onramp-token-select-view")
], W3mOnrampTokensView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-swap-view/styles.js
var styles_default17 = css`
  :host > wui-flex:first-child {
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  .action-button {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
  }

  .action-button:disabled {
    border-color: 1px solid var(--wui-color-gray-glass-005);
  }

  .swap-inputs-container {
    position: relative;
  }

  .replace-tokens-button-container {
    display: flex;
    justify-content: center;
    align-items: center;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    gap: var(--wui-spacing-1xs);
    border-radius: var(--wui-border-radius-xs);
    background-color: var(--wui-color-modal-bg-base);
    padding: var(--wui-spacing-xxs);
  }

  .replace-tokens-button-container > button {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 40px;
    width: 40px;
    padding: var(--wui-spacing-xs);
    border: none;
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
    transition: background-color var(--wui-duration-md) var(--wui-ease-out-power-1);
    will-change: background-color;
    z-index: 20;
  }

  .replace-tokens-button-container > button:hover {
    background: var(--wui-color-gray-glass-005);
  }

  .details-container > wui-flex {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    width: 100%;
  }

  .details-container > wui-flex > button {
    border: none;
    background: none;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    transition: background 0.2s linear;
  }

  .details-container > wui-flex > button:hover {
    background: var(--wui-color-gray-glass-002);
  }

  .details-content-container {
    padding: var(--wui-spacing-1xs);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .details-content-container > wui-flex {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s) var(--wui-spacing-xl);
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-swap-view/index.js
var __decorate27 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSwapView = class W3mSwapView2 extends LitElement {
  constructor() {
    var _a;
    super();
    this.unsubscribe = [];
    this.detailsOpen = false;
    this.caipNetworkId = (_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId;
    this.initialized = SwapController.state.initialized;
    this.loadingQuote = SwapController.state.loadingQuote;
    this.loadingPrices = SwapController.state.loadingPrices;
    this.loadingTransaction = SwapController.state.loadingTransaction;
    this.sourceToken = SwapController.state.sourceToken;
    this.sourceTokenAmount = SwapController.state.sourceTokenAmount;
    this.sourceTokenPriceInUSD = SwapController.state.sourceTokenPriceInUSD;
    this.toToken = SwapController.state.toToken;
    this.toTokenAmount = SwapController.state.toTokenAmount;
    this.toTokenPriceInUSD = SwapController.state.toTokenPriceInUSD;
    this.inputError = SwapController.state.inputError;
    this.gasPriceInUSD = SwapController.state.gasPriceInUSD;
    this.fetchError = SwapController.state.fetchError;
    this.onDebouncedGetSwapCalldata = CoreHelperUtil.debounce(async () => {
      await SwapController.swapTokens();
    }, 200);
    ChainController.subscribeKey("activeCaipNetwork", (newCaipNetwork) => {
      if (this.caipNetworkId !== (newCaipNetwork == null ? void 0 : newCaipNetwork.caipNetworkId)) {
        this.caipNetworkId = newCaipNetwork == null ? void 0 : newCaipNetwork.caipNetworkId;
        SwapController.resetState();
        SwapController.initializeState();
      }
    });
    this.unsubscribe.push(...[
      ModalController.subscribeKey("open", (isOpen) => {
        if (!isOpen) {
          SwapController.resetState();
        }
      }),
      RouterController.subscribeKey("view", (newRoute) => {
        if (!newRoute.includes("Swap")) {
          SwapController.resetValues();
        }
      }),
      SwapController.subscribe((newState) => {
        this.initialized = newState.initialized;
        this.loadingQuote = newState.loadingQuote;
        this.loadingPrices = newState.loadingPrices;
        this.loadingTransaction = newState.loadingTransaction;
        this.sourceToken = newState.sourceToken;
        this.sourceTokenAmount = newState.sourceTokenAmount;
        this.sourceTokenPriceInUSD = newState.sourceTokenPriceInUSD;
        this.toToken = newState.toToken;
        this.toTokenAmount = newState.toTokenAmount;
        this.toTokenPriceInUSD = newState.toTokenPriceInUSD;
        this.inputError = newState.inputError;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.fetchError = newState.fetchError;
      })
    ]);
  }
  firstUpdated() {
    SwapController.initializeState();
    this.watchTokensAndValues();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe == null ? void 0 : unsubscribe());
    clearInterval(this.interval);
  }
  render() {
    return html`
      <wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]} gap="s">
        ${this.initialized ? this.templateSwap() : this.templateLoading()}
      </wui-flex>
    `;
  }
  watchTokensAndValues() {
    this.interval = setInterval(() => {
      SwapController.getNetworkTokenPrice();
      SwapController.getMyTokensWithBalance();
      SwapController.swapTokens();
    }, 1e4);
  }
  templateSwap() {
    return html`
      <wui-flex flexDirection="column" gap="s">
        <wui-flex flexDirection="column" alignItems="center" gap="xs" class="swap-inputs-container">
          ${this.templateTokenInput("sourceToken", this.sourceToken)}
          ${this.templateTokenInput("toToken", this.toToken)} ${this.templateReplaceTokensButton()}
        </wui-flex>
        ${this.templateDetails()} ${this.templateActionButton()}
      </wui-flex>
    `;
  }
  actionButtonLabel() {
    if (this.fetchError) {
      return "Swap";
    }
    if (!this.sourceToken || !this.toToken) {
      return "Select token";
    }
    if (!this.sourceTokenAmount) {
      return "Enter amount";
    }
    if (this.inputError) {
      return this.inputError;
    }
    return "Review swap";
  }
  templateReplaceTokensButton() {
    return html`
      <wui-flex class="replace-tokens-button-container">
        <button @click=${this.onSwitchTokens.bind(this)}>
          <wui-icon name="recycleHorizontal" color="fg-250" size="lg"></wui-icon>
        </button>
      </wui-flex>
    `;
  }
  templateLoading() {
    return html`
      <wui-flex flexDirection="column" gap="l">
        <wui-flex flexDirection="column" alignItems="center" gap="xs" class="swap-inputs-container">
          <w3m-swap-input-skeleton target="sourceToken"></w3m-swap-input-skeleton>
          <w3m-swap-input-skeleton target="toToken"></w3m-swap-input-skeleton>
          ${this.templateReplaceTokensButton()}
        </wui-flex>
        ${this.templateActionButton()}
      </wui-flex>
    `;
  }
  templateTokenInput(target, token) {
    var _a, _b;
    const myToken = (_a = SwapController.state.myTokensWithBalance) == null ? void 0 : _a.find((ct3) => (ct3 == null ? void 0 : ct3.address) === (token == null ? void 0 : token.address));
    const amount = target === "toToken" ? this.toTokenAmount : this.sourceTokenAmount;
    const price = target === "toToken" ? this.toTokenPriceInUSD : this.sourceTokenPriceInUSD;
    let value = parseFloat(amount) * price;
    if (target === "toToken") {
      value -= this.gasPriceInUSD || 0;
    }
    return html`<w3m-swap-input
      .value=${target === "toToken" ? this.toTokenAmount : this.sourceTokenAmount}
      ?disabled=${this.loadingQuote && target === "toToken"}
      .onSetAmount=${this.handleChangeAmount.bind(this)}
      target=${target}
      .token=${token}
      .balance=${(_b = myToken == null ? void 0 : myToken.quantity) == null ? void 0 : _b.numeric}
      .price=${myToken == null ? void 0 : myToken.price}
      .marketValue=${value}
      .onSetMaxValue=${this.onSetMaxValue.bind(this)}
    ></w3m-swap-input>`;
  }
  onSetMaxValue(target, balance) {
    const token = target === "sourceToken" ? this.sourceToken : this.toToken;
    const isNetworkToken = (token == null ? void 0 : token.address) === ChainController.getActiveNetworkTokenAddress();
    let value = "0";
    if (!balance) {
      value = "0";
      this.handleChangeAmount(target, value);
      return;
    }
    if (!this.gasPriceInUSD) {
      value = balance;
      this.handleChangeAmount(target, value);
      return;
    }
    const amountOfTokenGasRequires = NumberUtil.bigNumber(this.gasPriceInUSD.toFixed(5)).dividedBy(this.sourceTokenPriceInUSD);
    const maxValue = isNetworkToken ? NumberUtil.bigNumber(balance).minus(amountOfTokenGasRequires) : NumberUtil.bigNumber(balance);
    this.handleChangeAmount(target, maxValue.isGreaterThan(0) ? maxValue.toFixed(20) : "0");
  }
  templateDetails() {
    if (!this.sourceToken || !this.toToken || this.inputError) {
      return null;
    }
    return html`<w3m-swap-details .detailsOpen=${this.detailsOpen}></w3m-swap-details>`;
  }
  handleChangeAmount(target, value) {
    SwapController.clearError();
    if (target === "sourceToken") {
      SwapController.setSourceTokenAmount(value);
    } else {
      SwapController.setToTokenAmount(value);
    }
    this.onDebouncedGetSwapCalldata();
  }
  templateActionButton() {
    const haveNoTokenSelected = !this.toToken || !this.sourceToken;
    const haveNoAmount = !this.sourceTokenAmount;
    const loading = this.loadingQuote || this.loadingPrices || this.loadingTransaction;
    const disabled = loading || haveNoTokenSelected || haveNoAmount || this.inputError;
    return html` <wui-flex gap="xs">
      <wui-button
        data-testid="swap-action-button"
        class="action-button"
        fullWidth
        size="lg"
        borderRadius="xs"
        variant=${haveNoTokenSelected ? "neutral" : "main"}
        .loading=${loading}
        .disabled=${disabled}
        @click=${this.onSwapPreview.bind(this)}
      >
        ${this.actionButtonLabel()}
      </wui-button>
    </wui-flex>`;
  }
  onSwitchTokens() {
    SwapController.switchTokens();
  }
  onSwapPreview() {
    var _a, _b;
    if (this.fetchError) {
      SwapController.swapTokens();
      return;
    }
    EventsController.sendEvent({
      type: "track",
      event: "INITIATE_SWAP",
      properties: {
        network: this.caipNetworkId || "",
        swapFromToken: ((_a = this.sourceToken) == null ? void 0 : _a.symbol) || "",
        swapToToken: ((_b = this.toToken) == null ? void 0 : _b.symbol) || "",
        swapFromAmount: this.sourceTokenAmount || "",
        swapToAmount: this.toTokenAmount || "",
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("SwapPreview");
  }
};
W3mSwapView.styles = styles_default17;
__decorate27([
  state()
], W3mSwapView.prototype, "interval", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "detailsOpen", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "caipNetworkId", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "initialized", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "loadingQuote", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "loadingPrices", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "loadingTransaction", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "sourceToken", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "sourceTokenAmount", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "sourceTokenPriceInUSD", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "toToken", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "toTokenAmount", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "toTokenPriceInUSD", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "inputError", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "gasPriceInUSD", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "fetchError", void 0);
W3mSwapView = __decorate27([
  customElement("w3m-swap-view")
], W3mSwapView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-switch-active-chain-view/styles.js
var styles_default18 = css`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-visual {
    width: var(--wui-wallet-image-size-lg);
    height: var(--wui-wallet-image-size-lg);
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    position: relative;
    overflow: hidden;
  }

  wui-visual::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition:
      opacity var(--wui-ease-out-power-2) var(--wui-duration-lg),
      transform var(--wui-ease-out-power-2) var(--wui-duration-lg);
    will-change: opacity, transform;
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }

  wui-link {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
  }

  .capitalize {
    text-transform: capitalize;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-switch-active-chain-view/index.js
var __decorate28 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSwitchActiveChainView = class W3mSwitchActiveChainView2 extends LitElement {
  constructor() {
    var _a, _b, _c, _d;
    super(...arguments);
    this.unsubscribe = [];
    this.switchToChain = (_a = RouterController.state.data) == null ? void 0 : _a.switchToChain;
    this.navigateTo = (_b = RouterController.state.data) == null ? void 0 : _b.navigateTo;
    this.navigateWithReplace = (_c = RouterController.state.data) == null ? void 0 : _c.navigateWithReplace;
    this.caipNetwork = (_d = RouterController.state.data) == null ? void 0 : _d.network;
    this.activeChain = ChainController.state.activeChain;
  }
  firstUpdated() {
    this.unsubscribe.push(ChainController.subscribeKey("activeChain", (val) => this.activeChain = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const switchedChainNameString = this.switchToChain ? ConstantsUtil.CHAIN_NAME_MAP[this.switchToChain] : "supported";
    if (!this.switchToChain) {
      return null;
    }
    const nextChainName = this.switchToChain === "eip155" ? "Ethereum" : this.switchToChain;
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" flexDirection="column" alignItems="center" gap="xl">
          <wui-visual
            name=${this.switchToChain === "eip155" ? "eth" : this.switchToChain}
          ></wui-visual>
          <wui-text
            data-testid=${`w3m-switch-active-chain-to-${nextChainName}`}
            variant="paragraph-500"
            color="fg-100"
            align="center"
            >Switch to <span class="capitalize">${nextChainName}</span></wui-text
          >
          <wui-text variant="small-400" color="fg-200" align="center">
            Connected wallet doesn't support connecting to ${switchedChainNameString} chain. You
            need to connect with a different wallet.
          </wui-text>
          <wui-button size="md" @click=${this.switchActiveChain.bind(this)}>Switch</wui-button>
        </wui-flex>
      </wui-flex>
    `;
  }
  async switchActiveChain() {
    if (!this.switchToChain) {
      return;
    }
    if (this.caipNetwork) {
      await ChainController.switchActiveNetwork(this.caipNetwork);
    } else {
      ChainController.setActiveNamespace(this.switchToChain);
    }
    ModalController.close();
    ModalController.open({
      view: "Connect"
    });
  }
};
W3mSwitchActiveChainView.styles = styles_default18;
__decorate28([
  property()
], W3mSwitchActiveChainView.prototype, "activeChain", void 0);
W3mSwitchActiveChainView = __decorate28([
  customElement("w3m-switch-active-chain-view")
], W3mSwitchActiveChainView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-swap-preview-view/styles.js
var styles_default19 = css`
  :host > wui-flex:first-child {
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }

  .preview-container,
  .details-container {
    width: 100%;
  }

  .token-image {
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
    border-radius: 12px;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  .token-item {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-xxs);
    padding: var(--wui-spacing-xs);
    height: 40px;
    border: none;
    border-radius: 80px;
    background: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    cursor: pointer;
    transition: background 0.2s linear;
  }

  .token-item:hover {
    background: var(--wui-color-gray-glass-005);
  }

  .preview-token-details-container {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s) var(--wui-spacing-xl);
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
  }

  .action-buttons-container {
    width: 100%;
    gap: var(--wui-spacing-xs);
  }

  .action-buttons-container > button {
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    height: 48px;
    border-radius: var(--wui-border-radius-xs);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  .action-buttons-container > button:disabled {
    opacity: 0.8;
    cursor: not-allowed;
  }

  .action-button > wui-loading-spinner {
    display: inline-block;
  }

  .cancel-button:hover,
  .action-button:hover {
    cursor: pointer;
  }

  .action-buttons-container > wui-button.cancel-button {
    flex: 2;
  }

  .action-buttons-container > wui-button.action-button {
    flex: 4;
  }

  .action-buttons-container > button.action-button > wui-text {
    color: white;
  }

  .details-container > wui-flex {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    width: 100%;
  }

  .details-container > wui-flex > button {
    border: none;
    background: none;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    transition: background 0.2s linear;
  }

  .details-container > wui-flex > button:hover {
    background: var(--wui-color-gray-glass-002);
  }

  .details-content-container {
    padding: var(--wui-spacing-1xs);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .details-content-container > wui-flex {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s) var(--wui-spacing-xl);
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-swap-preview-view/index.js
var __decorate29 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSwapPreviewView = class W3mSwapPreviewView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.detailsOpen = true;
    this.approvalTransaction = SwapController.state.approvalTransaction;
    this.swapTransaction = SwapController.state.swapTransaction;
    this.sourceToken = SwapController.state.sourceToken;
    this.sourceTokenAmount = SwapController.state.sourceTokenAmount ?? "";
    this.sourceTokenPriceInUSD = SwapController.state.sourceTokenPriceInUSD;
    this.toToken = SwapController.state.toToken;
    this.toTokenAmount = SwapController.state.toTokenAmount ?? "";
    this.toTokenPriceInUSD = SwapController.state.toTokenPriceInUSD;
    this.caipNetwork = ChainController.state.activeCaipNetwork;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.gasPriceInUSD = SwapController.state.gasPriceInUSD;
    this.inputError = SwapController.state.inputError;
    this.loadingQuote = SwapController.state.loadingQuote;
    this.loadingApprovalTransaction = SwapController.state.loadingApprovalTransaction;
    this.loadingBuildTransaction = SwapController.state.loadingBuildTransaction;
    this.loadingTransaction = SwapController.state.loadingTransaction;
    this.unsubscribe.push(...[
      AccountController.subscribeKey("balanceSymbol", (newBalanceSymbol) => {
        if (this.balanceSymbol !== newBalanceSymbol) {
          RouterController.goBack();
        }
      }),
      ChainController.subscribeKey("activeCaipNetwork", (newCaipNetwork) => {
        if (this.caipNetwork !== newCaipNetwork) {
          this.caipNetwork = newCaipNetwork;
        }
      }),
      SwapController.subscribe((newState) => {
        this.approvalTransaction = newState.approvalTransaction;
        this.swapTransaction = newState.swapTransaction;
        this.sourceToken = newState.sourceToken;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.toToken = newState.toToken;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.toTokenPriceInUSD = newState.toTokenPriceInUSD;
        this.sourceTokenAmount = newState.sourceTokenAmount ?? "";
        this.toTokenAmount = newState.toTokenAmount ?? "";
        this.inputError = newState.inputError;
        if (newState.inputError) {
          RouterController.goBack();
        }
        this.loadingQuote = newState.loadingQuote;
        this.loadingApprovalTransaction = newState.loadingApprovalTransaction;
        this.loadingBuildTransaction = newState.loadingBuildTransaction;
        this.loadingTransaction = newState.loadingTransaction;
      })
    ]);
  }
  firstUpdated() {
    SwapController.getTransaction();
    this.refreshTransaction();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe == null ? void 0 : unsubscribe());
    clearInterval(this.interval);
  }
  render() {
    return html`
      <wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]} gap="s">
        ${this.templateSwap()}
      </wui-flex>
    `;
  }
  refreshTransaction() {
    this.interval = setInterval(() => {
      if (!SwapController.getApprovalLoadingState()) {
        SwapController.getTransaction();
      }
    }, 1e4);
  }
  templateSwap() {
    var _a, _b, _c, _d;
    const sourceTokenText = `${UiHelperUtil.formatNumberToLocalString(parseFloat(this.sourceTokenAmount))} ${(_a = this.sourceToken) == null ? void 0 : _a.symbol}`;
    const toTokenText = `${UiHelperUtil.formatNumberToLocalString(parseFloat(this.toTokenAmount))} ${(_b = this.toToken) == null ? void 0 : _b.symbol}`;
    const sourceTokenValue = parseFloat(this.sourceTokenAmount) * this.sourceTokenPriceInUSD;
    const toTokenValue = parseFloat(this.toTokenAmount) * this.toTokenPriceInUSD - (this.gasPriceInUSD || 0);
    const sentPrice = UiHelperUtil.formatNumberToLocalString(sourceTokenValue);
    const receivePrice = UiHelperUtil.formatNumberToLocalString(toTokenValue);
    const loading = this.loadingQuote || this.loadingBuildTransaction || this.loadingTransaction || this.loadingApprovalTransaction;
    return html`
      <wui-flex flexDirection="column" alignItems="center" gap="l">
        <wui-flex class="preview-container" flexDirection="column" alignItems="flex-start" gap="l">
          <wui-flex
            class="preview-token-details-container"
            alignItems="center"
            justifyContent="space-between"
            gap="l"
          >
            <wui-flex flexDirection="column" alignItems="flex-start" gap="4xs">
              <wui-text variant="small-400" color="fg-150">Send</wui-text>
              <wui-text variant="paragraph-400" color="fg-100">$${sentPrice}</wui-text>
            </wui-flex>
            <wui-token-button
              flexDirection="row-reverse"
              text=${sourceTokenText}
              imageSrc=${(_c = this.sourceToken) == null ? void 0 : _c.logoUri}
            >
            </wui-token-button>
          </wui-flex>
          <wui-icon name="recycleHorizontal" color="fg-200" size="md"></wui-icon>
          <wui-flex
            class="preview-token-details-container"
            alignItems="center"
            justifyContent="space-between"
            gap="l"
          >
            <wui-flex flexDirection="column" alignItems="flex-start" gap="4xs">
              <wui-text variant="small-400" color="fg-150">Receive</wui-text>
              <wui-text variant="paragraph-400" color="fg-100">$${receivePrice}</wui-text>
            </wui-flex>
            <wui-token-button
              flexDirection="row-reverse"
              text=${toTokenText}
              imageSrc=${(_d = this.toToken) == null ? void 0 : _d.logoUri}
            >
            </wui-token-button>
          </wui-flex>
        </wui-flex>

        ${this.templateDetails()}

        <wui-flex flexDirection="row" alignItems="center" justifyContent="center" gap="xs">
          <wui-icon size="sm" color="fg-200" name="infoCircle"></wui-icon>
          <wui-text variant="small-400" color="fg-200">Review transaction carefully</wui-text>
        </wui-flex>

        <wui-flex
          class="action-buttons-container"
          flexDirection="row"
          alignItems="center"
          justifyContent="space-between"
          gap="xs"
        >
          <wui-button
            class="cancel-button"
            fullWidth
            size="lg"
            borderRadius="xs"
            variant="neutral"
            @click=${this.onCancelTransaction.bind(this)}
          >
            <wui-text variant="paragraph-600" color="fg-200">Cancel</wui-text>
          </wui-button>
          <wui-button
            class="action-button"
            fullWidth
            size="lg"
            borderRadius="xs"
            variant="main"
            ?loading=${loading}
            ?disabled=${loading}
            @click=${this.onSendTransaction.bind(this)}
          >
            <wui-text variant="paragraph-600" color="inverse-100">
              ${this.actionButtonLabel()}
            </wui-text>
          </wui-button>
        </wui-flex>
      </wui-flex>
    `;
  }
  templateDetails() {
    if (!this.sourceToken || !this.toToken || this.inputError) {
      return null;
    }
    return html`<w3m-swap-details .detailsOpen=${this.detailsOpen}></w3m-swap-details>`;
  }
  actionButtonLabel() {
    if (this.loadingApprovalTransaction) {
      return "Approving...";
    }
    if (this.approvalTransaction) {
      return "Approve";
    }
    return "Swap";
  }
  onCancelTransaction() {
    RouterController.goBack();
  }
  onSendTransaction() {
    if (this.approvalTransaction) {
      SwapController.sendTransactionForApproval(this.approvalTransaction);
    } else {
      SwapController.sendTransactionForSwap(this.swapTransaction);
    }
  }
};
W3mSwapPreviewView.styles = styles_default19;
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "interval", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "detailsOpen", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "approvalTransaction", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "swapTransaction", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "sourceToken", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "sourceTokenAmount", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "sourceTokenPriceInUSD", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "toToken", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "toTokenAmount", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "toTokenPriceInUSD", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "caipNetwork", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "balanceSymbol", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "gasPriceInUSD", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "inputError", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "loadingQuote", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "loadingApprovalTransaction", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "loadingBuildTransaction", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "loadingTransaction", void 0);
W3mSwapPreviewView = __decorate29([
  customElement("w3m-swap-preview-view")
], W3mSwapPreviewView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-swap-select-token-view/styles.js
var styles_default20 = css`
  :host {
    --tokens-scroll--top-opacity: 0;
    --tokens-scroll--bottom-opacity: 1;
    --suggested-tokens-scroll--left-opacity: 0;
    --suggested-tokens-scroll--right-opacity: 1;
  }

  :host > wui-flex:first-child {
    overflow-y: hidden;
    overflow-x: hidden;
    scrollbar-width: none;
    scrollbar-height: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  .suggested-tokens-container {
    overflow-x: auto;
    mask-image: linear-gradient(
      to right,
      rgba(0, 0, 0, calc(1 - var(--suggested-tokens-scroll--left-opacity))) 0px,
      rgba(200, 200, 200, calc(1 - var(--suggested-tokens-scroll--left-opacity))) 1px,
      black 50px,
      black 90px,
      black calc(100% - 90px),
      black calc(100% - 50px),
      rgba(155, 155, 155, calc(1 - var(--suggested-tokens-scroll--right-opacity))) calc(100% - 1px),
      rgba(0, 0, 0, calc(1 - var(--suggested-tokens-scroll--right-opacity))) 100%
    );
  }

  .suggested-tokens-container::-webkit-scrollbar {
    display: none;
  }

  .tokens-container {
    border-top: 1px solid var(--wui-color-gray-glass-005);
    height: 100%;
    max-height: 390px;
  }

  .tokens {
    width: 100%;
    overflow-y: auto;
    mask-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, calc(1 - var(--tokens-scroll--top-opacity))) 0px,
      rgba(200, 200, 200, calc(1 - var(--tokens-scroll--top-opacity))) 1px,
      black 50px,
      black 90px,
      black calc(100% - 90px),
      black calc(100% - 50px),
      rgba(155, 155, 155, calc(1 - var(--tokens-scroll--bottom-opacity))) calc(100% - 1px),
      rgba(0, 0, 0, calc(1 - var(--tokens-scroll--bottom-opacity))) 100%
    );
  }

  .network-search-input,
  .select-network-button {
    height: 40px;
  }

  .select-network-button {
    border: none;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-xs);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
    background-color: transparent;
    border-radius: var(--wui-border-radius-xxs);
    padding: var(--wui-spacing-xs);
    align-items: center;
    transition: background-color 0.2s linear;
  }

  .select-network-button:hover {
    background-color: var(--wui-color-gray-glass-002);
  }

  .select-network-button > wui-image {
    width: 26px;
    height: 26px;
    border-radius: var(--wui-border-radius-xs);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-swap-select-token-view/index.js
var __decorate30 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSwapSelectTokenView = class W3mSwapSelectTokenView2 extends LitElement {
  constructor() {
    var _a;
    super();
    this.unsubscribe = [];
    this.targetToken = (_a = RouterController.state.data) == null ? void 0 : _a.target;
    this.sourceToken = SwapController.state.sourceToken;
    this.sourceTokenAmount = SwapController.state.sourceTokenAmount;
    this.toToken = SwapController.state.toToken;
    this.myTokensWithBalance = SwapController.state.myTokensWithBalance;
    this.popularTokens = SwapController.state.popularTokens;
    this.searchValue = "";
    this.unsubscribe.push(...[
      SwapController.subscribe((newState) => {
        this.sourceToken = newState.sourceToken;
        this.toToken = newState.toToken;
        this.myTokensWithBalance = newState.myTokensWithBalance;
      })
    ]);
  }
  updated() {
    var _a, _b;
    const suggestedTokensContainer = (_a = this.renderRoot) == null ? void 0 : _a.querySelector(".suggested-tokens-container");
    suggestedTokensContainer == null ? void 0 : suggestedTokensContainer.addEventListener("scroll", this.handleSuggestedTokensScroll.bind(this));
    const tokensList = (_b = this.renderRoot) == null ? void 0 : _b.querySelector(".tokens");
    tokensList == null ? void 0 : tokensList.addEventListener("scroll", this.handleTokenListScroll.bind(this));
  }
  disconnectedCallback() {
    var _a, _b;
    super.disconnectedCallback();
    const suggestedTokensContainer = (_a = this.renderRoot) == null ? void 0 : _a.querySelector(".suggested-tokens-container");
    const tokensList = (_b = this.renderRoot) == null ? void 0 : _b.querySelector(".tokens");
    suggestedTokensContainer == null ? void 0 : suggestedTokensContainer.removeEventListener("scroll", this.handleSuggestedTokensScroll.bind(this));
    tokensList == null ? void 0 : tokensList.removeEventListener("scroll", this.handleTokenListScroll.bind(this));
    clearInterval(this.interval);
  }
  render() {
    return html`
      <wui-flex flexDirection="column" gap="s">
        ${this.templateSearchInput()} ${this.templateSuggestedTokens()} ${this.templateTokens()}
      </wui-flex>
    `;
  }
  onSelectToken(token) {
    if (this.targetToken === "sourceToken") {
      SwapController.setSourceToken(token);
    } else {
      SwapController.setToToken(token);
      if (this.sourceToken && this.sourceTokenAmount) {
        SwapController.swapTokens();
      }
    }
    RouterController.goBack();
  }
  templateSearchInput() {
    return html`
      <wui-flex .padding=${["3xs", "s", "0", "s"]} gap="xs">
        <wui-input-text
          data-testid="swap-select-token-search-input"
          class="network-search-input"
          size="sm"
          placeholder="Search token"
          icon="search"
          .value=${this.searchValue}
          @inputChange=${this.onSearchInputChange.bind(this)}
        ></wui-input-text>
      </wui-flex>
    `;
  }
  templateTokens() {
    const yourTokens = this.myTokensWithBalance ? Object.values(this.myTokensWithBalance) : [];
    const tokens = this.popularTokens ? this.popularTokens : [];
    const filteredYourTokens = this.filterTokensWithText(yourTokens, this.searchValue);
    const filteredTokens = this.filterTokensWithText(tokens, this.searchValue);
    return html`
      <wui-flex class="tokens-container">
        <wui-flex class="tokens" .padding=${["0", "s", "s", "s"]} flexDirection="column">
          ${(filteredYourTokens == null ? void 0 : filteredYourTokens.length) > 0 ? html`
                <wui-flex justifyContent="flex-start" padding="s">
                  <wui-text variant="paragraph-500" color="fg-200">Your tokens</wui-text>
                </wui-flex>
                ${filteredYourTokens.map((token) => {
      var _a, _b, _c;
      const selected = token.symbol === ((_a = this.sourceToken) == null ? void 0 : _a.symbol) || token.symbol === ((_b = this.toToken) == null ? void 0 : _b.symbol);
      return html`
                    <wui-token-list-item
                      data-testid="swap-select-token-item-${token.symbol}"
                      name=${token.name}
                      ?disabled=${selected}
                      symbol=${token.symbol}
                      price=${token == null ? void 0 : token.price}
                      amount=${(_c = token == null ? void 0 : token.quantity) == null ? void 0 : _c.numeric}
                      imageSrc=${token.logoUri}
                      @click=${() => {
        if (!selected) {
          this.onSelectToken(token);
        }
      }}
                    >
                    </wui-token-list-item>
                  `;
    })}
              ` : null}

          <wui-flex justifyContent="flex-start" padding="s">
            <wui-text variant="paragraph-500" color="fg-200">Tokens</wui-text>
          </wui-flex>
          ${(filteredTokens == null ? void 0 : filteredTokens.length) > 0 ? filteredTokens.map((token) => html`
                  <wui-token-list-item
                    data-testid="swap-select-token-item-${token.symbol}"
                    name=${token.name}
                    symbol=${token.symbol}
                    imageSrc=${token.logoUri}
                    @click=${() => this.onSelectToken(token)}
                  >
                  </wui-token-list-item>
                `) : null}
        </wui-flex>
      </wui-flex>
    `;
  }
  templateSuggestedTokens() {
    const tokens = SwapController.state.suggestedTokens ? SwapController.state.suggestedTokens.slice(0, 8) : null;
    if (!tokens) {
      return null;
    }
    return html`
      <wui-flex class="suggested-tokens-container" .padding=${["0", "s", "0", "s"]} gap="xs">
        ${tokens.map((token) => html`
            <wui-token-button
              text=${token.symbol}
              imageSrc=${token.logoUri}
              @click=${() => this.onSelectToken(token)}
            >
            </wui-token-button>
          `)}
      </wui-flex>
    `;
  }
  onSearchInputChange(event) {
    this.searchValue = event.detail;
  }
  handleSuggestedTokensScroll() {
    var _a;
    const container = (_a = this.renderRoot) == null ? void 0 : _a.querySelector(".suggested-tokens-container");
    if (!container) {
      return;
    }
    container.style.setProperty("--suggested-tokens-scroll--left-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollLeft).toString());
    container.style.setProperty("--suggested-tokens-scroll--right-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollWidth - container.scrollLeft - container.offsetWidth).toString());
  }
  handleTokenListScroll() {
    var _a;
    const container = (_a = this.renderRoot) == null ? void 0 : _a.querySelector(".tokens");
    if (!container) {
      return;
    }
    container.style.setProperty("--tokens-scroll--top-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollTop).toString());
    container.style.setProperty("--tokens-scroll--bottom-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollHeight - container.scrollTop - container.offsetHeight).toString());
  }
  filterTokensWithText(tokens, text) {
    return tokens.filter((token) => `${token.symbol} ${token.name} ${token.address}`.toLowerCase().includes(text.toLowerCase()));
  }
};
W3mSwapSelectTokenView.styles = styles_default20;
__decorate30([
  state()
], W3mSwapSelectTokenView.prototype, "interval", void 0);
__decorate30([
  state()
], W3mSwapSelectTokenView.prototype, "targetToken", void 0);
__decorate30([
  state()
], W3mSwapSelectTokenView.prototype, "sourceToken", void 0);
__decorate30([
  state()
], W3mSwapSelectTokenView.prototype, "sourceTokenAmount", void 0);
__decorate30([
  state()
], W3mSwapSelectTokenView.prototype, "toToken", void 0);
__decorate30([
  state()
], W3mSwapSelectTokenView.prototype, "myTokensWithBalance", void 0);
__decorate30([
  state()
], W3mSwapSelectTokenView.prototype, "popularTokens", void 0);
__decorate30([
  state()
], W3mSwapSelectTokenView.prototype, "searchValue", void 0);
W3mSwapSelectTokenView = __decorate30([
  customElement("w3m-swap-select-token-view")
], W3mSwapSelectTokenView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-transactions-view/styles.js
var styles_default21 = css`
  :host > wui-flex:first-child {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-transactions-view/index.js
var __decorate31 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mTransactionsView = class W3mTransactionsView2 extends LitElement {
  render() {
    return html`
      <wui-flex flexDirection="column" .padding=${["0", "m", "m", "m"]} gap="s">
        <w3m-activity-list page="activity"></w3m-activity-list>
      </wui-flex>
    `;
  }
};
W3mTransactionsView.styles = styles_default21;
W3mTransactionsView = __decorate31([
  customElement("w3m-transactions-view")
], W3mTransactionsView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-what-is-a-network-view/index.js
var __decorate32 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var data = [
  {
    images: ["network", "layers", "system"],
    title: "The system’s nuts and bolts",
    text: "A network is what brings the blockchain to life, as this technical infrastructure allows apps to access the ledger and smart contract services."
  },
  {
    images: ["noun", "defiAlt", "dao"],
    title: "Designed for different uses",
    text: "Each network is designed differently, and may therefore suit certain apps and experiences."
  }
];
var W3mWhatIsANetworkView = class W3mWhatIsANetworkView2 extends LitElement {
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data}></w3m-help-widget>
        <wui-button
          variant="main"
          size="md"
          @click=${() => {
      CoreHelperUtil.openHref("https://ethereum.org/en/developers/docs/networks/", "_blank");
    }}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-button>
      </wui-flex>
    `;
  }
};
W3mWhatIsANetworkView = __decorate32([
  customElement("w3m-what-is-a-network-view")
], W3mWhatIsANetworkView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-what-is-a-wallet-view/index.js
var __decorate33 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var data2 = [
  {
    images: ["login", "profile", "lock"],
    title: "One login for all of web3",
    text: "Log in to any app by connecting your wallet. Say goodbye to countless passwords!"
  },
  {
    images: ["defi", "nft", "eth"],
    title: "A home for your digital assets",
    text: "A wallet lets you store, send and receive digital assets like cryptocurrencies and NFTs."
  },
  {
    images: ["browser", "noun", "dao"],
    title: "Your gateway to a new web",
    text: "With your wallet, you can explore and interact with DeFi, NFTs, DAOs, and much more."
  }
];
var W3mWhatIsAWalletView = class W3mWhatIsAWalletView2 extends LitElement {
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data2}></w3m-help-widget>
        <wui-button variant="main" size="md" @click=${this.onGetWallet.bind(this)}>
          <wui-icon color="inherit" slot="iconLeft" name="wallet"></wui-icon>
          Get a wallet
        </wui-button>
      </wui-flex>
    `;
  }
  onGetWallet() {
    EventsController.sendEvent({ type: "track", event: "CLICK_GET_WALLET" });
    RouterController.push("GetWallet");
  }
};
W3mWhatIsAWalletView = __decorate33([
  customElement("w3m-what-is-a-wallet-view")
], W3mWhatIsAWalletView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-what-is-a-buy-view/index.js
var __decorate34 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mWhatIsABuyView = class W3mWhatIsABuyView2 extends LitElement {
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "3xl", "xl", "3xl"]}
        alignItems="center"
        gap="xl"
      >
        <wui-visual name="onrampCard"></wui-visual>
        <wui-flex flexDirection="column" gap="xs" alignItems="center">
          <wui-text align="center" variant="paragraph-500" color="fg-100">
            Quickly and easily buy digital assets!
          </wui-text>
          <wui-text align="center" variant="small-400" color="fg-200">
            Simply select your preferred onramp provider and add digital assets to your account
            using your credit card or bank transfer
          </wui-text>
        </wui-flex>
        <wui-button @click=${RouterController.goBack}>
          <wui-icon size="sm" color="inherit" name="add" slot="iconLeft"></wui-icon>
          Buy
        </wui-button>
      </wui-flex>
    `;
  }
};
W3mWhatIsABuyView = __decorate34([
  customElement("w3m-what-is-a-buy-view")
], W3mWhatIsABuyView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/w3m-email-otp-widget/styles.js
var styles_default22 = css`
  wui-loading-spinner {
    margin: 9px auto;
  }

  .email-display,
  .email-display wui-text {
    max-width: 100%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/w3m-email-otp-widget/index.js
var __decorate35 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var OTP_LENGTH = 6;
var W3mEmailOtpWidget = class W3mEmailOtpWidget2 extends LitElement {
  firstUpdated() {
    this.startOTPTimeout();
  }
  disconnectedCallback() {
    clearTimeout(this.OTPTimeout);
  }
  constructor() {
    var _a;
    super();
    this.loading = false;
    this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
    this.error = "";
    this.otp = "";
    this.email = (_a = RouterController.state.data) == null ? void 0 : _a.email;
    this.authConnector = ConnectorController.getAuthConnector();
  }
  render() {
    if (!this.email) {
      throw new Error("w3m-email-otp-widget: No email provided");
    }
    const isResendDisabled = Boolean(this.timeoutTimeLeft);
    const footerLabels = this.getFooterLabels(isResendDisabled);
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["l", "0", "l", "0"]}
        gap="l"
      >
        <wui-flex
          class="email-display"
          flexDirection="column"
          alignItems="center"
          .padding=${["0", "xl", "0", "xl"]}
        >
          <wui-text variant="paragraph-400" color="fg-100" align="center">
            Enter the code we sent to
          </wui-text>
          <wui-text variant="paragraph-500" color="fg-100" lineClamp="1" align="center">
            ${this.email}
          </wui-text>
        </wui-flex>

        <wui-text variant="small-400" color="fg-200">The code expires in 20 minutes</wui-text>

        ${this.loading ? html`<wui-loading-spinner size="xl" color="accent-100"></wui-loading-spinner>` : html` <wui-flex flexDirection="column" alignItems="center" gap="xs">
              <wui-otp
                dissabled
                length="6"
                @inputChange=${this.onOtpInputChange.bind(this)}
                .otp=${this.otp}
              ></wui-otp>
              ${this.error ? html`
                    <wui-text variant="small-400" align="center" color="error-100">
                      ${this.error}. Try Again
                    </wui-text>
                  ` : null}
            </wui-flex>`}

        <wui-flex alignItems="center" gap="xs">
          <wui-text variant="small-400" color="fg-200">${footerLabels.title}</wui-text>
          <wui-link @click=${this.onResendCode.bind(this)} .disabled=${isResendDisabled}>
            ${footerLabels.action}
          </wui-link>
        </wui-flex>
      </wui-flex>
    `;
  }
  startOTPTimeout() {
    this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
    this.OTPTimeout = setInterval(() => {
      if (this.timeoutTimeLeft > 0) {
        this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
      } else {
        clearInterval(this.OTPTimeout);
      }
    }, 1e3);
  }
  async onOtpInputChange(event) {
    var _a;
    try {
      if (!this.loading) {
        this.otp = event.detail;
        if (this.authConnector && this.otp.length === OTP_LENGTH) {
          this.loading = true;
          await ((_a = this.onOtpSubmit) == null ? void 0 : _a.call(this, this.otp));
        }
      }
    } catch (error) {
      this.error = CoreHelperUtil.parseError(error);
      this.loading = false;
    }
  }
  async onResendCode() {
    try {
      if (this.onOtpResend) {
        if (!this.loading && !this.timeoutTimeLeft) {
          this.error = "";
          this.otp = "";
          const authConnector = ConnectorController.getAuthConnector();
          if (!authConnector || !this.email) {
            throw new Error("w3m-email-otp-widget: Unable to resend email");
          }
          this.loading = true;
          await this.onOtpResend(this.email);
          this.startOTPTimeout();
          SnackController.showSuccess("Code email resent");
        }
      } else if (this.onStartOver) {
        this.onStartOver();
      }
    } catch (error) {
      SnackController.showError(error);
    } finally {
      this.loading = false;
    }
  }
  getFooterLabels(isResendDisabled) {
    if (this.onStartOver) {
      return {
        title: "Something wrong?",
        action: `Try again ${isResendDisabled ? `in ${this.timeoutTimeLeft}s` : ""}`
      };
    }
    return {
      title: `Didn't receive it?`,
      action: `Resend ${isResendDisabled ? `in ${this.timeoutTimeLeft}s` : "Code"}`
    };
  }
};
W3mEmailOtpWidget.styles = styles_default22;
__decorate35([
  state()
], W3mEmailOtpWidget.prototype, "loading", void 0);
__decorate35([
  state()
], W3mEmailOtpWidget.prototype, "timeoutTimeLeft", void 0);
__decorate35([
  state()
], W3mEmailOtpWidget.prototype, "error", void 0);
W3mEmailOtpWidget = __decorate35([
  customElement("w3m-email-otp-widget")
], W3mEmailOtpWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-email-verify-otp-view/index.js
var __decorate36 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mEmailVerifyOtpView = class W3mEmailVerifyOtpView2 extends W3mEmailOtpWidget {
  constructor() {
    super(...arguments);
    this.onOtpSubmit = async (otp) => {
      try {
        if (this.authConnector) {
          await this.authConnector.provider.connectOtp({ otp });
          EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_PASS" });
          if (ChainController.state.activeChain) {
            await ConnectionController.connectExternal(this.authConnector, ChainController.state.activeChain);
          } else {
            throw new Error("Active chain is not set on ChainControll");
          }
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: { method: "email", name: this.authConnector.name || "Unknown" }
          });
          if (!OptionsController.state.isSiweEnabled) {
            ModalController.close();
          }
        }
      } catch (error) {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_FAIL" });
        throw error;
      }
    };
    this.onOtpResend = async (email) => {
      if (this.authConnector) {
        await this.authConnector.provider.connectEmail({ email });
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
      }
    };
  }
};
W3mEmailVerifyOtpView = __decorate36([
  customElement("w3m-email-verify-otp-view")
], W3mEmailVerifyOtpView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-email-verify-device-view/styles.js
var styles_default23 = css`
  wui-icon-box {
    height: var(--wui-icon-box-size-xl);
    width: var(--wui-icon-box-size-xl);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-email-verify-device-view/index.js
var __decorate37 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mEmailVerifyDeviceView = class W3mEmailVerifyDeviceView2 extends LitElement {
  constructor() {
    var _a;
    super();
    this.email = (_a = RouterController.state.data) == null ? void 0 : _a.email;
    this.authConnector = ConnectorController.getAuthConnector();
    this.loading = false;
    this.listenForDeviceApproval();
  }
  render() {
    if (!this.email) {
      throw new Error("w3m-email-verify-device-view: No email provided");
    }
    if (!this.authConnector) {
      throw new Error("w3m-email-verify-device-view: No auth connector provided");
    }
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xxl", "s", "xxl", "s"]}
        gap="l"
      >
        <wui-icon-box
          size="xl"
          iconcolor="accent-100"
          backgroundcolor="accent-100"
          icon="verify"
          background="opaque"
        ></wui-icon-box>

        <wui-flex flexDirection="column" alignItems="center" gap="s">
          <wui-flex flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-400" color="fg-100">
              Approve the login link we sent to
            </wui-text>
            <wui-text variant="paragraph-400" color="fg-100"><b>${this.email}</b></wui-text>
          </wui-flex>

          <wui-text variant="small-400" color="fg-200" align="center">
            The code expires in 20 minutes
          </wui-text>

          <wui-flex alignItems="center" id="w3m-resend-section" gap="xs">
            <wui-text variant="small-400" color="fg-100" align="center">
              Didn't receive it?
            </wui-text>
            <wui-link @click=${this.onResendCode.bind(this)} .disabled=${this.loading}>
              Resend email
            </wui-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `;
  }
  async listenForDeviceApproval() {
    if (this.authConnector) {
      try {
        await this.authConnector.provider.connectDevice();
        EventsController.sendEvent({ type: "track", event: "DEVICE_REGISTERED_FOR_EMAIL" });
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
        RouterController.replace("EmailVerifyOtp", { email: this.email });
      } catch (error) {
        RouterController.goBack();
      }
    }
  }
  async onResendCode() {
    try {
      if (!this.loading) {
        if (!this.authConnector || !this.email) {
          throw new Error("w3m-email-login-widget: Unable to resend email");
        }
        this.loading = true;
        await this.authConnector.provider.connectEmail({ email: this.email });
        this.listenForDeviceApproval();
        SnackController.showSuccess("Code email resent");
      }
    } catch (error) {
      SnackController.showError(error);
    } finally {
      this.loading = false;
    }
  }
};
W3mEmailVerifyDeviceView.styles = styles_default23;
__decorate37([
  state()
], W3mEmailVerifyDeviceView.prototype, "loading", void 0);
W3mEmailVerifyDeviceView = __decorate37([
  customElement("w3m-email-verify-device-view")
], W3mEmailVerifyDeviceView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-approve-transaction-view/styles.js
var styles_default24 = css`
  div {
    width: 100%;
  }

  [data-ready='false'] {
    transform: scale(1.05);
  }

  @media (max-width: 430px) {
    [data-ready='false'] {
      transform: translateY(-50px);
    }
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-approve-transaction-view/index.js
var __decorate38 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var PAGE_HEIGHT = 600;
var PAGE_WIDTH = 360;
var HEADER_HEIGHT = 64;
var W3mApproveTransactionView = class W3mApproveTransactionView2 extends LitElement {
  constructor() {
    super();
    this.bodyObserver = void 0;
    this.unsubscribe = [];
    this.iframe = document.getElementById("w3m-iframe");
    this.ready = false;
    this.unsubscribe.push(...[
      ModalController.subscribeKey("open", (isOpen) => {
        if (!isOpen) {
          this.onHideIframe();
          RouterController.popTransactionStack();
        }
      }),
      ModalController.subscribeKey("shake", (val) => {
        if (val) {
          this.iframe.style.animation = `w3m-shake 500ms var(--wui-ease-out-power-2)`;
        } else {
          this.iframe.style.animation = "none";
        }
      })
    ]);
  }
  disconnectedCallback() {
    var _a;
    this.onHideIframe();
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    (_a = this.bodyObserver) == null ? void 0 : _a.unobserve(window.document.body);
  }
  async firstUpdated() {
    var _a;
    await this.syncTheme();
    this.iframe.style.display = "block";
    const container = (_a = this == null ? void 0 : this.renderRoot) == null ? void 0 : _a.querySelector("div");
    this.bodyObserver = new ResizeObserver((entries) => {
      var _a2, _b;
      const contentBoxSize = (_a2 = entries == null ? void 0 : entries[0]) == null ? void 0 : _a2.contentBoxSize;
      const width = (_b = contentBoxSize == null ? void 0 : contentBoxSize[0]) == null ? void 0 : _b.inlineSize;
      this.iframe.style.height = `${PAGE_HEIGHT}px`;
      container.style.height = `${PAGE_HEIGHT}px`;
      if (width && width <= 430) {
        this.iframe.style.width = "100%";
        this.iframe.style.left = "0px";
        this.iframe.style.bottom = "0px";
        this.iframe.style.top = "unset";
      } else {
        this.iframe.style.width = `${PAGE_WIDTH}px`;
        this.iframe.style.left = `calc(50% - ${PAGE_WIDTH / 2}px)`;
        this.iframe.style.top = `calc(50% - ${PAGE_HEIGHT / 2}px + ${HEADER_HEIGHT / 2}px)`;
        this.iframe.style.bottom = "unset";
      }
      this.ready = true;
      this.onShowIframe();
    });
    this.bodyObserver.observe(window.document.body);
  }
  render() {
    return html`<div data-ready=${this.ready} id="w3m-frame-container"></div>`;
  }
  onShowIframe() {
    const isMobile = window.innerWidth <= 430;
    this.iframe.style.animation = isMobile ? "w3m-iframe-zoom-in-mobile 200ms var(--wui-ease-out-power-2)" : "w3m-iframe-zoom-in 200ms var(--wui-ease-out-power-2)";
  }
  onHideIframe() {
    this.iframe.style.display = "none";
    this.iframe.style.animation = "w3m-iframe-fade-out 200ms var(--wui-ease-out-power-2)";
  }
  async syncTheme() {
    const authConnector = ConnectorController.getAuthConnector();
    if (authConnector) {
      const themeMode = ThemeController.getSnapshot().themeMode;
      const themeVariables = ThemeController.getSnapshot().themeVariables;
      await authConnector.provider.syncTheme({
        themeVariables,
        w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
      });
    }
  }
};
W3mApproveTransactionView.styles = styles_default24;
__decorate38([
  state()
], W3mApproveTransactionView.prototype, "ready", void 0);
W3mApproveTransactionView = __decorate38([
  customElement("w3m-approve-transaction-view")
], W3mApproveTransactionView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-upgrade-wallet-view/index.js
var __decorate39 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mUpgradeWalletView = class W3mUpgradeWalletView2 extends LitElement {
  render() {
    return html`
      <wui-flex flexDirection="column" alignItems="center" gap="xl" padding="xl">
        <wui-text variant="paragraph-400" color="fg-100">Follow the instructions on</wui-text>
        <wui-chip
          icon="externalLink"
          variant="fill"
          href=${ConstantsUtil2.SECURE_SITE_DASHBOARD}
          imageSrc=${ConstantsUtil2.SECURE_SITE_FAVICON}
          data-testid="w3m-secure-website-button"
        >
        </wui-chip>
        <wui-text variant="small-400" color="fg-200">
          You will have to reconnect for security reasons
        </wui-text>
      </wui-flex>
    `;
  }
};
W3mUpgradeWalletView = __decorate39([
  customElement("w3m-upgrade-wallet-view")
], W3mUpgradeWalletView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-upgrade-to-smart-account-view/index.js
var __decorate40 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mUpgradeToSmartAccountView = class W3mUpgradeToSmartAccountView2 extends LitElement {
  constructor() {
    super(...arguments);
    this.authConnector = ConnectorController.getAuthConnector();
    this.loading = false;
    this.setPreferSmartAccount = async () => {
      if (this.authConnector) {
        try {
          this.loading = true;
          await ConnectionController.setPreferredAccountType(W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT);
          this.loading = false;
          RouterController.push("Account");
        } catch (e2) {
          SnackController.showError("Error upgrading to smart account");
        }
      }
    };
  }
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="xxl"
        .padding=${["0", "0", "l", "0"]}
      >
        ${this.onboardingTemplate()} ${this.buttonsTemplate()}
        <wui-link
          @click=${() => {
      CoreHelperUtil.openHref(NavigationUtil.URLS.FAQ, "_blank");
    }}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-link>
      </wui-flex>
    `;
  }
  onboardingTemplate() {
    return html` <wui-flex
      flexDirection="column"
      gap="xxl"
      alignItems="center"
      .padding=${["0", "xxl", "0", "xxl"]}
    >
      <wui-flex gap="s" alignItems="center" justifyContent="center">
        <wui-visual name="google"></wui-visual>
        <wui-visual name="pencil"></wui-visual>
        <wui-visual name="lightbulb"></wui-visual>
      </wui-flex>
      <wui-flex flexDirection="column" alignItems="center" gap="s">
        <wui-text align="center" variant="medium-600" color="fg-100">
          Discover Smart Accounts
        </wui-text>
        <wui-text align="center" variant="paragraph-400" color="fg-100">
          Access advanced features such as username, social login, improved security and a smoother
          user experience!
        </wui-text>
      </wui-flex>
    </wui-flex>`;
  }
  buttonsTemplate() {
    return html`<wui-flex .padding=${["0", "2l", "0", "2l"]} gap="s">
      <wui-button
        variant="accent"
        @click=${this.redirectToAccount.bind(this)}
        size="lg"
        borderRadius="xs"
      >
        Do it later
      </wui-button>
      <wui-button
        .loading=${this.loading}
        size="lg"
        borderRadius="xs"
        @click=${this.setPreferSmartAccount.bind(this)}
        >Continue
      </wui-button>
    </wui-flex>`;
  }
  redirectToAccount() {
    RouterController.push("Account");
  }
};
__decorate40([
  state()
], W3mUpgradeToSmartAccountView.prototype, "authConnector", void 0);
__decorate40([
  state()
], W3mUpgradeToSmartAccountView.prototype, "loading", void 0);
W3mUpgradeToSmartAccountView = __decorate40([
  customElement("w3m-upgrade-to-smart-account-view")
], W3mUpgradeToSmartAccountView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-update-email-wallet-view/styles.js
var styles_default25 = css`
  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-update-email-wallet-view/index.js
var __decorate41 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mUpdateEmailWalletView = class W3mUpdateEmailWalletView2 extends LitElement {
  constructor() {
    var _a;
    super(...arguments);
    this.formRef = createRef();
    this.initialEmail = ((_a = RouterController.state.data) == null ? void 0 : _a.email) ?? "";
    this.email = "";
    this.loading = false;
  }
  firstUpdated() {
    var _a;
    (_a = this.formRef.value) == null ? void 0 : _a.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        this.onSubmitEmail(event);
      }
    });
  }
  render() {
    const showSubmit = !this.loading && this.email.length > 3 && this.email !== this.initialEmail;
    return html`
      <wui-flex flexDirection="column" padding="m" gap="m">
        <form ${ref2(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
          <wui-email-input
            value=${this.initialEmail}
            .disabled=${this.loading}
            @inputChange=${this.onEmailInputChange.bind(this)}
          >
          </wui-email-input>
          <input type="submit" hidden />
        </form>

        <wui-flex gap="s">
          <wui-button size="md" variant="neutral" fullWidth @click=${RouterController.goBack}>
            Cancel
          </wui-button>

          <wui-button
            size="md"
            variant="main"
            fullWidth
            @click=${this.onSubmitEmail.bind(this)}
            .disabled=${!showSubmit}
            .loading=${this.loading}
          >
            Save
          </wui-button>
        </wui-flex>
      </wui-flex>
    `;
  }
  onEmailInputChange(event) {
    this.email = event.detail;
  }
  async onSubmitEmail(event) {
    try {
      if (this.loading) {
        return;
      }
      this.loading = true;
      event.preventDefault();
      const authConnector = ConnectorController.getAuthConnector();
      if (!authConnector) {
        throw new Error("w3m-update-email-wallet: Auth connector not found");
      }
      const response = await authConnector.provider.updateEmail({ email: this.email });
      EventsController.sendEvent({ type: "track", event: "EMAIL_EDIT" });
      if (response.action === "VERIFY_SECONDARY_OTP") {
        RouterController.push("UpdateEmailSecondaryOtp", {
          email: this.initialEmail,
          newEmail: this.email
        });
      } else {
        RouterController.push("UpdateEmailPrimaryOtp", {
          email: this.initialEmail,
          newEmail: this.email
        });
      }
    } catch (error) {
      SnackController.showError(error);
      this.loading = false;
    }
  }
};
W3mUpdateEmailWalletView.styles = styles_default25;
__decorate41([
  state()
], W3mUpdateEmailWalletView.prototype, "email", void 0);
__decorate41([
  state()
], W3mUpdateEmailWalletView.prototype, "loading", void 0);
W3mUpdateEmailWalletView = __decorate41([
  customElement("w3m-update-email-wallet-view")
], W3mUpdateEmailWalletView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-update-email-primary-otp-view/index.js
var __decorate42 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mUpdateEmailPrimaryOtpView = class W3mUpdateEmailPrimaryOtpView2 extends W3mEmailOtpWidget {
  constructor() {
    var _a;
    super();
    this.email = (_a = RouterController.state.data) == null ? void 0 : _a.email;
    this.onOtpSubmit = async (otp) => {
      try {
        if (this.authConnector) {
          await this.authConnector.provider.updateEmailPrimaryOtp({ otp });
          EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_PASS" });
          RouterController.replace("UpdateEmailSecondaryOtp", RouterController.state.data);
        }
      } catch (error) {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_FAIL" });
        throw error;
      }
    };
    this.onStartOver = () => {
      RouterController.replace("UpdateEmailWallet", RouterController.state.data);
    };
  }
};
W3mUpdateEmailPrimaryOtpView = __decorate42([
  customElement("w3m-update-email-primary-otp-view")
], W3mUpdateEmailPrimaryOtpView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-update-email-secondary-otp-view/index.js
var __decorate43 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mUpdateEmailSecondaryOtpView = class W3mUpdateEmailSecondaryOtpView2 extends W3mEmailOtpWidget {
  constructor() {
    var _a;
    super();
    this.email = (_a = RouterController.state.data) == null ? void 0 : _a.newEmail;
    this.onOtpSubmit = async (otp) => {
      try {
        if (this.authConnector) {
          await this.authConnector.provider.updateEmailSecondaryOtp({ otp });
          EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_PASS" });
          RouterController.reset("Account");
        }
      } catch (error) {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_FAIL" });
        throw error;
      }
    };
    this.onStartOver = () => {
      RouterController.replace("UpdateEmailWallet", RouterController.state.data);
    };
  }
};
W3mUpdateEmailSecondaryOtpView = __decorate43([
  customElement("w3m-update-email-secondary-otp-view")
], W3mUpdateEmailSecondaryOtpView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-unsupported-chain-view/styles.js
var styles_default26 = css`
  :host > wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-unsupported-chain-view/index.js
var __decorate44 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mUnsupportedChainView = class W3mUnsupportedChainView2 extends LitElement {
  constructor() {
    var _a;
    super(...arguments);
    this.swapUnsupportedChain = (_a = RouterController.state.data) == null ? void 0 : _a.swapUnsupportedChain;
    this.disconecting = false;
  }
  render() {
    return html`
      <wui-flex class="container" flexDirection="column" gap="0">
        <wui-flex
          class="container"
          flexDirection="column"
          .padding=${["m", "xl", "xs", "xl"]}
          alignItems="center"
          gap="xl"
        >
          ${this.descriptionTemplate()}
        </wui-flex>

        <wui-flex flexDirection="column" padding="s" gap="xs">
          ${this.networksTemplate()}
        </wui-flex>

        <wui-separator text="or"></wui-separator>
        <wui-flex flexDirection="column" padding="s" gap="xs">
          <wui-list-item
            variant="icon"
            iconVariant="overlay"
            icon="disconnect"
            ?chevron=${false}
            .loading=${this.disconecting}
            @click=${this.onDisconnect.bind(this)}
            data-testid="disconnect-button"
          >
            <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
          </wui-list-item>
        </wui-flex>
      </wui-flex>
    `;
  }
  descriptionTemplate() {
    if (this.swapUnsupportedChain) {
      return html`
        <wui-text variant="small-400" color="fg-200" align="center">
          The swap feature doesn’t support your current network. Switch to an available option to
          continue.
        </wui-text>
      `;
    }
    return html`
      <wui-text variant="small-400" color="fg-200" align="center">
        This app doesn’t support your current network. Switch to an available option to continue.
      </wui-text>
    `;
  }
  networksTemplate() {
    const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const approvedCaipNetworkIds = ChainController.getAllApprovedCaipNetworkIds();
    const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    const filteredNetworks = this.swapUnsupportedChain ? sortedNetworks.filter((network) => ConstantsUtil2.SWAP_SUPPORTED_NETWORKS.includes(network.caipNetworkId)) : sortedNetworks;
    return filteredNetworks.map((network) => html`
        <wui-list-network
          imageSrc=${ifDefined(AssetUtil.getNetworkImage(network))}
          name=${network.name ?? "Unknown"}
          @click=${() => this.onSwitchNetwork(network)}
        >
        </wui-list-network>
      `);
  }
  async onDisconnect() {
    try {
      this.disconecting = true;
      await ConnectionController.disconnect();
      EventsController.sendEvent({
        type: "track",
        event: "DISCONNECT_SUCCESS"
      });
      ModalController.close();
    } catch {
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_ERROR" });
      SnackController.showError("Failed to disconnect");
    } finally {
      this.disconecting = false;
    }
  }
  async onSwitchNetwork(network) {
    const caipAddress = AccountController.state.caipAddress;
    const approvedCaipNetworkIds = ChainController.getAllApprovedCaipNetworkIds();
    const supportsAllNetworks = ChainController.getNetworkProp("supportsAllNetworks", network.chainNamespace);
    const caipNetwork = ChainController.state.activeCaipNetwork;
    const routerData = RouterController.state.data;
    if (caipAddress && (caipNetwork == null ? void 0 : caipNetwork.caipNetworkId) !== network.caipNetworkId) {
      if (approvedCaipNetworkIds == null ? void 0 : approvedCaipNetworkIds.includes(network.caipNetworkId)) {
        await ChainController.switchActiveNetwork(network);
      } else if (supportsAllNetworks) {
        RouterController.push("SwitchNetwork", { ...routerData, network });
      }
    } else if (!caipAddress) {
      ChainController.setActiveCaipNetwork(network);
      RouterController.push("Connect");
    }
  }
};
W3mUnsupportedChainView.styles = styles_default26;
__decorate44([
  state()
], W3mUnsupportedChainView.prototype, "disconecting", void 0);
W3mUnsupportedChainView = __decorate44([
  customElement("w3m-unsupported-chain-view")
], W3mUnsupportedChainView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-receive-view/styles.js
var styles_default27 = css`
  wui-compatible-network {
    margin-top: var(--wui-spacing-l);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-receive-view/index.js
var __decorate45 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mWalletReceiveView = class W3mWalletReceiveView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.address = AccountController.state.address;
    this.profileName = AccountController.state.profileName;
    this.network = ChainController.state.activeCaipNetwork;
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileName = val.profileName;
          this.preferredAccountType = val.preferredAccountType;
        } else {
          SnackController.showError("Account not found");
        }
      })
    ], ChainController.subscribeKey("activeCaipNetwork", (val) => {
      if (val == null ? void 0 : val.id) {
        this.network = val;
      }
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!this.address) {
      throw new Error("w3m-wallet-receive-view: No account provided");
    }
    const networkImage = AssetUtil.getNetworkImage(this.network);
    return html` <wui-flex
      flexDirection="column"
      .padding=${["0", "l", "l", "l"]}
      alignItems="center"
    >
      <wui-chip-button
        data-testid="receive-address-copy-button"
        @click=${this.onCopyClick.bind(this)}
        text=${UiHelperUtil.getTruncateString({
      string: this.profileName || this.address || "",
      charsStart: this.profileName ? 18 : 4,
      charsEnd: this.profileName ? 0 : 4,
      truncate: this.profileName ? "end" : "middle"
    })}
        icon="copy"
        size="sm"
        imageSrc=${networkImage ? networkImage : ""}
        variant="gray"
      ></wui-chip-button>
      <wui-flex
        flexDirection="column"
        .padding=${["l", "0", "0", "0"]}
        alignItems="center"
        gap="s"
      >
        <wui-qr-code
          size=${232}
          theme=${ThemeController.state.themeMode}
          uri=${this.address}
          ?arenaClear=${true}
          data-testid="wui-qr-code"
        ></wui-qr-code>
        <wui-text variant="paragraph-500" color="fg-100" align="center">
          Copy your address or scan this QR code
        </wui-text>
      </wui-flex>
      ${this.networkTemplate()}
    </wui-flex>`;
  }
  networkTemplate() {
    var _a;
    const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const isNetworkEnabledForSmartAccounts = ChainController.checkIfSmartAccountEnabled();
    const caipNetwork = ChainController.state.activeCaipNetwork;
    if (this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT && isNetworkEnabledForSmartAccounts) {
      if (!caipNetwork) {
        return null;
      }
      return html`<wui-compatible-network
        @click=${this.onReceiveClick.bind(this)}
        text="Only receive assets on this network"
        .networkImages=${[AssetUtil.getNetworkImage(caipNetwork) ?? ""]}
      ></wui-compatible-network>`;
    }
    const slicedNetworks = (_a = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.filter((network) => {
      var _a2;
      return (_a2 = network == null ? void 0 : network.assets) == null ? void 0 : _a2.imageId;
    })) == null ? void 0 : _a.slice(0, 5);
    const imagesArray = slicedNetworks.map(AssetUtil.getNetworkImage).filter(Boolean);
    return html`<wui-compatible-network
      @click=${this.onReceiveClick.bind(this)}
      text="Only receive assets on these networks"
      .networkImages=${imagesArray}
    ></wui-compatible-network>`;
  }
  onReceiveClick() {
    RouterController.push("WalletCompatibleNetworks");
  }
  onCopyClick() {
    try {
      if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mWalletReceiveView.styles = styles_default27;
__decorate45([
  state()
], W3mWalletReceiveView.prototype, "address", void 0);
__decorate45([
  state()
], W3mWalletReceiveView.prototype, "profileName", void 0);
__decorate45([
  state()
], W3mWalletReceiveView.prototype, "network", void 0);
__decorate45([
  state()
], W3mWalletReceiveView.prototype, "preferredAccountType", void 0);
W3mWalletReceiveView = __decorate45([
  customElement("w3m-wallet-receive-view")
], W3mWalletReceiveView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-compatible-networks-view/styles.js
var styles_default28 = css`
  :host > wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-compatible-networks-view/index.js
var __decorate46 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mWalletCompatibleNetworksView = class W3mWalletCompatibleNetworksView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.unsubscribe.push(AccountController.subscribeKey("preferredAccountType", (val) => {
      this.preferredAccountType = val;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html` <wui-flex
      flexDirection="column"
      .padding=${["xs", "s", "m", "s"]}
      gap="xs"
    >
      <wui-banner
        icon="warningCircle"
        text="You can only receive assets on these networks"
      ></wui-banner>
      ${this.networkTemplate()}
    </wui-flex>`;
  }
  networkTemplate() {
    const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const approvedCaipNetworkIds = ChainController.getAllApprovedCaipNetworkIds();
    const caipNetwork = ChainController.state.activeCaipNetwork;
    const isNetworkEnabledForSmartAccounts = ChainController.checkIfSmartAccountEnabled();
    let sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    if (isNetworkEnabledForSmartAccounts && this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT) {
      if (!caipNetwork) {
        return null;
      }
      sortedNetworks = [caipNetwork];
    }
    return sortedNetworks.map((network) => html`
        <wui-list-network
          imageSrc=${ifDefined(AssetUtil.getNetworkImage(network))}
          name=${network.name ?? "Unknown"}
          ?transparent=${true}
        >
        </wui-list-network>
      `);
  }
};
W3mWalletCompatibleNetworksView.styles = styles_default28;
__decorate46([
  state()
], W3mWalletCompatibleNetworksView.prototype, "preferredAccountType", void 0);
W3mWalletCompatibleNetworksView = __decorate46([
  customElement("w3m-wallet-compatible-networks-view")
], W3mWalletCompatibleNetworksView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-send-view/styles.js
var styles_default29 = css`
  :host {
    display: block;
  }

  wui-flex {
    position: relative;
  }

  wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xs) !important;
    border: 5px solid var(--wui-color-bg-125);
    background: var(--wui-color-bg-175);
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 3;
  }

  wui-button {
    --local-border-radius: var(--wui-border-radius-xs) !important;
  }

  .inputContainer {
    height: fit-content;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-send-view/index.js
var __decorate47 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mWalletSendView = class W3mWalletSendView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.token = SendController.state.token;
    this.sendTokenAmount = SendController.state.sendTokenAmount;
    this.receiverAddress = SendController.state.receiverAddress;
    this.receiverProfileName = SendController.state.receiverProfileName;
    this.loading = SendController.state.loading;
    this.gasPriceInUSD = SendController.state.gasPriceInUSD;
    this.gasPrice = SendController.state.gasPrice;
    this.message = "Preview Send";
    this.fetchNetworkPrice();
    this.unsubscribe.push(...[
      SendController.subscribe((val) => {
        this.token = val.token;
        this.sendTokenAmount = val.sendTokenAmount;
        this.receiverAddress = val.receiverAddress;
        this.gasPriceInUSD = val.gasPriceInUSD;
        this.receiverProfileName = val.receiverProfileName;
        this.loading = val.loading;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    this.getMessage();
    return html` <wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]}>
      <wui-flex class="inputContainer" gap="xs" flexDirection="column">
        <w3m-input-token
          .token=${this.token}
          .sendTokenAmount=${this.sendTokenAmount}
          .gasPriceInUSD=${this.gasPriceInUSD}
          .gasPrice=${this.gasPrice}
        ></w3m-input-token>
        <wui-icon-box
          size="inherit"
          backgroundColor="fg-300"
          iconSize="lg"
          iconColor="fg-250"
          background="opaque"
          icon="arrowBottom"
        ></wui-icon-box>
        <w3m-input-address
          .value=${this.receiverProfileName ? this.receiverProfileName : this.receiverAddress}
        ></w3m-input-address>
      </wui-flex>
      <wui-flex .margin=${["l", "0", "0", "0"]}>
        <wui-button
          @click=${this.onButtonClick.bind(this)}
          ?disabled=${!this.message.startsWith("Preview Send")}
          size="lg"
          variant="main"
          ?loading=${this.loading}
          fullWidth
        >
          ${this.message}
        </wui-button>
      </wui-flex>
    </wui-flex>`;
  }
  async fetchNetworkPrice() {
    await SwapController.getNetworkTokenPrice();
    const gas = await SwapController.getInitialGasPrice();
    if ((gas == null ? void 0 : gas.gasPrice) && (gas == null ? void 0 : gas.gasPriceInUSD)) {
      SendController.setGasPrice(gas.gasPrice);
      SendController.setGasPriceInUsd(gas.gasPriceInUSD);
    }
  }
  onButtonClick() {
    RouterController.push("WalletSendPreview");
  }
  getMessage() {
    var _a;
    this.message = "Preview Send";
    if (this.receiverAddress && !CoreHelperUtil.isAddress(this.receiverAddress, ChainController.state.activeChain)) {
      this.message = "Invalid Address";
    }
    if (!this.receiverAddress) {
      this.message = "Add Address";
    }
    if (this.sendTokenAmount && this.token && this.sendTokenAmount > Number(this.token.quantity.numeric)) {
      this.message = "Insufficient Funds";
    }
    if (!this.sendTokenAmount) {
      this.message = "Add Amount";
    }
    if (this.sendTokenAmount && ((_a = this.token) == null ? void 0 : _a.price)) {
      const value = this.sendTokenAmount * this.token.price;
      if (!value) {
        this.message = "Incorrect Value";
      }
    }
    if (!this.token) {
      this.message = "Select Token";
    }
  }
};
W3mWalletSendView.styles = styles_default29;
__decorate47([
  state()
], W3mWalletSendView.prototype, "token", void 0);
__decorate47([
  state()
], W3mWalletSendView.prototype, "sendTokenAmount", void 0);
__decorate47([
  state()
], W3mWalletSendView.prototype, "receiverAddress", void 0);
__decorate47([
  state()
], W3mWalletSendView.prototype, "receiverProfileName", void 0);
__decorate47([
  state()
], W3mWalletSendView.prototype, "loading", void 0);
__decorate47([
  state()
], W3mWalletSendView.prototype, "gasPriceInUSD", void 0);
__decorate47([
  state()
], W3mWalletSendView.prototype, "gasPrice", void 0);
__decorate47([
  state()
], W3mWalletSendView.prototype, "message", void 0);
W3mWalletSendView = __decorate47([
  customElement("w3m-wallet-send-view")
], W3mWalletSendView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-send-select-token-view/styles.js
var styles_default30 = css`
  .contentContainer {
    height: 440px;
    overflow: scroll;
    scrollbar-width: none;
  }

  .contentContainer::-webkit-scrollbar {
    display: none;
  }

  wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-send-select-token-view/index.js
var __decorate48 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSendSelectTokenView = class W3mSendSelectTokenView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tokenBalance = AccountController.state.tokenBalance;
    this.search = "";
    this.onDebouncedSearch = CoreHelperUtil.debounce((value) => {
      this.search = value;
    });
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        this.tokenBalance = val.tokenBalance;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`
      <wui-flex flexDirection="column">
        ${this.templateSearchInput()} <wui-separator></wui-separator> ${this.templateTokens()}
      </wui-flex>
    `;
  }
  templateSearchInput() {
    return html`
      <wui-flex gap="xs" padding="s">
        <wui-input-text
          @inputChange=${this.onInputChange.bind(this)}
          class="network-search-input"
          size="sm"
          placeholder="Search token"
          icon="search"
        ></wui-input-text>
      </wui-flex>
    `;
  }
  templateTokens() {
    var _a, _b;
    this.tokens = (_a = this.tokenBalance) == null ? void 0 : _a.filter((token) => {
      var _a2;
      return token.chainId === ((_a2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a2.caipNetworkId);
    });
    if (this.search) {
      this.filteredTokens = (_b = this.tokenBalance) == null ? void 0 : _b.filter((token) => token.name.toLowerCase().includes(this.search.toLowerCase()));
    } else {
      this.filteredTokens = this.tokens;
    }
    return html`
      <wui-flex
        class="contentContainer"
        flexDirection="column"
        .padding=${["0", "s", "0", "s"]}
      >
        <wui-flex justifyContent="flex-start" .padding=${["m", "s", "s", "s"]}>
          <wui-text variant="paragraph-500" color="fg-200">Your tokens</wui-text>
        </wui-flex>
        <wui-flex flexDirection="column" gap="xs">
          ${this.filteredTokens && this.filteredTokens.length > 0 ? this.filteredTokens.map((token) => html`<wui-list-token
                    @click=${this.handleTokenClick.bind(this, token)}
                    ?clickable=${true}
                    tokenName=${token.name}
                    tokenImageUrl=${token.iconUrl}
                    tokenAmount=${token.quantity.numeric}
                    tokenValue=${token.value}
                    tokenCurrency=${token.symbol}
                  ></wui-list-token>`) : html`<wui-flex
                .padding=${["4xl", "0", "0", "0"]}
                alignItems="center"
                flexDirection="column"
                gap="l"
              >
                <wui-icon-box
                  icon="coinPlaceholder"
                  size="inherit"
                  iconColor="fg-200"
                  backgroundColor="fg-200"
                  iconSize="lg"
                ></wui-icon-box>
                <wui-flex
                  class="textContent"
                  gap="xs"
                  flexDirection="column"
                  justifyContent="center"
                  flexDirection="column"
                >
                  <wui-text variant="paragraph-500" align="center" color="fg-100"
                    >No tokens found</wui-text
                  >
                  <wui-text variant="small-400" align="center" color="fg-200"
                    >Your tokens will appear here</wui-text
                  >
                </wui-flex>
                <wui-link @click=${this.onBuyClick.bind(this)}>Buy</wui-link>
              </wui-flex>`}
        </wui-flex>
      </wui-flex>
    `;
  }
  onBuyClick() {
    RouterController.push("OnRampProviders");
  }
  onInputChange(event) {
    this.onDebouncedSearch(event.detail);
  }
  handleTokenClick(token) {
    SendController.setToken(token);
    SendController.setTokenAmount(void 0);
    RouterController.goBack();
  }
};
W3mSendSelectTokenView.styles = styles_default30;
__decorate48([
  state()
], W3mSendSelectTokenView.prototype, "tokenBalance", void 0);
__decorate48([
  state()
], W3mSendSelectTokenView.prototype, "tokens", void 0);
__decorate48([
  state()
], W3mSendSelectTokenView.prototype, "filteredTokens", void 0);
__decorate48([
  state()
], W3mSendSelectTokenView.prototype, "search", void 0);
W3mSendSelectTokenView = __decorate48([
  customElement("w3m-wallet-send-select-token-view")
], W3mSendSelectTokenView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-send-preview-view/styles.js
var styles_default31 = css`
  wui-avatar,
  wui-image {
    display: ruby;
    width: 32px;
    height: 32px;
    border-radius: var(--wui-border-radius-3xl);
  }

  .sendButton {
    width: 70%;
    --local-width: 100% !important;
    --local-border-radius: var(--wui-border-radius-xs) !important;
  }

  .cancelButton {
    width: 30%;
    --local-width: 100% !important;
    --local-border-radius: var(--wui-border-radius-xs) !important;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-send-preview-view/index.js
var __decorate49 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mWalletSendPreviewView = class W3mWalletSendPreviewView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.token = SendController.state.token;
    this.sendTokenAmount = SendController.state.sendTokenAmount;
    this.receiverAddress = SendController.state.receiverAddress;
    this.receiverProfileName = SendController.state.receiverProfileName;
    this.receiverProfileImageUrl = SendController.state.receiverProfileImageUrl;
    this.gasPriceInUSD = SendController.state.gasPriceInUSD;
    this.caipNetwork = ChainController.state.activeCaipNetwork;
    this.unsubscribe.push(...[
      SendController.subscribe((val) => {
        this.token = val.token;
        this.sendTokenAmount = val.sendTokenAmount;
        this.receiverAddress = val.receiverAddress;
        this.gasPriceInUSD = val.gasPriceInUSD;
        this.receiverProfileName = val.receiverProfileName;
        this.receiverProfileImageUrl = val.receiverProfileImageUrl;
      }),
      ChainController.subscribeKey("activeCaipNetwork", (val) => this.caipNetwork = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a, _b;
    return html` <wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]}>
      <wui-flex gap="xs" flexDirection="column" .padding=${["0", "xs", "0", "xs"]}>
        <wui-flex alignItems="center" justifyContent="space-between">
          <wui-flex flexDirection="column" gap="4xs">
            <wui-text variant="small-400" color="fg-150">Send</wui-text>
            ${this.sendValueTemplate()}
          </wui-flex>
          <wui-preview-item
            text="${this.sendTokenAmount ? UiHelperUtil.roundNumber(this.sendTokenAmount, 6, 5) : "unknown"} ${(_a = this.token) == null ? void 0 : _a.symbol}"
            .imageSrc=${(_b = this.token) == null ? void 0 : _b.iconUrl}
          ></wui-preview-item>
        </wui-flex>
        <wui-flex>
          <wui-icon color="fg-200" size="md" name="arrowBottom"></wui-icon>
        </wui-flex>
        <wui-flex alignItems="center" justifyContent="space-between">
          <wui-text variant="small-400" color="fg-150">To</wui-text>
          <wui-preview-item
            text="${this.receiverProfileName ? UiHelperUtil.getTruncateString({
      string: this.receiverProfileName,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : UiHelperUtil.getTruncateString({
      string: this.receiverAddress ? this.receiverAddress : "",
      charsStart: 4,
      charsEnd: 4,
      truncate: "middle"
    })}"
            address=${this.receiverAddress ?? ""}
            .imageSrc=${this.receiverProfileImageUrl ?? void 0}
            .isAddress=${true}
          ></wui-preview-item>
        </wui-flex>
      </wui-flex>
      <wui-flex flexDirection="column" .padding=${["xxl", "0", "0", "0"]}>
        <w3m-wallet-send-details
          .caipNetwork=${this.caipNetwork}
          .receiverAddress=${this.receiverAddress}
          .networkFee=${this.gasPriceInUSD}
        ></w3m-wallet-send-details>
        <wui-flex justifyContent="center" gap="xxs" .padding=${["s", "0", "0", "0"]}>
          <wui-icon size="sm" color="fg-200" name="warningCircle"></wui-icon>
          <wui-text variant="small-400" color="fg-200">Review transaction carefully</wui-text>
        </wui-flex>
        <wui-flex justifyContent="center" gap="s" .padding=${["l", "0", "0", "0"]}>
          <wui-button
            class="cancelButton"
            @click=${this.onCancelClick.bind(this)}
            size="lg"
            variant="neutral"
          >
            Cancel
          </wui-button>
          <wui-button
            class="sendButton"
            @click=${this.onSendClick.bind(this)}
            size="lg"
            variant="main"
          >
            Send
          </wui-button>
        </wui-flex>
      </wui-flex></wui-flex
    >`;
  }
  sendValueTemplate() {
    if (this.token && this.sendTokenAmount) {
      const price = this.token.price;
      const totalValue = price * this.sendTokenAmount;
      return html`<wui-text variant="paragraph-400" color="fg-100"
        >$${totalValue.toFixed(2)}</wui-text
      >`;
    }
    return null;
  }
  onSendClick() {
    SendController.sendToken();
  }
  onCancelClick() {
    RouterController.goBack();
  }
};
W3mWalletSendPreviewView.styles = styles_default31;
__decorate49([
  state()
], W3mWalletSendPreviewView.prototype, "token", void 0);
__decorate49([
  state()
], W3mWalletSendPreviewView.prototype, "sendTokenAmount", void 0);
__decorate49([
  state()
], W3mWalletSendPreviewView.prototype, "receiverAddress", void 0);
__decorate49([
  state()
], W3mWalletSendPreviewView.prototype, "receiverProfileName", void 0);
__decorate49([
  state()
], W3mWalletSendPreviewView.prototype, "receiverProfileImageUrl", void 0);
__decorate49([
  state()
], W3mWalletSendPreviewView.prototype, "gasPriceInUSD", void 0);
__decorate49([
  state()
], W3mWalletSendPreviewView.prototype, "caipNetwork", void 0);
W3mWalletSendPreviewView = __decorate49([
  customElement("w3m-wallet-send-preview-view")
], W3mWalletSendPreviewView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connect-wallets-view/styles.js
var styles_default32 = css`
  wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
  }
  wui-flex::-webkit-scrollbar {
    display: none;
  }
  wui-flex.disabled {
    opacity: 0.3;
    pointer-events: none;
    user-select: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connect-wallets-view/index.js
var __decorate50 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectWalletsView = class W3mConnectWalletsView2 extends LitElement {
  constructor() {
    super(...arguments);
    this.checked = false;
  }
  render() {
    var _a;
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    const legalCheckbox = (_a = OptionsController.state.features) == null ? void 0 : _a.legalCheckbox;
    const legalUrl = termsConditionsUrl || privacyPolicyUrl;
    const showLegalCheckbox = Boolean(legalUrl) && Boolean(legalCheckbox);
    const disabled = showLegalCheckbox && !this.checked;
    const tabIndex = disabled ? -1 : void 0;
    return html`
      <w3m-legal-checkbox @checkboxChange=${this.onCheckboxChange.bind(this)}></w3m-legal-checkbox>
      <wui-flex
        flexDirection="column"
        .padding=${showLegalCheckbox ? ["0", "s", "s", "s"] : "s"}
        gap="xs"
        class=${ifDefined(disabled ? "disabled" : void 0)}
      >
        <w3m-wallet-login-list tabIdx=${ifDefined(tabIndex)}></w3m-wallet-login-list>
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
  onCheckboxChange(event) {
    this.checked = Boolean(event.detail);
  }
};
W3mConnectWalletsView.styles = styles_default32;
__decorate50([
  state()
], W3mConnectWalletsView.prototype, "checked", void 0);
W3mConnectWalletsView = __decorate50([
  customElement("w3m-connect-wallets-view")
], W3mConnectWalletsView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connect-socials-view/styles.js
var styles_default33 = css`
  wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
  }
  wui-flex::-webkit-scrollbar {
    display: none;
  }
  wui-flex.disabled {
    opacity: 0.3;
    pointer-events: none;
    user-select: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connect-socials-view/index.js
var __decorate51 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectSocialsView = class W3mConnectSocialsView2 extends LitElement {
  constructor() {
    super(...arguments);
    this.checked = false;
  }
  render() {
    var _a;
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    const legalCheckbox = (_a = OptionsController.state.features) == null ? void 0 : _a.legalCheckbox;
    const legalUrl = termsConditionsUrl || privacyPolicyUrl;
    const showLegalCheckbox = Boolean(legalUrl) && Boolean(legalCheckbox);
    const disabled = showLegalCheckbox && !this.checked;
    const tabIndex = disabled ? -1 : void 0;
    return html`
      <w3m-legal-checkbox @checkboxChange=${this.onCheckboxChange.bind(this)}></w3m-legal-checkbox>
      <wui-flex
        flexDirection="column"
        .padding=${showLegalCheckbox ? ["0", "s", "s", "s"] : "s"}
        gap="xs"
        class=${ifDefined(disabled ? "disabled" : void 0)}
      >
        <w3m-social-login-list tabIdx=${ifDefined(tabIndex)}></w3m-social-login-list>
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
  onCheckboxChange(event) {
    this.checked = Boolean(event.detail);
  }
};
W3mConnectSocialsView.styles = styles_default33;
__decorate51([
  state()
], W3mConnectSocialsView.prototype, "checked", void 0);
W3mConnectSocialsView = __decorate51([
  customElement("w3m-connect-socials-view")
], W3mConnectSocialsView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-social-view/styles.js
var styles_default34 = css`
  wui-logo {
    width: 80px;
    height: 80px;
    border-radius: var(--wui-border-radius-m);
  }
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }
  wui-flex:first-child:not(:only-child) {
    position: relative;
  }
  wui-loading-thumbnail {
    position: absolute;
  }
  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }
  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }
  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }
  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }
  .capitalize {
    text-transform: capitalize;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-social-view/index.js
var __decorate52 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingSocialView = class W3mConnectingSocialView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.socialProvider = AccountController.state.socialProvider;
    this.socialWindow = AccountController.state.socialWindow;
    this.error = false;
    this.connecting = false;
    this.message = "Connect in the provider window";
    this.authConnector = ConnectorController.getAuthConnector();
    this.handleSocialConnection = async (event) => {
      var _a;
      if ((_a = event.data) == null ? void 0 : _a.resultUri) {
        if (event.origin === ConstantsUtil4.SECURE_SITE_ORIGIN) {
          window.removeEventListener("message", this.handleSocialConnection, false);
          try {
            if (this.authConnector && !this.connecting) {
              if (this.socialWindow) {
                this.socialWindow.close();
                AccountController.setSocialWindow(void 0, ChainController.state.activeChain);
              }
              this.connecting = true;
              this.updateMessage();
              const uri = event.data.resultUri;
              await this.authConnector.provider.connectSocial(uri);
              if (this.socialProvider) {
                StorageUtil.setConnectedSocialProvider(this.socialProvider);
                await ConnectionController.connectExternal(this.authConnector, this.authConnector.chain);
                EventsController.sendEvent({
                  type: "track",
                  event: "SOCIAL_LOGIN_SUCCESS",
                  properties: { provider: this.socialProvider }
                });
              }
            }
          } catch (error) {
            this.error = true;
            this.updateMessage();
            if (this.socialProvider) {
              EventsController.sendEvent({
                type: "track",
                event: "SOCIAL_LOGIN_ERROR",
                properties: { provider: this.socialProvider }
              });
            }
          }
        } else {
          RouterController.goBack();
          SnackController.showError("Untrusted Origin");
          if (this.socialProvider) {
            EventsController.sendEvent({
              type: "track",
              event: "SOCIAL_LOGIN_ERROR",
              properties: { provider: this.socialProvider }
            });
          }
        }
      }
    };
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.socialProvider) {
          this.socialProvider = val.socialProvider;
        }
        if (val.socialWindow) {
          this.socialWindow = val.socialWindow;
        }
        if (val.address) {
          if (ModalController.state.open) {
            ModalController.close();
          }
        }
      })
    ]);
    if (this.authConnector) {
      this.connectSocial();
    }
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    window.removeEventListener("message", this.handleSocialConnection, false);
  }
  render() {
    return html`
      <wui-flex
        data-error=${ifDefined(this.error)}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-logo logo=${ifDefined(this.socialProvider)}></wui-logo>
          ${this.error ? null : this.loaderTemplate()}
          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100"
            >Log in with
            <span class="capitalize">${this.socialProvider ?? "Social"}</span></wui-text
          >
          <wui-text align="center" variant="small-400" color=${this.error ? "error-100" : "fg-200"}
            >${this.message}</wui-text
          ></wui-flex
        >
      </wui-flex>
    `;
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return html`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  connectSocial() {
    const interval = setInterval(() => {
      var _a;
      if ((_a = this.socialWindow) == null ? void 0 : _a.closed) {
        if (!this.connecting && RouterController.state.view === "ConnectingSocial") {
          RouterController.goBack();
        }
        clearInterval(interval);
      }
    }, 1e3);
    window.addEventListener("message", this.handleSocialConnection, false);
  }
  updateMessage() {
    if (this.error) {
      this.message = "Something went wrong";
    } else if (this.connecting) {
      this.message = "Retrieving user data";
    } else {
      this.message = "Connect in the provider window";
    }
  }
};
W3mConnectingSocialView.styles = styles_default34;
__decorate52([
  state()
], W3mConnectingSocialView.prototype, "socialProvider", void 0);
__decorate52([
  state()
], W3mConnectingSocialView.prototype, "socialWindow", void 0);
__decorate52([
  state()
], W3mConnectingSocialView.prototype, "error", void 0);
__decorate52([
  state()
], W3mConnectingSocialView.prototype, "connecting", void 0);
__decorate52([
  state()
], W3mConnectingSocialView.prototype, "message", void 0);
W3mConnectingSocialView = __decorate52([
  customElement("w3m-connecting-social-view")
], W3mConnectingSocialView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-profile-view/styles.js
var styles_default35 = css`
  wui-flex {
    width: 100%;
  }

  wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }

  .account-links {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .account-links wui-flex {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    background: red;
    align-items: center;
    justify-content: center;
    height: 48px;
    padding: 10px;
    flex: 1 0 0;

    border-radius: var(--XS, 16px);
    border: 1px solid var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    background: var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  .account-links wui-flex:hover {
    background: var(--dark-accent-glass-015, rgba(71, 161, 255, 0.15));
  }

  .account-links wui-flex wui-icon {
    width: var(--S, 20px);
    height: var(--S, 20px);
  }

  .account-links wui-flex wui-icon svg path {
    stroke: #47a1ff;
  }

  .account-settings-button {
    padding: calc(var(--wui-spacing-m) - 1px) var(--wui-spacing-2l);
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
    border: 1px solid var(--wui-color-gray-glass-002);
    background: var(--wui-color-gray-glass-002);
    cursor: pointer;
  }

  .account-settings-button:hover {
    background: var(--wui-color-gray-glass-005);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-profile-view/index.js
var __decorate53 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mProfileView = class W3mProfileView2 extends LitElement {
  constructor() {
    super();
    this.usubscribe = [];
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.accounts = AccountController.state.allAccounts;
    this.loading = false;
    this.usubscribe.push(AccountController.subscribeKey("address", (address) => {
      if (address) {
        this.address = address;
      } else {
        ModalController.close();
      }
    }));
    this.usubscribe.push(AccountController.subscribeKey("profileImage", (profileImage) => {
      this.profileImage = profileImage;
    }));
    this.usubscribe.push(AccountController.subscribeKey("profileName", (profileName) => {
      this.profileName = profileName;
    }));
  }
  disconnectedCallback() {
    this.usubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!this.address) {
      throw new Error("w3m-profile-view: No account provided");
    }
    return html`
      <wui-flex flexDirection="column" gap="l" .padding=${["0", "xl", "m", "xl"]}>
        <wui-flex flexDirection="column" alignItems="center" gap="l">
          <wui-avatar
            alt=${this.address}
            address=${this.address}
            imageSrc=${ifDefined(this.profileImage)}
            size="2lg"
          ></wui-avatar>
          <wui-flex flexDirection="column" alignItems="center">
            <wui-flex gap="3xs" alignItems="center" justifyContent="center">
              <wui-text variant="title-6-600" color="fg-100" data-testid="account-settings-address">
                ${this.profileName ? UiHelperUtil.getTruncateString({
      string: this.profileName,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : UiHelperUtil.getTruncateString({
      string: this.address,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}
              </wui-text>
              <wui-icon-link
                size="md"
                icon="copy"
                iconColor="fg-200"
                @click=${this.onCopyAddress}
              ></wui-icon-link>
            </wui-flex>
          </wui-flex>
        </wui-flex>
        <wui-flex
          data-testid="account-settings-button"
          justifyContent="center"
          alignItems="center"
          class="account-settings-button"
          @click=${() => RouterController.push("AccountSettings")}
        >
          <wui-text variant="paragraph-500" color="fg-100">Account Settings</wui-text>
        </wui-flex>
        ${this.accountsTemplate()}
      </wui-flex>
    `;
  }
  accountsTemplate() {
    return html`<wui-flex flexDirection="column">
      <wui-flex .padding=${["3xs", "m", "s", "s"]}>
        <wui-text color="fg-200" variant="paragraph-400">Your accounts</wui-text>
      </wui-flex>
      <wui-flex flexDirection="column" gap="xxs">
        ${this.accounts.map((account) => this.accountTemplate(account))}
      </wui-flex>
    </wui-flex>`;
  }
  async onSwitchAccount(account) {
    this.loading = true;
    const emailConnector = ConnectorController.getAuthConnector();
    if (emailConnector) {
      await ConnectionController.setPreferredAccountType(account.type);
    }
    AccountController.setShouldUpdateToAddress(account.address, ChainController.state.activeChain);
    this.loading = false;
  }
  accountTemplate(account) {
    return html`<wui-list-account accountAddress=${account.address} accountType=${account.type}>
      ${account.address === this.address ? "" : html`<wui-button
            slot="action"
            textVariant="small-600"
            size="md"
            variant="accent"
            @click=${() => this.onSwitchAccount(account)}
            .loading=${this.loading}
            >Switch</wui-button
          >`}
    </wui-list-account>`;
  }
  onCopyAddress() {
    try {
      if (this.profileName) {
        CoreHelperUtil.copyToClopboard(this.profileName);
        SnackController.showSuccess("Name copied");
      } else if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mProfileView.styles = styles_default35;
__decorate53([
  state()
], W3mProfileView.prototype, "address", void 0);
__decorate53([
  state()
], W3mProfileView.prototype, "profileImage", void 0);
__decorate53([
  state()
], W3mProfileView.prototype, "profileName", void 0);
__decorate53([
  state()
], W3mProfileView.prototype, "accounts", void 0);
__decorate53([
  state()
], W3mProfileView.prototype, "loading", void 0);
W3mProfileView = __decorate53([
  customElement("w3m-profile-view")
], W3mProfileView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-switch-address-view/styles.js
var styles_default36 = css`
  wui-avatar {
    width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
    box-shadow: 0 0 0 0;
  }

  wui-icon-box {
    position: relative;
    right: 15px;
    top: 15px;
    border: 2px solid var(--wui-color-bg-150);
    background-color: var(--wui-color-bg-125);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-switch-address-view/index.js
var __decorate54 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSwitchAddressView = class W3mSwitchAddressView2 extends LitElement {
  constructor() {
    super();
    this.metadata = OptionsController.state.metadata;
    this.allAccounts = AccountController.state.allAccounts || [];
    this.balances = {};
    this.labels = AccountController.state.addressLabels;
    this.currentAddress = AccountController.state.address || "";
    this.connectedConnector = StorageUtil.getConnectedConnector();
    this.shouldShowIcon = this.connectedConnector === "AUTH";
    this.caipNetwork = ChainController.state.activeCaipNetwork;
    AccountController.subscribeKey("allAccounts", (allAccounts) => {
      this.allAccounts = allAccounts;
    });
  }
  connectedCallback() {
    super.connectedCallback();
    this.allAccounts.forEach((account) => {
      var _a;
      BlockchainApiController.getBalance(account.address, (_a = this.caipNetwork) == null ? void 0 : _a.caipNetworkId).then((response) => {
        let total = this.balances[account.address] || 0;
        if (response.balances.length > 0) {
          total = response.balances.reduce((acc, balance) => acc + ((balance == null ? void 0 : balance.value) || 0), 0);
        }
        this.balances[account.address] = total;
        this.requestUpdate();
      });
    });
  }
  getAddressIcon(type) {
    if (type === "smartAccount") {
      return "lightbulb";
    }
    return "mail";
  }
  render() {
    var _a, _b;
    return html`
      <wui-flex justifyContent="center" .padding=${["xl", "0", "xl", "0"]}>
        <wui-banner-img
          imageSrc=${ifDefined((_a = this.metadata) == null ? void 0 : _a.icons[0])}
          text=${ifDefined((_b = this.metadata) == null ? void 0 : _b.url)}
          size="sm"
        ></wui-banner-img>
      </wui-flex>
      <wui-flex flexDirection="column" gap="xxl" .padding=${["l", "xl", "xl", "xl"]}>
        ${this.allAccounts.map((account, index2) => this.getAddressTemplate(account, index2))}
      </wui-flex>
    `;
  }
  getAddressTemplate(account, index2) {
    var _a, _b, _c, _d;
    const label = (_a = this.labels) == null ? void 0 : _a.get(account.address);
    return html`
      <wui-flex
        flexDirection="row"
        justifyContent="space-between"
        data-testid="switch-address-item"
      >
        <wui-flex alignItems="center">
          <wui-avatar address=${account.address}></wui-avatar>
          ${this.shouldShowIcon ? html`<wui-icon-box
                size="sm"
                iconcolor="fg-200"
                backgroundcolor="glass-002"
                background="gray"
                icon="${this.getAddressIcon(account.type)}"
                ?border=${true}
              ></wui-icon-box>` : html`<wui-flex .padding="${["0", "0", "0", "s"]}"></wui-flex>`}
          <wui-flex flexDirection="column">
            <wui-text class="address" variant="paragraph-500" color="fg-100"
              >${label ? label : UiHelperUtil.getTruncateString({
      string: account.address,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}</wui-text
            >
            <wui-text class="address-description" variant="small-400">
              ${typeof this.balances[account.address] === "number" ? `$${(_b = this.balances[account.address]) == null ? void 0 : _b.toFixed(2)}` : html`<wui-loading-spinner size="sm" color="accent-100"></wui-loading-spinner>`}
            </wui-text>
          </wui-flex>
        </wui-flex>
        <wui-flex gap="s" alignItems="center">
          ${((_c = account.address) == null ? void 0 : _c.toLowerCase()) === ((_d = this.currentAddress) == null ? void 0 : _d.toLowerCase()) ? "" : html`
                <wui-button
                  data-testid=${`w3m-switch-address-button-${index2}`}
                  textVariant="small-600"
                  size="md"
                  variant="accent"
                  @click=${() => this.onSwitchAddress(account.address)}
                  >Switch to</wui-button
                >
              `}
        </wui-flex>
      </wui-flex>
    `;
  }
  onSwitchAddress(address) {
    const caipNetwork = ChainController.state.activeCaipNetwork;
    const activeChainNamespace = caipNetwork == null ? void 0 : caipNetwork.chainNamespace;
    const caipAddress = `${activeChainNamespace}:${caipNetwork == null ? void 0 : caipNetwork.id}:${address}`;
    AccountController.setCaipAddress(caipAddress, activeChainNamespace);
    ModalController.close();
  }
};
W3mSwitchAddressView.styles = styles_default36;
__decorate54([
  state()
], W3mSwitchAddressView.prototype, "allAccounts", void 0);
__decorate54([
  state()
], W3mSwitchAddressView.prototype, "balances", void 0);
W3mSwitchAddressView = __decorate54([
  customElement("w3m-switch-address-view")
], W3mSwitchAddressView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-farcaster-view/styles.js
var styles_default37 = css`
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }

  wui-logo {
    width: 80px;
    height: 80px;
    border-radius: var(--wui-border-radius-m);
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }
  wui-loading-thumbnail {
    position: absolute;
  }
  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-farcaster-view/index.js
var __decorate55 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingFarcasterView = class W3mConnectingFarcasterView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.timeout = void 0;
    this.socialProvider = AccountController.state.socialProvider;
    this.uri = AccountController.state.farcasterUrl;
    this.ready = false;
    this.loading = false;
    this.authConnector = ConnectorController.getAuthConnector();
    this.forceUpdate = () => {
      this.requestUpdate();
    };
    this.unsubscribe.push(...[
      AccountController.subscribeKey("farcasterUrl", (val) => {
        if (val) {
          this.uri = val;
          this.connectFarcaster();
        }
      }),
      AccountController.subscribeKey("socialProvider", (val) => {
        if (val) {
          this.socialProvider = val;
        }
      })
    ]);
    window.addEventListener("resize", this.forceUpdate);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    clearTimeout(this.timeout);
    window.removeEventListener("resize", this.forceUpdate);
  }
  render() {
    this.onRenderProxy();
    return html`${this.platformTemplate()}`;
  }
  platformTemplate() {
    if (CoreHelperUtil.isMobile()) {
      return html`${this.mobileTemplate()}`;
    }
    return html`${this.desktopTemplate()}`;
  }
  desktopTemplate() {
    if (this.loading) {
      return html`${this.loadingTemplate()}`;
    }
    return html`${this.qrTemplate()}`;
  }
  qrTemplate() {
    return html` <wui-flex
      flexDirection="column"
      alignItems="center"
      .padding=${["0", "xl", "xl", "xl"]}
      gap="xl"
    >
      <wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>

      <wui-text variant="paragraph-500" color="fg-100">
        Scan this QR Code with your phone
      </wui-text>
      ${this.copyTemplate()}
    </wui-flex>`;
  }
  loadingTemplate() {
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-logo logo="farcaster"></wui-logo>
          ${this.loaderTemplate()}
          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100">
            Loading user data
          </wui-text>
          <wui-text align="center" variant="small-400" color="fg-200">
            Please wait a moment while we load your data.
          </wui-text>
        </wui-flex>
      </wui-flex>
    `;
  }
  mobileTemplate() {
    return html` <wui-flex
      flexDirection="column"
      alignItems="center"
      .padding=${["3xl", "xl", "xl", "xl"]}
      gap="xl"
    >
      <wui-flex justifyContent="center" alignItems="center">
        <wui-logo logo="farcaster"></wui-logo>
        ${this.loaderTemplate()}
        <wui-icon-box
          backgroundColor="error-100"
          background="opaque"
          iconColor="error-100"
          icon="close"
          size="sm"
          border
          borderColor="wui-color-bg-125"
        ></wui-icon-box>
      </wui-flex>
      <wui-flex flexDirection="column" alignItems="center" gap="xs">
        <wui-text align="center" variant="paragraph-500" color="fg-100"
          >Continue in Farcaster</span></wui-text
        >
        <wui-text align="center" variant="small-400" color="fg-200"
          >Accept connection request in the app</wui-text
        ></wui-flex
      >
      ${this.mobileLinkTemplate()}
    </wui-flex>`;
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return html`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  async connectFarcaster() {
    var _a;
    if (this.authConnector) {
      try {
        await ((_a = this.authConnector) == null ? void 0 : _a.provider.connectFarcaster());
        if (this.socialProvider) {
          StorageUtil.setConnectedSocialProvider(this.socialProvider);
        }
        this.loading = true;
        await ConnectionController.connectExternal(this.authConnector, this.authConnector.chain);
        this.loading = false;
        ModalController.close();
      } catch (error) {
        RouterController.goBack();
        SnackController.showError(error);
      }
    }
  }
  mobileLinkTemplate() {
    return html`<wui-button
      size="md"
      ?loading=${this.loading}
      ?disabled=${!this.uri || this.loading}
      @click=${() => {
      if (this.uri) {
        CoreHelperUtil.openHref(this.uri, "_blank");
      }
    }}
    >
      Open farcaster</wui-button
    >`;
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.timeout = setTimeout(() => {
        this.ready = true;
      }, 0);
    }
  }
  qrCodeTemplate() {
    if (!this.uri || !this.ready) {
      return null;
    }
    const size3 = this.getBoundingClientRect().width - 40;
    return html` <wui-qr-code
      size=${size3}
      theme=${ThemeController.state.themeMode}
      uri=${this.uri}
      ?farcaster=${true}
      data-testid="wui-qr-code"
    ></wui-qr-code>`;
  }
  copyTemplate() {
    const inactive = !this.uri || !this.ready;
    return html`<wui-link
      .disabled=${inactive}
      @click=${this.onCopyUri}
      color="fg-200"
      data-testid="copy-wc2-uri"
    >
      <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
      Copy link
    </wui-link>`;
  }
  onCopyUri() {
    try {
      if (this.uri) {
        CoreHelperUtil.copyToClopboard(this.uri);
        SnackController.showSuccess("Link copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mConnectingFarcasterView.styles = styles_default37;
__decorate55([
  state()
], W3mConnectingFarcasterView.prototype, "socialProvider", void 0);
__decorate55([
  state()
], W3mConnectingFarcasterView.prototype, "uri", void 0);
__decorate55([
  state()
], W3mConnectingFarcasterView.prototype, "ready", void 0);
__decorate55([
  state()
], W3mConnectingFarcasterView.prototype, "loading", void 0);
W3mConnectingFarcasterView = __decorate55([
  customElement("w3m-connecting-farcaster-view")
], W3mConnectingFarcasterView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-siwx-sign-message-view/index.js
var __decorate56 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSIWXSignMessageView = class W3mSIWXSignMessageView2 extends LitElement {
  constructor() {
    var _a;
    super(...arguments);
    this.dappName = (_a = OptionsController.state.metadata) == null ? void 0 : _a.name;
    this.isCancelling = false;
  }
  render() {
    return html`
      <wui-flex justifyContent="center" .padding=${["2xl", "0", "xxl", "0"]}>
        <w3m-siwx-sign-message-thumbnails></w3m-siwx-sign-message-thumbnails>
      </wui-flex>
      <wui-flex
        .padding=${["0", "4xl", "l", "4xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100"
          >${this.dappName ?? "Dapp"} needs to connect to your wallet</wui-text
        >
      </wui-flex>
      <wui-flex
        .padding=${["0", "3xl", "l", "3xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="small-400" align="center" color="fg-200"
          >Sign this message to prove you own this wallet and proceed. Canceling will disconnect
          you.</wui-text
        >
      </wui-flex>
      <wui-flex .padding=${["l", "xl", "xl", "xl"]} gap="s" justifyContent="space-between">
        <wui-button
          size="lg"
          borderRadius="xs"
          fullWidth
          variant="neutral"
          ?loading=${this.isCancelling}
          @click=${this.onCancel.bind(this)}
          data-testid="w3m-connecting-siwe-cancel"
        >
          Cancel
        </wui-button>
      </wui-flex>
    `;
  }
  async onCancel() {
    var _a;
    this.isCancelling = true;
    const caipAddress = ChainController.state.activeCaipAddress;
    if (caipAddress) {
      await ConnectionController.disconnect();
      ModalController.close();
    } else {
      RouterController.push("Connect");
    }
    this.isCancelling = false;
    EventsController.sendEvent({
      event: "CLICK_CANCEL_SIWE",
      type: "track",
      properties: {
        network: ((_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId) || "",
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
  }
};
__decorate56([
  state()
], W3mSIWXSignMessageView.prototype, "isCancelling", void 0);
W3mSIWXSignMessageView = __decorate56([
  customElement("w3m-siwx-sign-message-view")
], W3mSIWXSignMessageView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-list/styles.js
var styles_default38 = css`
  wui-grid {
    max-height: clamp(360px, 400px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 104px);
  }

  @media (max-width: 350px) {
    wui-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    justify-content: center;
    grid-column: 1 / span 4;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/WalletUtil.js
var WalletUtil = {
  filterOutDuplicatesByRDNS(wallets) {
    const connectors = OptionsController.state.enableEIP6963 ? ConnectorController.state.connectors : [];
    const recent = StorageUtil.getRecentWallets();
    const connectorRDNSs = connectors.map((connector) => {
      var _a;
      return (_a = connector.info) == null ? void 0 : _a.rdns;
    }).filter(Boolean);
    const recentRDNSs = recent.map((wallet) => wallet.rdns).filter(Boolean);
    const allRDNSs = connectorRDNSs.concat(recentRDNSs);
    if (allRDNSs.includes("io.metamask.mobile") && CoreHelperUtil.isMobile()) {
      const index2 = allRDNSs.indexOf("io.metamask.mobile");
      allRDNSs[index2] = "io.metamask";
    }
    const filtered = wallets.filter((wallet) => !allRDNSs.includes(String(wallet == null ? void 0 : wallet.rdns)));
    return filtered;
  },
  filterOutDuplicatesByIds(wallets) {
    const connectors = ConnectorController.state.connectors.filter((connector) => connector.type === "ANNOUNCED" || connector.type === "INJECTED");
    const recent = StorageUtil.getRecentWallets();
    const connectorIds = connectors.map((connector) => connector.explorerId);
    const recentIds = recent.map((wallet) => wallet.id);
    const allIds = connectorIds.concat(recentIds);
    const filtered = wallets.filter((wallet) => !allIds.includes(wallet == null ? void 0 : wallet.id));
    return filtered;
  },
  filterOutDuplicateWallets(wallets) {
    const uniqueByRDNS = this.filterOutDuplicatesByRDNS(wallets);
    const uniqueWallets = this.filterOutDuplicatesByIds(uniqueByRDNS);
    return uniqueWallets;
  },
  markWalletsAsInstalled(wallets) {
    const { connectors } = ConnectorController.state;
    const installedConnectors = connectors.filter((c5) => c5.type === "ANNOUNCED").reduce((acum, val) => {
      var _a;
      if (!((_a = val.info) == null ? void 0 : _a.rdns)) {
        return acum;
      }
      acum[val.info.rdns] = true;
      return acum;
    }, {});
    const walletsWithInstalled = wallets.map((wallet) => ({
      ...wallet,
      installed: Boolean(wallet.rdns) && Boolean(installedConnectors[wallet.rdns ?? ""])
    }));
    const sortedWallets = walletsWithInstalled.sort((a5, b3) => Number(b3.installed) - Number(a5.installed));
    return sortedWallets;
  }
};

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-list/index.js
var __decorate57 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var PAGINATOR_ID = "local-paginator";
var W3mAllWalletsList = class W3mAllWalletsList2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.paginationObserver = void 0;
    this.initial = !ApiController.state.wallets.length;
    this.wallets = ApiController.state.wallets;
    this.recommended = ApiController.state.recommended;
    this.featured = ApiController.state.featured;
    this.unsubscribe.push(...[
      ApiController.subscribeKey("wallets", (val) => this.wallets = val),
      ApiController.subscribeKey("recommended", (val) => this.recommended = val),
      ApiController.subscribeKey("featured", (val) => this.featured = val)
    ]);
  }
  firstUpdated() {
    this.initialFetch();
    this.createPaginationObserver();
  }
  disconnectedCallback() {
    var _a;
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    (_a = this.paginationObserver) == null ? void 0 : _a.disconnect();
  }
  render() {
    return html`
      <wui-grid
        data-scroll=${!this.initial}
        .padding=${["0", "s", "s", "s"]}
        columnGap="xxs"
        rowGap="l"
        justifyContent="space-between"
      >
        ${this.initial ? this.shimmerTemplate(16) : this.walletsTemplate()}
        ${this.paginationLoaderTemplate()}
      </wui-grid>
    `;
  }
  async initialFetch() {
    var _a;
    const gridEl = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector("wui-grid");
    if (this.initial && gridEl) {
      await ApiController.fetchWallets({ page: 1 });
      await gridEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.initial = false;
      gridEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  shimmerTemplate(items, id) {
    return [...Array(items)].map(() => html`
        <wui-card-select-loader type="wallet" id=${ifDefined(id)}></wui-card-select-loader>
      `);
  }
  walletsTemplate() {
    const wallets = [...this.featured, ...this.recommended, ...this.wallets];
    const walletsWithInstalled = WalletUtil.markWalletsAsInstalled(wallets);
    return walletsWithInstalled.map((wallet) => html`
        <w3m-all-wallets-list-item
          @click=${() => this.onConnectWallet(wallet)}
          .wallet=${wallet}
        ></w3m-all-wallets-list-item>
      `);
  }
  paginationLoaderTemplate() {
    const { wallets, recommended, featured, count } = ApiController.state;
    const columns = window.innerWidth < 352 ? 3 : 4;
    const currentWallets = wallets.length + recommended.length;
    const minimumRows = Math.ceil(currentWallets / columns);
    let shimmerCount = minimumRows * columns - currentWallets + columns;
    shimmerCount -= wallets.length ? featured.length % columns : 0;
    if (count === 0 && featured.length > 0) {
      return null;
    }
    if (count === 0 || [...featured, ...wallets, ...recommended].length < count) {
      return this.shimmerTemplate(shimmerCount, PAGINATOR_ID);
    }
    return null;
  }
  createPaginationObserver() {
    var _a;
    const loaderEl = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector(`#${PAGINATOR_ID}`);
    if (loaderEl) {
      this.paginationObserver = new IntersectionObserver(([element]) => {
        if ((element == null ? void 0 : element.isIntersecting) && !this.initial) {
          const { page, count, wallets } = ApiController.state;
          if (wallets.length < count) {
            ApiController.fetchWallets({ page: page + 1 });
          }
        }
      });
      this.paginationObserver.observe(loaderEl);
    }
  }
  onConnectWallet(wallet) {
    const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
W3mAllWalletsList.styles = styles_default38;
__decorate57([
  state()
], W3mAllWalletsList.prototype, "initial", void 0);
__decorate57([
  state()
], W3mAllWalletsList.prototype, "wallets", void 0);
__decorate57([
  state()
], W3mAllWalletsList.prototype, "recommended", void 0);
__decorate57([
  state()
], W3mAllWalletsList.prototype, "featured", void 0);
W3mAllWalletsList = __decorate57([
  customElement("w3m-all-wallets-list")
], W3mAllWalletsList);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-list-item/styles.js
var styles_default39 = css`
  button {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    width: 104px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-s) var(--wui-spacing-0);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
    will-change: background-color, color;
    outline: none;
    border: none;
  }

  button > wui-flex > wui-text {
    color: var(--wui-color-fg-100);
    max-width: 86px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    justify-content: center;
  }

  button > wui-flex > wui-text.certified {
    max-width: 66px;
  }

  button:hover:enabled {
    background-color: var(--wui-color-gray-glass-005);
  }

  button:disabled > wui-flex > wui-text {
    color: var(--wui-color-gray-glass-015);
  }

  [data-selected='true'] {
    background-color: var(--wui-color-accent-glass-020);
  }

  @media (hover: hover) and (pointer: fine) {
    [data-selected='true']:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }
  }

  [data-selected='true']:active:enabled {
    background-color: var(--wui-color-accent-glass-010);
  }

  @media (max-width: 350px) {
    button {
      width: 100%;
    }
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-list-item/index.js
var __decorate58 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAllWalletsListItem = class W3mAllWalletsListItem2 extends LitElement {
  constructor() {
    super();
    this.observer = new IntersectionObserver(() => void 0);
    this.visible = false;
    this.imageSrc = void 0;
    this.imageLoading = false;
    this.wallet = void 0;
    this.observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          this.visible = true;
          this.fetchImageSrc();
        } else {
          this.visible = false;
        }
      });
    }, { threshold: 0.01 });
  }
  firstUpdated() {
    this.observer.observe(this);
  }
  disconnectedCallback() {
    this.observer.disconnect();
  }
  render() {
    var _a, _b;
    const certified = ((_a = this.wallet) == null ? void 0 : _a.badge_type) === "certified";
    return html`
      <button ontouchstart>
        ${this.imageTemplate()}
        <wui-flex flexDirection="row" alignItems="center" justifyContent="center" gap="3xs">
          <wui-text
            variant="tiny-500"
            color="inherit"
            class=${ifDefined(certified ? "certified" : void 0)}
            >${(_b = this.wallet) == null ? void 0 : _b.name}</wui-text
          >
          ${certified ? html`<wui-icon size="sm" name="walletConnectBrown"></wui-icon>` : null}
        </wui-flex>
      </button>
    `;
  }
  imageTemplate() {
    var _a, _b;
    if (!this.visible && !this.imageSrc || this.imageLoading) {
      return this.shimmerTemplate();
    }
    return html`
      <wui-wallet-image
        size="md"
        imageSrc=${ifDefined(this.imageSrc)}
        name=${(_a = this.wallet) == null ? void 0 : _a.name}
        .installed=${(_b = this.wallet) == null ? void 0 : _b.installed}
        badgeSize="sm"
      >
      </wui-wallet-image>
    `;
  }
  shimmerTemplate() {
    return html`<wui-shimmer width="56px" height="56px" borderRadius="xs"></wui-shimmer>`;
  }
  async fetchImageSrc() {
    if (!this.wallet) {
      return;
    }
    this.imageSrc = AssetUtil.getWalletImage(this.wallet);
    if (this.imageSrc) {
      return;
    }
    this.imageLoading = true;
    this.imageSrc = await AssetUtil.fetchWalletImage(this.wallet.image_id);
    this.imageLoading = false;
  }
};
W3mAllWalletsListItem.styles = styles_default39;
__decorate58([
  state()
], W3mAllWalletsListItem.prototype, "visible", void 0);
__decorate58([
  state()
], W3mAllWalletsListItem.prototype, "imageSrc", void 0);
__decorate58([
  state()
], W3mAllWalletsListItem.prototype, "imageLoading", void 0);
__decorate58([
  property()
], W3mAllWalletsListItem.prototype, "wallet", void 0);
W3mAllWalletsListItem = __decorate58([
  customElement("w3m-all-wallets-list-item")
], W3mAllWalletsListItem);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-search/styles.js
var styles_default40 = css`
  wui-grid,
  wui-loading-spinner,
  wui-flex {
    height: 360px;
  }

  wui-grid {
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 104px);
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    justify-content: center;
    align-items: center;
  }

  @media (max-width: 350px) {
    wui-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-search/index.js
var __decorate59 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAllWalletsSearch = class W3mAllWalletsSearch2 extends LitElement {
  constructor() {
    super(...arguments);
    this.prevQuery = "";
    this.prevBadge = void 0;
    this.loading = true;
    this.query = "";
  }
  render() {
    this.onSearch();
    return this.loading ? html`<wui-loading-spinner color="accent-100"></wui-loading-spinner>` : this.walletsTemplate();
  }
  async onSearch() {
    if (this.query.trim() !== this.prevQuery.trim() || this.badge !== this.prevBadge) {
      this.prevQuery = this.query;
      this.prevBadge = this.badge;
      this.loading = true;
      await ApiController.searchWallet({ search: this.query, badge: this.badge });
      this.loading = false;
    }
  }
  walletsTemplate() {
    const { search } = ApiController.state;
    const wallets = WalletUtil.markWalletsAsInstalled(search);
    if (!search.length) {
      return html`
        <wui-flex justifyContent="center" alignItems="center" gap="s" flexDirection="column">
          <wui-icon-box
            size="lg"
            iconColor="fg-200"
            backgroundColor="fg-300"
            icon="wallet"
            background="transparent"
          ></wui-icon-box>
          <wui-text color="fg-200" variant="paragraph-500">No Wallet found</wui-text>
        </wui-flex>
      `;
    }
    return html`
      <wui-grid
        .padding=${["0", "s", "s", "s"]}
        rowGap="l"
        columnGap="xs"
        justifyContent="space-between"
      >
        ${wallets.map((wallet) => html`
            <w3m-all-wallets-list-item
              @click=${() => this.onConnectWallet(wallet)}
              .wallet=${wallet}
              data-testid="wallet-search-item-${wallet.id}"
            ></w3m-all-wallets-list-item>
          `)}
      </wui-grid>
    `;
  }
  onConnectWallet(wallet) {
    const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
W3mAllWalletsSearch.styles = styles_default40;
__decorate59([
  state()
], W3mAllWalletsSearch.prototype, "loading", void 0);
__decorate59([
  property()
], W3mAllWalletsSearch.prototype, "query", void 0);
__decorate59([
  property()
], W3mAllWalletsSearch.prototype, "badge", void 0);
W3mAllWalletsSearch = __decorate59([
  customElement("w3m-all-wallets-search")
], W3mAllWalletsSearch);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-header/index.js
var __decorate60 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingHeader = class W3mConnectingHeader2 extends LitElement {
  constructor() {
    super();
    this.platformTabs = [];
    this.unsubscribe = [];
    this.platforms = [];
    this.onSelectPlatfrom = void 0;
    this.buffering = false;
    this.unsubscribe.push(ConnectionController.subscribeKey("buffering", (val) => this.buffering = val));
  }
  disconnectCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const tabs = this.generateTabs();
    return html`
      <wui-flex justifyContent="center" .padding=${["0", "0", "l", "0"]}>
        <wui-tabs
          ?disabled=${this.buffering}
          .tabs=${tabs}
          .onTabChange=${this.onTabChange.bind(this)}
        ></wui-tabs>
      </wui-flex>
    `;
  }
  generateTabs() {
    const tabs = this.platforms.map((platform) => {
      if (platform === "browser") {
        return { label: "Browser", icon: "extension", platform: "browser" };
      } else if (platform === "mobile") {
        return { label: "Mobile", icon: "mobile", platform: "mobile" };
      } else if (platform === "qrcode") {
        return { label: "Mobile", icon: "mobile", platform: "qrcode" };
      } else if (platform === "web") {
        return { label: "Webapp", icon: "browser", platform: "web" };
      } else if (platform === "desktop") {
        return { label: "Desktop", icon: "desktop", platform: "desktop" };
      }
      return { label: "Browser", icon: "extension", platform: "unsupported" };
    });
    this.platformTabs = tabs.map(({ platform }) => platform);
    return tabs;
  }
  onTabChange(index2) {
    var _a;
    const tab = this.platformTabs[index2];
    if (tab) {
      (_a = this.onSelectPlatfrom) == null ? void 0 : _a.call(this, tab);
    }
  }
};
__decorate60([
  property({ type: Array })
], W3mConnectingHeader.prototype, "platforms", void 0);
__decorate60([
  property()
], W3mConnectingHeader.prototype, "onSelectPlatfrom", void 0);
__decorate60([
  state()
], W3mConnectingHeader.prototype, "buffering", void 0);
W3mConnectingHeader = __decorate60([
  customElement("w3m-connecting-header")
], W3mConnectingHeader);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-browser/index.js
var __decorate61 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingWcBrowser = class W3mConnectingWcBrowser2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-browser: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onAutoConnect = this.onConnectProxy.bind(this);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "browser" }
    });
  }
  async onConnectProxy() {
    var _a;
    try {
      this.error = false;
      const { connectors } = ConnectorController.state;
      const connector = connectors.find((c5) => {
        var _a2, _b, _c;
        return c5.type === "ANNOUNCED" && ((_a2 = c5.info) == null ? void 0 : _a2.rdns) === ((_b = this.wallet) == null ? void 0 : _b.rdns) || c5.type === "INJECTED" || c5.name === ((_c = this.wallet) == null ? void 0 : _c.name);
      });
      if (connector) {
        await ConnectionController.connectExternal(connector, connector.chain);
      } else {
        throw new Error("w3m-connecting-wc-browser: No connector found");
      }
      ModalController.close();
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_SUCCESS",
        properties: { method: "browser", name: ((_a = this.wallet) == null ? void 0 : _a.name) || "Unknown" }
      });
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (error == null ? void 0 : error.message) ?? "Unknown" }
      });
      this.error = true;
    }
  }
};
W3mConnectingWcBrowser = __decorate61([
  customElement("w3m-connecting-wc-browser")
], W3mConnectingWcBrowser);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-desktop/index.js
var __decorate62 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingWcDesktop = class W3mConnectingWcDesktop2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-desktop: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onRender = this.onRenderProxy.bind(this);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "desktop" }
    });
  }
  onRenderProxy() {
    var _a;
    if (!this.ready && this.uri) {
      this.ready = true;
      (_a = this.onConnect) == null ? void 0 : _a.call(this);
    }
  }
  onConnectProxy() {
    var _a;
    if (((_a = this.wallet) == null ? void 0 : _a.desktop_link) && this.uri) {
      try {
        this.error = false;
        const { desktop_link, name } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatNativeUrl(desktop_link, this.uri);
        ConnectionController.setWcLinking({ name, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_blank");
      } catch {
        this.error = true;
      }
    }
  }
};
W3mConnectingWcDesktop = __decorate62([
  customElement("w3m-connecting-wc-desktop")
], W3mConnectingWcDesktop);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-mobile/index.js
var __decorate63 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingWcMobile = class W3mConnectingWcMobile2 extends W3mConnectingWidget {
  constructor() {
    super();
    this.btnLabelTimeout = void 0;
    this.labelTimeout = void 0;
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-mobile: No wallet provided");
    }
    this.secondaryBtnLabel = void 0;
    this.secondaryLabel = ConstantsUtil2.CONNECT_LABELS.MOBILE;
    this.onConnect = this.onConnectProxy.bind(this);
    this.onRender = this.onRenderProxy.bind(this);
    document.addEventListener("visibilitychange", this.onBuffering.bind(this));
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "mobile" }
    });
    this.btnLabelTimeout = setTimeout(() => {
      this.secondaryBtnLabel = "Try again";
      this.secondaryLabel = ConstantsUtil2.CONNECT_LABELS.MOBILE;
    }, ConstantsUtil2.FIVE_SEC_MS);
    this.labelTimeout = setTimeout(() => {
      this.secondaryLabel = `Hold tight... it's taking longer than expected`;
    }, ConstantsUtil2.THREE_SEC_MS);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("visibilitychange", this.onBuffering.bind(this));
    clearTimeout(this.btnLabelTimeout);
    clearTimeout(this.labelTimeout);
  }
  onRenderProxy() {
    var _a;
    if (!this.ready && this.uri) {
      this.ready = true;
      (_a = this.onConnect) == null ? void 0 : _a.call(this);
    }
  }
  onConnectProxy() {
    var _a;
    if (((_a = this.wallet) == null ? void 0 : _a.mobile_link) && this.uri) {
      try {
        this.error = false;
        const { mobile_link, name } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatNativeUrl(mobile_link, this.uri);
        ConnectionController.setWcLinking({ name, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_self");
        clearTimeout(this.labelTimeout);
        this.secondaryLabel = ConstantsUtil2.CONNECT_LABELS.MOBILE;
      } catch (e2) {
        EventsController.sendEvent({
          type: "track",
          event: "CONNECT_PROXY_ERROR",
          properties: {
            message: e2 instanceof Error ? e2.message : "Error parsing the deeplink",
            uri: this.uri,
            mobile_link: this.wallet.mobile_link,
            name: this.wallet.name
          }
        });
        this.error = true;
      }
    }
  }
  onBuffering() {
    const isIos = CoreHelperUtil.isIos();
    if ((document == null ? void 0 : document.visibilityState) === "visible" && !this.error && isIos) {
      ConnectionController.setBuffering(true);
      setTimeout(() => {
        ConnectionController.setBuffering(false);
      }, 5e3);
    }
  }
};
W3mConnectingWcMobile = __decorate63([
  customElement("w3m-connecting-wc-mobile")
], W3mConnectingWcMobile);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-qrcode/styles.js
var styles_default41 = css`
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-qrcode/index.js
var __decorate64 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingWcQrcode = class W3mConnectingWcQrcode2 extends W3mConnectingWidget {
  constructor() {
    var _a;
    super();
    this.forceUpdate = () => {
      this.requestUpdate();
    };
    window.addEventListener("resize", this.forceUpdate);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: ((_a = this.wallet) == null ? void 0 : _a.name) ?? "WalletConnect", platform: "qrcode" }
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("resize", this.forceUpdate);
  }
  render() {
    this.onRenderProxy();
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["0", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>

        <wui-text variant="paragraph-500" color="fg-100">
          Scan this QR Code with your phone
        </wui-text>
        ${this.copyTemplate()}
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.timeout = setTimeout(() => {
        this.ready = true;
      }, 200);
    }
  }
  qrCodeTemplate() {
    if (!this.uri || !this.ready) {
      return null;
    }
    const size3 = this.getBoundingClientRect().width - 40;
    const alt = this.wallet ? this.wallet.name : void 0;
    ConnectionController.setWcLinking(void 0);
    ConnectionController.setRecentWallet(this.wallet);
    return html` <wui-qr-code
      size=${size3}
      theme=${ThemeController.state.themeMode}
      uri=${this.uri}
      imageSrc=${ifDefined(AssetUtil.getWalletImage(this.wallet))}
      alt=${ifDefined(alt)}
      data-testid="wui-qr-code"
    ></wui-qr-code>`;
  }
  copyTemplate() {
    const inactive = !this.uri || !this.ready;
    return html`<wui-link
      .disabled=${inactive}
      @click=${this.onCopyUri}
      color="fg-200"
      data-testid="copy-wc2-uri"
    >
      <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
      Copy link
    </wui-link>`;
  }
};
W3mConnectingWcQrcode.styles = styles_default41;
W3mConnectingWcQrcode = __decorate64([
  customElement("w3m-connecting-wc-qrcode")
], W3mConnectingWcQrcode);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-unsupported/index.js
var __decorate65 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingWcUnsupported = class W3mConnectingWcUnsupported2 extends LitElement {
  constructor() {
    var _a;
    super();
    this.wallet = (_a = RouterController.state.data) == null ? void 0 : _a.wallet;
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-unsupported: No wallet provided");
    }
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "browser" }
    });
  }
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-wallet-image
          size="lg"
          imageSrc=${ifDefined(AssetUtil.getWalletImage(this.wallet))}
        ></wui-wallet-image>

        <wui-text variant="paragraph-500" color="fg-100">Not Detected</wui-text>
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
};
W3mConnectingWcUnsupported = __decorate65([
  customElement("w3m-connecting-wc-unsupported")
], W3mConnectingWcUnsupported);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-web/index.js
var __decorate66 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingWcWeb = class W3mConnectingWcWeb2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-web: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.secondaryBtnLabel = "Open";
    this.secondaryLabel = "Open and continue in a new browser tab";
    this.secondaryBtnIcon = "externalLink";
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "web" }
    });
  }
  onConnectProxy() {
    var _a;
    if (((_a = this.wallet) == null ? void 0 : _a.webapp_link) && this.uri) {
      try {
        this.error = false;
        const { webapp_link, name } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatUniversalUrl(webapp_link, this.uri);
        ConnectionController.setWcLinking({ name, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_blank");
      } catch {
        this.error = true;
      }
    }
  }
};
W3mConnectingWcWeb = __decorate66([
  customElement("w3m-connecting-wc-web")
], W3mConnectingWcWeb);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-swap-details/styles.js
var styles_default42 = css`
  :host {
    width: 100%;
  }

  .details-container > wui-flex {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    width: 100%;
  }

  .details-container > wui-flex > button {
    border: none;
    background: none;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    cursor: pointer;
  }

  .details-content-container {
    padding: var(--wui-spacing-1xs);
    padding-top: 0px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .details-content-container > wui-flex {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s);
    padding-left: var(--wui-spacing-s);
    padding-right: var(--wui-spacing-1xs);
    border-radius: calc(var(--wui-border-radius-5xs) + var(--wui-border-radius-4xs));
    background: var(--wui-color-gray-glass-002);
  }

  .details-row-title {
    white-space: nowrap;
  }

  .details-row.provider-free-row {
    padding-right: var(--wui-spacing-xs);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-swap-details/index.js
var __decorate67 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var slippageRate = ConstantsUtil2.CONVERT_SLIPPAGE_TOLERANCE;
var WuiSwapDetails = class WuiSwapDetails2 extends LitElement {
  constructor() {
    var _a;
    super();
    this.unsubscribe = [];
    this.networkName = (_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.name;
    this.detailsOpen = false;
    this.sourceToken = SwapController.state.sourceToken;
    this.toToken = SwapController.state.toToken;
    this.toTokenAmount = SwapController.state.toTokenAmount;
    this.sourceTokenPriceInUSD = SwapController.state.sourceTokenPriceInUSD;
    this.toTokenPriceInUSD = SwapController.state.toTokenPriceInUSD;
    this.gasPriceInUSD = SwapController.state.gasPriceInUSD;
    this.priceImpact = SwapController.state.priceImpact;
    this.maxSlippage = SwapController.state.maxSlippage;
    this.networkTokenSymbol = SwapController.state.networkTokenSymbol;
    this.inputError = SwapController.state.inputError;
    this.unsubscribe.push(...[
      SwapController.subscribe((newState) => {
        this.sourceToken = newState.sourceToken;
        this.toToken = newState.toToken;
        this.toTokenAmount = newState.toTokenAmount;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.priceImpact = newState.priceImpact;
        this.maxSlippage = newState.maxSlippage;
        this.sourceTokenPriceInUSD = newState.sourceTokenPriceInUSD;
        this.toTokenPriceInUSD = newState.toTokenPriceInUSD;
        this.inputError = newState.inputError;
      })
    ]);
  }
  render() {
    const minReceivedAmount = this.toTokenAmount && this.maxSlippage ? NumberUtil.bigNumber(this.toTokenAmount).minus(this.maxSlippage).toString() : null;
    if (!this.sourceToken || !this.toToken || this.inputError) {
      return null;
    }
    const toTokenSwappedAmount = this.sourceTokenPriceInUSD && this.toTokenPriceInUSD ? 1 / this.toTokenPriceInUSD * this.sourceTokenPriceInUSD : 0;
    return html`
      <wui-flex flexDirection="column" alignItems="center" gap="1xs" class="details-container">
        <wui-flex flexDirection="column">
          <button @click=${this.toggleDetails.bind(this)}>
            <wui-flex justifyContent="space-between" .padding=${["0", "xs", "0", "xs"]}>
              <wui-flex justifyContent="flex-start" flexGrow="1" gap="xs">
                <wui-text variant="small-400" color="fg-100">
                  1 ${this.sourceToken.symbol} =
                  ${UiHelperUtil.formatNumberToLocalString(toTokenSwappedAmount, 3)}
                  ${this.toToken.symbol}
                </wui-text>
                <wui-text variant="small-400" color="fg-200">
                  $${UiHelperUtil.formatNumberToLocalString(this.sourceTokenPriceInUSD)}
                </wui-text>
              </wui-flex>
              <wui-icon name="chevronBottom"></wui-icon>
            </wui-flex>
          </button>
          ${this.detailsOpen ? html`
                <wui-flex flexDirection="column" gap="xs" class="details-content-container">
                  <wui-flex flexDirection="column" gap="xs">
                    <wui-flex
                      justifyContent="space-between"
                      alignItems="center"
                      class="details-row"
                    >
                      <wui-flex alignItems="center" gap="xs">
                        <wui-text class="details-row-title" variant="small-400" color="fg-150">
                          Network cost
                        </wui-text>
                        <w3m-tooltip-trigger
                          text=${`Network cost is paid in ${this.networkTokenSymbol} on the ${this.networkName} network in order to execute transaction.`}
                        >
                          <wui-icon size="xs" color="fg-250" name="infoCircle"></wui-icon>
                        </w3m-tooltip-trigger>
                      </wui-flex>
                      <wui-text variant="small-400" color="fg-100">
                        $${UiHelperUtil.formatNumberToLocalString(this.gasPriceInUSD, 3)}
                      </wui-text>
                    </wui-flex>
                  </wui-flex>
                  ${this.priceImpact ? html` <wui-flex flexDirection="column" gap="xs">
                        <wui-flex
                          justifyContent="space-between"
                          alignItems="center"
                          class="details-row"
                        >
                          <wui-flex alignItems="center" gap="xs">
                            <wui-text class="details-row-title" variant="small-400" color="fg-150">
                              Price impact
                            </wui-text>
                            <w3m-tooltip-trigger
                              text="Price impact reflects the change in market price due to your trade"
                            >
                              <wui-icon size="xs" color="fg-250" name="infoCircle"></wui-icon>
                            </w3m-tooltip-trigger>
                          </wui-flex>
                          <wui-flex>
                            <wui-text variant="small-400" color="fg-200">
                              ${UiHelperUtil.formatNumberToLocalString(this.priceImpact, 3)}%
                            </wui-text>
                          </wui-flex>
                        </wui-flex>
                      </wui-flex>` : null}
                  ${this.maxSlippage && this.sourceToken.symbol ? html`<wui-flex flexDirection="column" gap="xs">
                        <wui-flex
                          justifyContent="space-between"
                          alignItems="center"
                          class="details-row"
                        >
                          <wui-flex alignItems="center" gap="xs">
                            <wui-text class="details-row-title" variant="small-400" color="fg-150">
                              Max. slippage
                            </wui-text>
                            <w3m-tooltip-trigger
                              text=${`Max slippage sets the minimum amount you must receive for the transaction to proceed. ${minReceivedAmount ? `Transaction will be reversed if you receive less than ${UiHelperUtil.formatNumberToLocalString(minReceivedAmount, 6)} ${this.toToken.symbol} due to price changes.` : ""}`}
                            >
                              <wui-icon size="xs" color="fg-250" name="infoCircle"></wui-icon>
                            </w3m-tooltip-trigger>
                          </wui-flex>
                          <wui-flex>
                            <wui-text variant="small-400" color="fg-200">
                              ${UiHelperUtil.formatNumberToLocalString(this.maxSlippage, 6)}
                              ${this.toToken.symbol} ${slippageRate}%
                            </wui-text>
                          </wui-flex>
                        </wui-flex>
                      </wui-flex>` : null}
                  <wui-flex flexDirection="column" gap="xs">
                    <wui-flex
                      justifyContent="space-between"
                      alignItems="center"
                      class="details-row provider-free-row"
                    >
                      <wui-flex alignItems="center" gap="xs">
                        <wui-text class="details-row-title" variant="small-400" color="fg-150">
                          Provider fee
                        </wui-text>
                      </wui-flex>
                      <wui-flex>
                        <wui-text variant="small-400" color="fg-200">0.85%</wui-text>
                      </wui-flex>
                    </wui-flex>
                  </wui-flex>
                </wui-flex>
              ` : null}
        </wui-flex>
      </wui-flex>
    `;
  }
  toggleDetails() {
    this.detailsOpen = !this.detailsOpen;
  }
};
WuiSwapDetails.styles = [styles_default42];
__decorate67([
  state()
], WuiSwapDetails.prototype, "networkName", void 0);
__decorate67([
  property()
], WuiSwapDetails.prototype, "detailsOpen", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "sourceToken", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "toToken", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "toTokenAmount", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "sourceTokenPriceInUSD", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "toTokenPriceInUSD", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "gasPriceInUSD", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "priceImpact", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "maxSlippage", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "networkTokenSymbol", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "inputError", void 0);
WuiSwapDetails = __decorate67([
  customElement("w3m-swap-details")
], WuiSwapDetails);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-swap-input/styles.js
var styles_default43 = css`
  :host > wui-flex {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    border-radius: var(--wui-border-radius-s);
    background-color: var(--wui-color-gray-glass-002);
    padding: var(--wui-spacing-xl);
    padding-right: var(--wui-spacing-s);
    width: 100%;
    height: 100px;
    box-sizing: border-box;
    box-shadow: inset 0px 0px 0px 1px var(--wui-color-gray-glass-002);
    position: relative;
    transition: box-shadow var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
  }

  :host wui-flex.focus {
    box-shadow: inset 0px 0px 0px 1px var(--wui-color-gray-glass-005);
  }

  :host > wui-flex .swap-input,
  :host > wui-flex .swap-token-button {
    z-index: 10;
  }

  :host > wui-flex .swap-input {
    -webkit-mask-image: linear-gradient(
      270deg,
      transparent 0px,
      transparent 8px,
      black 24px,
      black 25px,
      black 32px,
      black 100%
    );
    mask-image: linear-gradient(
      270deg,
      transparent 0px,
      transparent 8px,
      black 24px,
      black 25px,
      black 32px,
      black 100%
    );
  }

  :host > wui-flex .swap-input input {
    background: none;
    border: none;
    height: 42px;
    width: 100%;
    font-size: 32px;
    font-style: normal;
    font-weight: 400;
    line-height: 130%;
    letter-spacing: -1.28px;
    outline: none;
    caret-color: var(--wui-color-accent-100);
    color: var(--wui-color-fg-100);
    padding: 0px;
  }

  :host > wui-flex .swap-input input:focus-visible {
    outline: none;
  }

  :host > wui-flex .swap-input input::-webkit-outer-spin-button,
  :host > wui-flex .swap-input input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  .max-value-button {
    background-color: transparent;
    border: none;
    cursor: pointer;
    color: var(--wui-color-gray-glass-020);
    padding-left: 0px;
  }

  .market-value {
    min-height: 18px;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-swap-input/index.js
var __decorate68 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var MINIMUM_USD_VALUE_TO_CONVERT = 5e-5;
var W3mSwapInput = class W3mSwapInput2 extends LitElement {
  constructor() {
    super(...arguments);
    this.focused = false;
    this.price = 0;
    this.target = "sourceToken";
    this.onSetAmount = null;
    this.onSetMaxValue = null;
  }
  render() {
    const marketValue = this.marketValue || "0";
    const isMarketValueGreaterThanZero = NumberUtil.bigNumber(marketValue).isGreaterThan("0");
    return html`
      <wui-flex class="${this.focused ? "focus" : ""}" justifyContent="space-between">
        <wui-flex
          flex="1"
          flexDirection="column"
          alignItems="flex-start"
          justifyContent="center"
          class="swap-input"
        >
          <input
            data-testid="swap-input-${this.target}"
            @focusin=${() => this.onFocusChange(true)}
            @focusout=${() => this.onFocusChange(false)}
            ?disabled=${this.disabled}
            .value=${this.value}
            @input=${this.dispatchInputChangeEvent}
            @keydown=${this.handleKeydown}
            placeholder="0"
            type="text"
            inputmode="decimal"
          />
          <wui-text class="market-value" variant="small-400" color="fg-200">
            ${isMarketValueGreaterThanZero ? `$${UiHelperUtil.formatNumberToLocalString(this.marketValue, 3)}` : null}
          </wui-text>
        </wui-flex>
        ${this.templateTokenSelectButton()}
      </wui-flex>
    `;
  }
  handleKeydown(event) {
    return InputUtil.numericInputKeyDown(event, this.value, (value) => {
      var _a;
      return (_a = this.onSetAmount) == null ? void 0 : _a.call(this, this.target, value);
    });
  }
  dispatchInputChangeEvent(event) {
    if (!this.onSetAmount) {
      return;
    }
    const value = event.target.value.replace(/[^0-9.]/gu, "");
    if (value === "," || value === ".") {
      this.onSetAmount(this.target, "0.");
    } else if (value.endsWith(",")) {
      this.onSetAmount(this.target, value.replace(",", "."));
    } else {
      this.onSetAmount(this.target, value);
    }
  }
  setMaxValueToInput() {
    var _a;
    (_a = this.onSetMaxValue) == null ? void 0 : _a.call(this, this.target, this.balance);
  }
  templateTokenSelectButton() {
    if (!this.token) {
      return html` <wui-button
        data-testid="swap-select-token-button-${this.target}"
        class="swap-token-button"
        size="md"
        variant="accent"
        @click=${this.onSelectToken.bind(this)}
      >
        Select token
      </wui-button>`;
    }
    return html`
      <wui-flex
        class="swap-token-button"
        flexDirection="column"
        alignItems="flex-end"
        justifyContent="center"
        gap="xxs"
      >
        <wui-token-button
          data-testid="swap-input-token-${this.target}"
          text=${this.token.symbol}
          imageSrc=${this.token.logoUri}
          @click=${this.onSelectToken.bind(this)}
        >
        </wui-token-button>
        <wui-flex alignItems="center" gap="xxs"> ${this.tokenBalanceTemplate()} </wui-flex>
      </wui-flex>
    `;
  }
  tokenBalanceTemplate() {
    const balanceValueInUSD = NumberUtil.multiply(this.balance, this.price);
    const haveBalance = balanceValueInUSD ? balanceValueInUSD == null ? void 0 : balanceValueInUSD.isGreaterThan(MINIMUM_USD_VALUE_TO_CONVERT) : false;
    return html`
      ${haveBalance ? html`<wui-text variant="small-400" color="fg-200">
            ${UiHelperUtil.formatNumberToLocalString(this.balance, 3)}
          </wui-text>` : null}
      ${this.target === "sourceToken" ? this.tokenActionButtonTemplate(haveBalance) : null}
    `;
  }
  tokenActionButtonTemplate(haveBalance) {
    if (haveBalance) {
      return html` <button class="max-value-button" @click=${this.setMaxValueToInput.bind(this)}>
        <wui-text color="accent-100" variant="small-600">Max</wui-text>
      </button>`;
    }
    return html` <button class="max-value-button" @click=${this.onBuyToken.bind(this)}>
      <wui-text color="accent-100" variant="small-600">Buy</wui-text>
    </button>`;
  }
  onFocusChange(state3) {
    this.focused = state3;
  }
  onSelectToken() {
    EventsController.sendEvent({ type: "track", event: "CLICK_SELECT_TOKEN_TO_SWAP" });
    RouterController.push("SwapSelectToken", {
      target: this.target
    });
  }
  onBuyToken() {
    RouterController.push("OnRampProviders");
  }
};
W3mSwapInput.styles = [styles_default43];
__decorate68([
  property()
], W3mSwapInput.prototype, "focused", void 0);
__decorate68([
  property()
], W3mSwapInput.prototype, "balance", void 0);
__decorate68([
  property()
], W3mSwapInput.prototype, "value", void 0);
__decorate68([
  property()
], W3mSwapInput.prototype, "price", void 0);
__decorate68([
  property()
], W3mSwapInput.prototype, "marketValue", void 0);
__decorate68([
  property()
], W3mSwapInput.prototype, "disabled", void 0);
__decorate68([
  property()
], W3mSwapInput.prototype, "target", void 0);
__decorate68([
  property()
], W3mSwapInput.prototype, "token", void 0);
__decorate68([
  property()
], W3mSwapInput.prototype, "onSetAmount", void 0);
__decorate68([
  property()
], W3mSwapInput.prototype, "onSetMaxValue", void 0);
W3mSwapInput = __decorate68([
  customElement("w3m-swap-input")
], W3mSwapInput);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-swap-input-skeleton/styles.js
var styles_default44 = css`
  :host {
    width: 100%;
  }

  :host > wui-flex {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    border-radius: var(--wui-border-radius-s);
    padding: var(--wui-spacing-xl);
    padding-right: var(--wui-spacing-s);
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0px 0px 0px 1px var(--wui-color-gray-glass-002);
    width: 100%;
    height: 100px;
    box-sizing: border-box;
    position: relative;
  }

  wui-shimmer.market-value {
    opacity: 0;
  }

  :host > wui-flex > svg.input_mask {
    position: absolute;
    inset: 0;
    z-index: 5;
  }

  :host wui-flex .input_mask__border,
  :host wui-flex .input_mask__background {
    transition: fill var(--wui-duration-md) var(--wui-ease-out-power-1);
    will-change: fill;
  }

  :host wui-flex .input_mask__border {
    fill: var(--wui-color-gray-glass-020);
  }

  :host wui-flex .input_mask__background {
    fill: var(--wui-color-gray-glass-002);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-swap-input-skeleton/index.js
var __decorate69 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSwapInputSkeleton = class W3mSwapInputSkeleton2 extends LitElement {
  constructor() {
    super(...arguments);
    this.target = "sourceToken";
  }
  render() {
    return html`
      <wui-flex class justifyContent="space-between">
        <wui-flex
          flex="1"
          flexDirection="column"
          alignItems="flex-start"
          justifyContent="center"
          class="swap-input"
          gap="xxs"
        >
          <wui-shimmer width="80px" height="40px" borderRadius="xxs" variant="light"></wui-shimmer>
        </wui-flex>
        ${this.templateTokenSelectButton()}
      </wui-flex>
    `;
  }
  templateTokenSelectButton() {
    return html`
      <wui-flex
        class="swap-token-button"
        flexDirection="column"
        alignItems="flex-end"
        justifyContent="center"
        gap="xxs"
      >
        <wui-shimmer width="80px" height="40px" borderRadius="3xl" variant="light"></wui-shimmer>
      </wui-flex>
    `;
  }
};
W3mSwapInputSkeleton.styles = [styles_default44];
__decorate69([
  property()
], W3mSwapInputSkeleton.prototype, "target", void 0);
W3mSwapInputSkeleton = __decorate69([
  customElement("w3m-swap-input-skeleton")
], W3mSwapInputSkeleton);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-header/styles.js
var styles_default45 = css`
  :host {
    height: 64px;
  }

  wui-text {
    text-transform: capitalize;
  }

  wui-flex.w3m-header-title {
    transform: translateY(0);
    opacity: 1;
  }

  wui-flex.w3m-header-title[view-direction='prev'] {
    animation:
      slide-down-out 120ms forwards var(--wui-ease-out-power-2),
      slide-down-in 120ms forwards var(--wui-ease-out-power-2);
    animation-delay: 0ms, 200ms;
  }

  wui-flex.w3m-header-title[view-direction='next'] {
    animation:
      slide-up-out 120ms forwards var(--wui-ease-out-power-2),
      slide-up-in 120ms forwards var(--wui-ease-out-power-2);
    animation-delay: 0ms, 200ms;
  }

  wui-icon-link[data-hidden='true'] {
    opacity: 0 !important;
    pointer-events: none;
  }

  @keyframes slide-up-out {
    from {
      transform: translateY(0px);
      opacity: 1;
    }
    to {
      transform: translateY(3px);
      opacity: 0;
    }
  }

  @keyframes slide-up-in {
    from {
      transform: translateY(-3px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  @keyframes slide-down-out {
    from {
      transform: translateY(0px);
      opacity: 1;
    }
    to {
      transform: translateY(-3px);
      opacity: 0;
    }
  }

  @keyframes slide-down-in {
    from {
      transform: translateY(3px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-header/index.js
var __decorate70 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var BETA_SCREENS = ["SmartSessionList"];
function headings() {
  var _a, _b, _c, _d, _e3, _f, _g;
  const connectorName = (_b = (_a = RouterController.state.data) == null ? void 0 : _a.connector) == null ? void 0 : _b.name;
  const walletName = (_d = (_c = RouterController.state.data) == null ? void 0 : _c.wallet) == null ? void 0 : _d.name;
  const networkName = (_f = (_e3 = RouterController.state.data) == null ? void 0 : _e3.network) == null ? void 0 : _f.name;
  const name = walletName ?? connectorName;
  const connectors = ConnectorController.getConnectors();
  const isEmail = connectors.length === 1 && ((_g = connectors[0]) == null ? void 0 : _g.id) === "w3m-email";
  return {
    Connect: `Connect ${isEmail ? "Email" : ""} Wallet`,
    Create: "Create Wallet",
    ChooseAccountName: void 0,
    Account: void 0,
    AccountSettings: void 0,
    AllWallets: "All Wallets",
    ApproveTransaction: "Approve Transaction",
    BuyInProgress: "Buy",
    ConnectingExternal: name ?? "Connect Wallet",
    ConnectingWalletConnect: name ?? "WalletConnect",
    ConnectingSiwe: "Sign In",
    Convert: "Convert",
    ConvertSelectToken: "Select token",
    ConvertPreview: "Preview convert",
    Downloads: name ? `Get ${name}` : "Downloads",
    EmailVerifyOtp: "Confirm Email",
    EmailVerifyDevice: "Register Device",
    GetWallet: "Get a wallet",
    Networks: "Choose Network",
    OnRampProviders: "Choose Provider",
    OnRampActivity: "Activity",
    OnRampTokenSelect: "Select Token",
    OnRampFiatSelect: "Select Currency",
    Profile: void 0,
    SwitchNetwork: networkName ?? "Switch Network",
    SwitchAddress: "Switch Address",
    Transactions: "Activity",
    UnsupportedChain: "Switch Network",
    UpgradeEmailWallet: "Upgrade your Wallet",
    UpgradeToSmartAccount: void 0,
    UpdateEmailWallet: "Edit Email",
    UpdateEmailPrimaryOtp: "Confirm Current Email",
    UpdateEmailSecondaryOtp: "Confirm New Email",
    WhatIsABuy: "What is Buy?",
    RegisterAccountName: "Choose name",
    RegisterAccountNameSuccess: "",
    WalletReceive: "Receive",
    WalletCompatibleNetworks: "Compatible Networks",
    Swap: "Swap",
    SwapSelectToken: "Select token",
    SwapPreview: "Preview swap",
    WalletSend: "Send",
    WalletSendPreview: "Review send",
    WalletSendSelectToken: "Select Token",
    WhatIsANetwork: "What is a network?",
    WhatIsAWallet: "What is a wallet?",
    ConnectWallets: "Connect wallet",
    ConnectSocials: "All socials",
    ConnectingSocial: AccountController.state.socialProvider ? AccountController.state.socialProvider : "Connect Social",
    ConnectingMultiChain: "Select chain",
    ConnectingFarcaster: "Farcaster",
    SwitchActiveChain: "Switch chain",
    SmartSessionCreated: void 0,
    SmartSessionList: "Smart Sessions",
    SIWXSignMessage: "Sign In"
  };
}
var W3mHeader = class W3mHeader2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.heading = headings()[RouterController.state.view];
    this.network = ChainController.state.activeCaipNetwork;
    this.buffering = false;
    this.showBack = false;
    this.isSiweEnabled = OptionsController.state.isSiweEnabled;
    this.prevHistoryLength = 1;
    this.view = RouterController.state.view;
    this.viewDirection = "";
    this.headerText = headings()[RouterController.state.view];
    this.unsubscribe.push(RouterController.subscribeKey("view", (val) => {
      setTimeout(() => {
        this.view = val;
        this.headerText = headings()[val];
      }, ConstantsUtil4.ANIMATION_DURATIONS.HeaderText);
      this.onViewChange();
      this.onHistoryChange();
    }), ConnectionController.subscribeKey("buffering", (val) => this.buffering = val), ChainController.subscribeKey("activeCaipNetwork", (val) => this.network = val));
  }
  disconnectCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`
      <wui-flex .padding=${this.getPadding()} justifyContent="space-between" alignItems="center">
        ${this.leftHeaderTemplate()} ${this.titleTemplate()} ${this.rightHeaderTemplate()}
      </wui-flex>
    `;
  }
  onWalletHelp() {
    EventsController.sendEvent({ type: "track", event: "CLICK_WALLET_HELP" });
    RouterController.push("WhatIsAWallet");
  }
  async onClose() {
    const isUnsupportedChain = RouterController.state.view === "UnsupportedChain";
    if (this.isSiweEnabled) {
      const { SIWEController } = await import("./exports-JUL67YGQ.js");
      const isApproveSignScreen = RouterController.state.view === "ApproveTransaction";
      const isUnauthenticated = SIWEController.state.status !== "success";
      if (isUnauthenticated && isApproveSignScreen) {
        RouterController.popTransactionStack(true);
      } else {
        ModalController.close();
      }
    } else if (isUnsupportedChain) {
      ModalController.shake();
    } else {
      ModalController.close();
    }
  }
  rightHeaderTemplate() {
    var _a, _b, _c;
    const isSmartSessionsEnabled = (_c = (_b = (_a = OptionsController) == null ? void 0 : _a.state) == null ? void 0 : _b.features) == null ? void 0 : _c.smartSessions;
    if (RouterController.state.view !== "Account" || !isSmartSessionsEnabled) {
      return this.closeButtonTemplate();
    }
    return html`<wui-flex>
      <wui-icon-link
        icon="clock"
        @click=${() => RouterController.push("SmartSessionList")}
        data-testid="w3m-header-smart-sessions"
      ></wui-icon-link>
      ${this.closeButtonTemplate()}
    </wui-flex> `;
  }
  closeButtonTemplate() {
    const isSiweSignScreen = RouterController.state.view === "ConnectingSiwe";
    if (this.isSiweEnabled && isSiweSignScreen) {
      return html`<div style="width:40px" />`;
    }
    return html`
      <wui-icon-link
        ?disabled=${this.buffering}
        icon="close"
        @click=${this.onClose.bind(this)}
        data-testid="w3m-header-close"
      ></wui-icon-link>
    `;
  }
  titleTemplate() {
    const isBeta = BETA_SCREENS.includes(this.view);
    return html`
      <wui-flex
        view-direction="${this.viewDirection}"
        class="w3m-header-title"
        alignItems="center"
        gap="xs"
      >
        <wui-text variant="paragraph-700" color="fg-100" data-testid="w3m-header-text"
          >${this.headerText}</wui-text
        >
        ${isBeta ? html`<wui-tag variant="main">Beta</wui-tag>` : null}
      </wui-flex>
    `;
  }
  leftHeaderTemplate() {
    var _a;
    const { view } = RouterController.state;
    const isConnectHelp = view === "Connect";
    const isApproveTransaction = view === "ApproveTransaction";
    const isUpgradeToSmartAccounts = view === "UpgradeToSmartAccount";
    const isConnectingSIWEView = view === "ConnectingSiwe";
    const isAccountView = view === "Account";
    const shouldHideBack = isApproveTransaction || isUpgradeToSmartAccounts || isConnectingSIWEView;
    if (isAccountView) {
      return html`<wui-select
        id="dynamic"
        data-testid="w3m-account-select-network"
        active-network=${ifDefined((_a = this.network) == null ? void 0 : _a.name)}
        @click=${this.onNetworks.bind(this)}
        imageSrc=${ifDefined(AssetUtil.getNetworkImage(this.network))}
      ></wui-select>`;
    }
    if (this.showBack && !shouldHideBack) {
      return html`<wui-icon-link
        id="dynamic"
        icon="chevronLeft"
        ?disabled=${this.buffering}
        @click=${this.onGoBack.bind(this)}
      ></wui-icon-link>`;
    }
    return html`<wui-icon-link
      data-hidden=${!isConnectHelp}
      id="dynamic"
      icon="helpCircle"
      @click=${this.onWalletHelp.bind(this)}
    ></wui-icon-link>`;
  }
  onNetworks() {
    if (this.isAllowedNetworkSwitch()) {
      EventsController.sendEvent({ type: "track", event: "CLICK_NETWORKS" });
      RouterController.push("Networks");
    }
  }
  isAllowedNetworkSwitch() {
    const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const isMultiNetwork = requestedCaipNetworks ? requestedCaipNetworks.length > 1 : false;
    const isValidNetwork = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.find(({ id }) => {
      var _a;
      return id === ((_a = this.network) == null ? void 0 : _a.id);
    });
    return isMultiNetwork || !isValidNetwork;
  }
  getPadding() {
    if (this.heading) {
      return ["l", "2l", "l", "2l"];
    }
    return ["0", "2l", "0", "2l"];
  }
  onViewChange() {
    const { history } = RouterController.state;
    let direction = ConstantsUtil4.VIEW_DIRECTION.Next;
    if (history.length < this.prevHistoryLength) {
      direction = ConstantsUtil4.VIEW_DIRECTION.Prev;
    }
    this.prevHistoryLength = history.length;
    this.viewDirection = direction;
  }
  async onHistoryChange() {
    var _a;
    const { history } = RouterController.state;
    const buttonEl = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector("#dynamic");
    if (history.length > 1 && !this.showBack && buttonEl) {
      await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.showBack = true;
      buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    } else if (history.length <= 1 && this.showBack && buttonEl) {
      await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.showBack = false;
      buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  onGoBack() {
    RouterController.goBack();
  }
};
W3mHeader.styles = styles_default45;
__decorate70([
  state()
], W3mHeader.prototype, "heading", void 0);
__decorate70([
  state()
], W3mHeader.prototype, "network", void 0);
__decorate70([
  state()
], W3mHeader.prototype, "buffering", void 0);
__decorate70([
  state()
], W3mHeader.prototype, "showBack", void 0);
__decorate70([
  state()
], W3mHeader.prototype, "isSiweEnabled", void 0);
__decorate70([
  state()
], W3mHeader.prototype, "prevHistoryLength", void 0);
__decorate70([
  state()
], W3mHeader.prototype, "view", void 0);
__decorate70([
  state()
], W3mHeader.prototype, "viewDirection", void 0);
__decorate70([
  state()
], W3mHeader.prototype, "headerText", void 0);
W3mHeader = __decorate70([
  customElement("w3m-header")
], W3mHeader);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-help-widget/index.js
var __decorate71 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mHelpWidget = class W3mHelpWidget2 extends LitElement {
  constructor() {
    super(...arguments);
    this.data = [];
  }
  render() {
    return html`
      <wui-flex flexDirection="column" alignItems="center" gap="l">
        ${this.data.map((item) => html`
            <wui-flex flexDirection="column" alignItems="center" gap="xl">
              <wui-flex flexDirection="row" justifyContent="center" gap="1xs">
                ${item.images.map((image) => html`<wui-visual name=${image}></wui-visual>`)}
              </wui-flex>
            </wui-flex>
            <wui-flex flexDirection="column" alignItems="center" gap="xxs">
              <wui-text variant="paragraph-500" color="fg-100" align="center">
                ${item.title}
              </wui-text>
              <wui-text variant="small-500" color="fg-200" align="center">${item.text}</wui-text>
            </wui-flex>
          `)}
      </wui-flex>
    `;
  }
};
__decorate71([
  property({ type: Array })
], W3mHelpWidget.prototype, "data", void 0);
W3mHelpWidget = __decorate71([
  customElement("w3m-help-widget")
], W3mHelpWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-onramp-activity-item/styles.js
var styles_default46 = css`
  :host {
    width: 100%;
  }

  :host > wui-flex {
    width: 100%;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xs);
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: var(--wui-spacing-s);
  }

  :host > wui-flex:hover {
    background-color: var(--wui-color-gray-glass-002);
  }

  .purchase-image-container {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    width: var(--wui-icon-box-size-lg);
    height: var(--wui-icon-box-size-lg);
  }

  .purchase-image-container wui-image {
    width: 100%;
    height: 100%;
    position: relative;
    border-radius: calc(var(--wui-icon-box-size-lg) / 2);
  }

  .purchase-image-container wui-image::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-icon-box-size-lg) / 2);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  .purchase-image-container wui-icon-box {
    position: absolute;
    right: 0;
    bottom: 0;
    transform: translate(20%, 20%);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-onramp-activity-item/index.js
var __decorate72 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mOnRampActivityItem = class W3mOnRampActivityItem2 extends LitElement {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.color = "inherit";
    this.label = "Bought";
    this.purchaseValue = "";
    this.purchaseCurrency = "";
    this.date = "";
    this.completed = false;
    this.inProgress = false;
    this.failed = false;
    this.onClick = null;
    this.symbol = "";
  }
  firstUpdated() {
    if (!this.icon) {
      this.fetchTokenImage();
    }
  }
  render() {
    return html`
      <wui-flex>
        ${this.imageTemplate()}
        <wui-flex flexDirection="column" gap="4xs" flexGrow="1">
          <wui-flex gap="xxs" alignItems="center" justifyContent="flex-start">
            ${this.statusIconTemplate()}
            <wui-text variant="paragraph-500" color="fg-100"> ${this.label}</wui-text>
          </wui-flex>
          <wui-text variant="small-400" color="fg-200">
            + ${this.purchaseValue} ${this.purchaseCurrency}
          </wui-text>
        </wui-flex>
        ${this.inProgress ? html`<wui-loading-spinner color="fg-200" size="md"></wui-loading-spinner>` : html`<wui-text variant="micro-700" color="fg-300"><span>${this.date}</span></wui-text>`}
      </wui-flex>
    `;
  }
  async fetchTokenImage() {
    await ApiController._fetchTokenImage(this.purchaseCurrency);
  }
  statusIconTemplate() {
    if (this.inProgress) {
      return null;
    }
    return this.completed ? this.boughtIconTemplate() : this.errorIconTemplate();
  }
  errorIconTemplate() {
    return html`<wui-icon-box
      size="xxs"
      iconColor="error-100"
      backgroundColor="error-100"
      background="opaque"
      icon="close"
      borderColor="wui-color-bg-125"
    ></wui-icon-box>`;
  }
  imageTemplate() {
    const icon = this.icon || `https://avatar.vercel.sh/andrew.svg?size=50&text=${this.symbol}`;
    return html`<wui-flex class="purchase-image-container">
      <wui-image src=${icon}></wui-image>
    </wui-flex>`;
  }
  boughtIconTemplate() {
    return html`<wui-icon-box
      size="xxs"
      iconColor="success-100"
      backgroundColor="success-100"
      background="opaque"
      icon="arrowBottom"
      borderColor="wui-color-bg-125"
    ></wui-icon-box>`;
  }
};
W3mOnRampActivityItem.styles = [styles_default46];
__decorate72([
  property({ type: Boolean })
], W3mOnRampActivityItem.prototype, "disabled", void 0);
__decorate72([
  property()
], W3mOnRampActivityItem.prototype, "color", void 0);
__decorate72([
  property()
], W3mOnRampActivityItem.prototype, "label", void 0);
__decorate72([
  property()
], W3mOnRampActivityItem.prototype, "purchaseValue", void 0);
__decorate72([
  property()
], W3mOnRampActivityItem.prototype, "purchaseCurrency", void 0);
__decorate72([
  property()
], W3mOnRampActivityItem.prototype, "date", void 0);
__decorate72([
  property({ type: Boolean })
], W3mOnRampActivityItem.prototype, "completed", void 0);
__decorate72([
  property({ type: Boolean })
], W3mOnRampActivityItem.prototype, "inProgress", void 0);
__decorate72([
  property({ type: Boolean })
], W3mOnRampActivityItem.prototype, "failed", void 0);
__decorate72([
  property()
], W3mOnRampActivityItem.prototype, "onClick", void 0);
__decorate72([
  property()
], W3mOnRampActivityItem.prototype, "symbol", void 0);
__decorate72([
  property()
], W3mOnRampActivityItem.prototype, "icon", void 0);
W3mOnRampActivityItem = __decorate72([
  customElement("w3m-onramp-activity-item")
], W3mOnRampActivityItem);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-onramp-input/styles.js
var styles_default47 = css`
  :host {
    width: 100%;
  }

  wui-loading-spinner {
    position: absolute;
    top: 50%;
    right: 20px;
    transform: translateY(-50%);
  }

  .currency-container {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    right: var(--wui-spacing-1xs);
    height: 40px;
    padding: var(--wui-spacing-xs) var(--wui-spacing-1xs) var(--wui-spacing-xs)
      var(--wui-spacing-xs);
    min-width: 95px;
    border-radius: var(--FULL, 1000px);
    border: 1px solid var(--wui-color-gray-glass-002);
    background: var(--wui-color-gray-glass-002);
    cursor: pointer;
  }

  .currency-container > wui-image {
    height: 24px;
    width: 24px;
    border-radius: 50%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-onramp-input/index.js
var __decorate73 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mInputCurrency = class W3mInputCurrency2 extends LitElement {
  constructor() {
    var _a;
    super();
    this.unsubscribe = [];
    this.type = "Token";
    this.value = 0;
    this.currencies = [];
    this.selectedCurrency = (_a = this.currencies) == null ? void 0 : _a[0];
    this.currencyImages = AssetController.state.currencyImages;
    this.tokenImages = AssetController.state.tokenImages;
    this.unsubscribe.push(OnRampController.subscribeKey("purchaseCurrency", (val) => {
      if (!val || this.type === "Fiat") {
        return;
      }
      this.selectedCurrency = this.formatPurchaseCurrency(val);
    }), OnRampController.subscribeKey("paymentCurrency", (val) => {
      if (!val || this.type === "Token") {
        return;
      }
      this.selectedCurrency = this.formatPaymentCurrency(val);
    }), OnRampController.subscribe((val) => {
      if (this.type === "Fiat") {
        this.currencies = val.purchaseCurrencies.map(this.formatPurchaseCurrency);
      } else {
        this.currencies = val.paymentCurrencies.map(this.formatPaymentCurrency);
      }
    }), AssetController.subscribe((val) => {
      this.currencyImages = { ...val.currencyImages };
      this.tokenImages = { ...val.tokenImages };
    }));
  }
  firstUpdated() {
    OnRampController.getAvailableCurrencies();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a;
    const symbol = ((_a = this.selectedCurrency) == null ? void 0 : _a.symbol) || "";
    const image = this.currencyImages[symbol] || this.tokenImages[symbol];
    return html`<wui-input-text type="number" size="lg" value=${this.value}>
      ${this.selectedCurrency ? html` <wui-flex
            class="currency-container"
            justifyContent="space-between"
            alignItems="center"
            gap="xxs"
            @click=${() => ModalController.open({ view: `OnRamp${this.type}Select` })}
          >
            <wui-image src=${ifDefined(image)}></wui-image>
            <wui-text color="fg-100">${this.selectedCurrency.symbol}</wui-text>
          </wui-flex>` : html`<wui-loading-spinner></wui-loading-spinner>`}
    </wui-input-text>`;
  }
  formatPaymentCurrency(currency) {
    return {
      name: currency.id,
      symbol: currency.id
    };
  }
  formatPurchaseCurrency(currency) {
    return {
      name: currency.name,
      symbol: currency.symbol
    };
  }
};
W3mInputCurrency.styles = styles_default47;
__decorate73([
  property({ type: String })
], W3mInputCurrency.prototype, "type", void 0);
__decorate73([
  property({ type: Number })
], W3mInputCurrency.prototype, "value", void 0);
__decorate73([
  state()
], W3mInputCurrency.prototype, "currencies", void 0);
__decorate73([
  state()
], W3mInputCurrency.prototype, "selectedCurrency", void 0);
__decorate73([
  state()
], W3mInputCurrency.prototype, "currencyImages", void 0);
__decorate73([
  state()
], W3mInputCurrency.prototype, "tokenImages", void 0);
W3mInputCurrency = __decorate73([
  customElement("w3m-onramp-input")
], W3mInputCurrency);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-onramp-provider-item/styles.js
var styles_default48 = css`
  button {
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xs);
    border: none;
    outline: none;
    background-color: var(--wui-color-gray-glass-002);
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: var(--wui-spacing-s);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  button:hover {
    background-color: var(--wui-color-gray-glass-005);
  }

  .provider-image {
    width: var(--wui-spacing-3xl);
    min-width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
    border-radius: calc(var(--wui-border-radius-xs) - calc(var(--wui-spacing-s) / 2));
    position: relative;
    overflow: hidden;
  }

  .provider-image::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-border-radius-xs) - calc(var(--wui-spacing-s) / 2));
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  .network-icon {
    width: var(--wui-spacing-m);
    height: var(--wui-spacing-m);
    border-radius: calc(var(--wui-spacing-m) / 2);
    overflow: hidden;
    box-shadow:
      0 0 0 3px var(--wui-color-gray-glass-002),
      0 0 0 3px var(--wui-color-modal-bg);
    transition: box-shadow var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: box-shadow;
  }

  button:hover .network-icon {
    box-shadow:
      0 0 0 3px var(--wui-color-gray-glass-005),
      0 0 0 3px var(--wui-color-modal-bg);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-onramp-provider-item/index.js
var __decorate74 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mOnRampProviderItem = class W3mOnRampProviderItem2 extends LitElement {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.color = "inherit";
    this.label = "";
    this.feeRange = "";
    this.loading = false;
    this.onClick = null;
  }
  render() {
    return html`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-visual name=${ifDefined(this.name)} class="provider-image"></wui-visual>
        <wui-flex flexDirection="column" gap="4xs">
          <wui-text variant="paragraph-500" color="fg-100">${this.label}</wui-text>
          <wui-flex alignItems="center" justifyContent="flex-start" gap="l">
            <wui-text variant="tiny-500" color="fg-100">
              <wui-text variant="tiny-400" color="fg-200">Fees</wui-text>
              ${this.feeRange}
            </wui-text>
            <wui-flex gap="xxs">
              <wui-icon name="bank" size="xs" color="fg-150"></wui-icon>
              <wui-icon name="card" size="xs" color="fg-150"></wui-icon>
            </wui-flex>
            ${this.networksTemplate()}
          </wui-flex>
        </wui-flex>
        ${this.loading ? html`<wui-loading-spinner color="fg-200" size="md"></wui-loading-spinner>` : html`<wui-icon name="chevronRight" color="fg-200" size="sm"></wui-icon>`}
      </button>
    `;
  }
  networksTemplate() {
    var _a;
    const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const slicedNetworks = (_a = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.filter((network) => {
      var _a2;
      return (_a2 = network == null ? void 0 : network.assets) == null ? void 0 : _a2.imageId;
    })) == null ? void 0 : _a.slice(0, 5);
    return html`
      <wui-flex class="networks">
        ${slicedNetworks == null ? void 0 : slicedNetworks.map((network) => html`
            <wui-flex class="network-icon">
              <wui-image src=${ifDefined(AssetUtil.getNetworkImage(network))}></wui-image>
            </wui-flex>
          `)}
      </wui-flex>
    `;
  }
};
W3mOnRampProviderItem.styles = [styles_default48];
__decorate74([
  property({ type: Boolean })
], W3mOnRampProviderItem.prototype, "disabled", void 0);
__decorate74([
  property()
], W3mOnRampProviderItem.prototype, "color", void 0);
__decorate74([
  property()
], W3mOnRampProviderItem.prototype, "name", void 0);
__decorate74([
  property()
], W3mOnRampProviderItem.prototype, "label", void 0);
__decorate74([
  property()
], W3mOnRampProviderItem.prototype, "feeRange", void 0);
__decorate74([
  property({ type: Boolean })
], W3mOnRampProviderItem.prototype, "loading", void 0);
__decorate74([
  property()
], W3mOnRampProviderItem.prototype, "onClick", void 0);
W3mOnRampProviderItem = __decorate74([
  customElement("w3m-onramp-provider-item")
], W3mOnRampProviderItem);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-legal-footer/styles.js
var styles_default49 = css`
  wui-flex {
    background-color: var(--wui-color-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 500;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-legal-footer/index.js
var __decorate75 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mLegalFooter = class W3mLegalFooter2 extends LitElement {
  render() {
    var _a;
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    const legalCheckbox = (_a = OptionsController.state.features) == null ? void 0 : _a.legalCheckbox;
    if (!termsConditionsUrl && !privacyPolicyUrl) {
      return null;
    }
    if (legalCheckbox) {
      return null;
    }
    return html`
      <wui-flex .padding=${["m", "s", "s", "s"]} justifyContent="center">
        <wui-text color="fg-250" variant="small-400" align="center">
          By connecting your wallet, you agree to our <br />
          ${this.termsTemplate()} ${this.andTemplate()} ${this.privacyTemplate()}
        </wui-text>
      </wui-flex>
    `;
  }
  andTemplate() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    return termsConditionsUrl && privacyPolicyUrl ? "and" : "";
  }
  termsTemplate() {
    const { termsConditionsUrl } = OptionsController.state;
    if (!termsConditionsUrl) {
      return null;
    }
    return html`<a href=${termsConditionsUrl}>Terms of Service</a>`;
  }
  privacyTemplate() {
    const { privacyPolicyUrl } = OptionsController.state;
    if (!privacyPolicyUrl) {
      return null;
    }
    return html`<a href=${privacyPolicyUrl}>Privacy Policy</a>`;
  }
};
W3mLegalFooter.styles = [styles_default49];
W3mLegalFooter = __decorate75([
  customElement("w3m-legal-footer")
], W3mLegalFooter);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-legal-checkbox/styles.js
var styles_default50 = css`
  :host {
    display: flex;
    align-items: center;
    justify-content: center;
  }
  wui-checkbox {
    padding: var(--wui-spacing-s);
  }
  a {
    text-decoration: none;
    color: var(--wui-color-fg-150);
    font-weight: 500;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-legal-checkbox/index.js
var __decorate76 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mLegalCheckbox = class W3mLegalCheckbox2 extends LitElement {
  render() {
    var _a;
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    const legalCheckbox = (_a = OptionsController.state.features) == null ? void 0 : _a.legalCheckbox;
    if (!termsConditionsUrl && !privacyPolicyUrl) {
      return null;
    }
    if (!legalCheckbox) {
      return null;
    }
    return html`
      <wui-checkbox data-testid="wui-checkbox">
        <wui-text color="fg-250" variant="small-400" align="left">
          I agree to our ${this.termsTemplate()} ${this.andTemplate()} ${this.privacyTemplate()}
        </wui-text>
      </wui-checkbox>
    `;
  }
  andTemplate() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    return termsConditionsUrl && privacyPolicyUrl ? "and" : "";
  }
  termsTemplate() {
    const { termsConditionsUrl } = OptionsController.state;
    if (!termsConditionsUrl) {
      return null;
    }
    return html`<a rel="noreferrer" target="_blank" href=${termsConditionsUrl}>terms of service</a>`;
  }
  privacyTemplate() {
    const { privacyPolicyUrl } = OptionsController.state;
    if (!privacyPolicyUrl) {
      return null;
    }
    return html`<a rel="noreferrer" target="_blank" href=${privacyPolicyUrl}>privacy policy</a>`;
  }
};
W3mLegalCheckbox.styles = [styles_default50];
W3mLegalCheckbox = __decorate76([
  customElement("w3m-legal-checkbox")
], W3mLegalCheckbox);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-mobile-download-links/styles.js
var styles_default51 = css`
  :host {
    display: block;
    padding: 0 var(--wui-spacing-xl) var(--wui-spacing-xl);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-mobile-download-links/index.js
var __decorate77 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mMobileDownloadLinks = class W3mMobileDownloadLinks2 extends LitElement {
  constructor() {
    super(...arguments);
    this.wallet = void 0;
  }
  render() {
    if (!this.wallet) {
      this.style.display = "none";
      return null;
    }
    const { name, app_store, play_store, chrome_store, homepage } = this.wallet;
    const isMobile = CoreHelperUtil.isMobile();
    const isIos = CoreHelperUtil.isIos();
    const isAndroid = CoreHelperUtil.isAndroid();
    const isMultiple = [app_store, play_store, homepage, chrome_store].filter(Boolean).length > 1;
    const shortName = UiHelperUtil.getTruncateString({
      string: name,
      charsStart: 12,
      charsEnd: 0,
      truncate: "end"
    });
    if (isMultiple && !isMobile) {
      return html`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${() => RouterController.push("Downloads", { wallet: this.wallet })}
        ></wui-cta-button>
      `;
    }
    if (!isMultiple && homepage) {
      return html`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onHomePage.bind(this)}
        ></wui-cta-button>
      `;
    }
    if (app_store && isIos) {
      return html`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onAppStore.bind(this)}
        ></wui-cta-button>
      `;
    }
    if (play_store && isAndroid) {
      return html`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onPlayStore.bind(this)}
        ></wui-cta-button>
      `;
    }
    this.style.display = "none";
    return null;
  }
  onAppStore() {
    var _a;
    if ((_a = this.wallet) == null ? void 0 : _a.app_store) {
      CoreHelperUtil.openHref(this.wallet.app_store, "_blank");
    }
  }
  onPlayStore() {
    var _a;
    if ((_a = this.wallet) == null ? void 0 : _a.play_store) {
      CoreHelperUtil.openHref(this.wallet.play_store, "_blank");
    }
  }
  onHomePage() {
    var _a;
    if ((_a = this.wallet) == null ? void 0 : _a.homepage) {
      CoreHelperUtil.openHref(this.wallet.homepage, "_blank");
    }
  }
};
W3mMobileDownloadLinks.styles = [styles_default51];
__decorate77([
  property({ type: Object })
], W3mMobileDownloadLinks.prototype, "wallet", void 0);
W3mMobileDownloadLinks = __decorate77([
  customElement("w3m-mobile-download-links")
], W3mMobileDownloadLinks);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-onramp-providers-footer/styles.js
var styles_default52 = css`
  wui-flex {
    border-top: 1px solid var(--wui-color-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 500;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-3xs);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-onramp-providers-footer/index.js
var __decorate78 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mOnRampProvidersFooter = class W3mOnRampProvidersFooter2 extends LitElement {
  render() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    if (!termsConditionsUrl && !privacyPolicyUrl) {
      return null;
    }
    return html`
      <wui-flex
        .padding=${["m", "s", "s", "s"]}
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
        gap="s"
      >
        <wui-text color="fg-250" variant="small-400" align="center">
          We work with the best providers to give you the lowest fees and best support. More options
          coming soon!
        </wui-text>

        ${this.howDoesItWorkTemplate()}
      </wui-flex>
    `;
  }
  howDoesItWorkTemplate() {
    return html` <wui-link @click=${this.onWhatIsBuy.bind(this)}>
      <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
      How does it work?
    </wui-link>`;
  }
  onWhatIsBuy() {
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WHAT_IS_A_BUY",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("WhatIsABuy");
  }
};
W3mOnRampProvidersFooter.styles = [styles_default52];
W3mOnRampProvidersFooter = __decorate78([
  customElement("w3m-onramp-providers-footer")
], W3mOnRampProvidersFooter);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-snackbar/styles.js
var styles_default53 = css`
  :host {
    display: block;
    position: absolute;
    opacity: 0;
    pointer-events: none;
    top: 11px;
    left: 50%;
    width: max-content;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-snackbar/index.js
var __decorate79 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var presets = {
  loading: void 0,
  success: {
    backgroundColor: "success-100",
    iconColor: "success-100",
    icon: "checkmark"
  },
  error: {
    backgroundColor: "error-100",
    iconColor: "error-100",
    icon: "close"
  }
};
var W3mSnackBar = class W3mSnackBar2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.timeout = void 0;
    this.open = SnackController.state.open;
    this.unsubscribe.push(SnackController.subscribeKey("open", (val) => {
      this.open = val;
      this.onOpen();
    }));
  }
  disconnectedCallback() {
    clearTimeout(this.timeout);
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { message, variant, svg } = SnackController.state;
    const preset = presets[variant];
    const { icon, iconColor } = svg ?? preset ?? {};
    return html`
      <wui-snackbar
        message=${message}
        backgroundColor=${preset == null ? void 0 : preset.backgroundColor}
        iconColor=${iconColor}
        icon=${icon}
        .loading=${variant === "loading"}
      ></wui-snackbar>
    `;
  }
  onOpen() {
    clearTimeout(this.timeout);
    if (this.open) {
      this.animate([
        { opacity: 0, transform: "translateX(-50%) scale(0.85)" },
        { opacity: 1, transform: "translateX(-50%) scale(1)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
      this.timeout = setTimeout(() => SnackController.hide(), 2500);
    } else {
      this.animate([
        { opacity: 1, transform: "translateX(-50%) scale(1)" },
        { opacity: 0, transform: "translateX(-50%) scale(0.85)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
};
W3mSnackBar.styles = styles_default53;
__decorate79([
  state()
], W3mSnackBar.prototype, "open", void 0);
W3mSnackBar = __decorate79([
  customElement("w3m-snackbar")
], W3mSnackBar);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-alertbar/styles.js
var styles_default54 = css`
  :host {
    display: block;
    position: absolute;
    top: var(--wui-spacing-s);
    left: var(--wui-spacing-l);
    right: var(--wui-spacing-l);
    opacity: 0;
    pointer-events: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-alertbar/index.js
var __decorate80 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var presets2 = {
  info: {
    backgroundColor: "fg-350",
    iconColor: "fg-325",
    icon: "info"
  },
  success: {
    backgroundColor: "success-glass-reown-020",
    iconColor: "success-125",
    icon: "checkmark"
  },
  warning: {
    backgroundColor: "warning-glass-reown-020",
    iconColor: "warning-100",
    icon: "warningCircle"
  },
  error: {
    backgroundColor: "error-glass-reown-020",
    iconColor: "error-125",
    icon: "exclamationTriangle"
  }
};
var W3mAlertBar = class W3mAlertBar2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.open = AlertController.state.open;
    this.onOpen(true);
    this.unsubscribe.push(AlertController.subscribeKey("open", (val) => {
      this.open = val;
      this.onOpen(false);
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { message, variant } = AlertController.state;
    const preset = presets2[variant];
    return html`
      <wui-alertbar
        message=${message}
        backgroundColor=${preset == null ? void 0 : preset.backgroundColor}
        iconColor=${preset == null ? void 0 : preset.iconColor}
        icon=${preset == null ? void 0 : preset.icon}
      ></wui-alertbar>
    `;
  }
  onOpen(isMounted) {
    if (this.open) {
      this.animate([
        { opacity: 0, transform: "scale(0.85)" },
        { opacity: 1, transform: "scale(1)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
      this.style.cssText = `pointer-events: auto`;
    } else if (!isMounted) {
      this.animate([
        { opacity: 1, transform: "scale(1)" },
        { opacity: 0, transform: "scale(0.85)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
      this.style.cssText = `pointer-events: none`;
    }
  }
};
W3mAlertBar.styles = styles_default54;
__decorate80([
  state()
], W3mAlertBar.prototype, "open", void 0);
W3mAlertBar = __decorate80([
  customElement("w3m-alertbar")
], W3mAlertBar);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-email-login-widget/styles.js
var styles_default55 = css`
  wui-separator {
    margin: var(--wui-spacing-s) calc(var(--wui-spacing-s) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }

  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }

  wui-icon-link,
  wui-loading-spinner {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
  }

  wui-icon-link {
    right: var(--wui-spacing-xs);
  }

  wui-loading-spinner {
    right: var(--wui-spacing-m);
  }

  wui-text {
    margin: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-0) var(--wui-spacing-m);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-email-login-widget/index.js
var __decorate81 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mEmailLoginWidget = class W3mEmailLoginWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.formRef = createRef();
    this.connectors = ConnectorController.state.connectors;
    this.authConnector = this.connectors.find((c5) => c5.type === "AUTH");
    this.email = "";
    this.loading = false;
    this.error = "";
    this.walletGuide = "get-started";
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => {
      this.connectors = val;
      this.authConnector = val.find((c5) => c5.type === "AUTH");
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  firstUpdated() {
    var _a;
    (_a = this.formRef.value) == null ? void 0 : _a.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        this.onSubmitEmail(event);
      }
    });
  }
  render() {
    var _a;
    const email = (_a = OptionsController.state.features) == null ? void 0 : _a.email;
    if (!this.authConnector || !email) {
      return null;
    }
    return html`
      <form ${ref2(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
        <wui-email-input
          @focus=${this.onFocusEvent.bind(this)}
          .disabled=${this.loading}
          @inputChange=${this.onEmailInputChange.bind(this)}
          tabIdx=${ifDefined(this.tabIdx)}
        >
        </wui-email-input>

        ${this.submitButtonTemplate()}${this.loadingTemplate()}
        <input type="submit" hidden />
      </form>
      ${this.templateError()} ${this.separatorTemplate()}
    `;
  }
  submitButtonTemplate() {
    const showSubmit = !this.loading && this.email.length > 3;
    return showSubmit ? html`
          <wui-icon-link
            size="sm"
            icon="chevronRight"
            iconcolor="accent-100"
            @click=${this.onSubmitEmail.bind(this)}
          >
          </wui-icon-link>
        ` : null;
  }
  separatorTemplate() {
    var _a, _b;
    const socials = (_a = OptionsController.state.features) == null ? void 0 : _a.socials;
    const multipleConnectors = this.connectors.length > 1;
    const enableWallets = OptionsController.state.enableWallets;
    const emailShowWallets = (_b = OptionsController.state.features) == null ? void 0 : _b.emailShowWallets;
    const hideSeparator = socials && socials.length || emailShowWallets || !multipleConnectors || !enableWallets;
    if (hideSeparator && this.walletGuide === "get-started") {
      return null;
    }
    if (socials && socials.length > 0) {
      return null;
    }
    return html`
      <wui-flex
        data-testid="w3m-email-login-or-separator"
        .padding=${["xxs", "0", "0", "0"]}
      >
        <wui-separator text="or"></wui-separator>
      </wui-flex>
    `;
  }
  loadingTemplate() {
    return this.loading ? html`<wui-loading-spinner size="md" color="accent-100"></wui-loading-spinner>` : null;
  }
  templateError() {
    if (this.error) {
      return html`<wui-text variant="tiny-500" color="error-100">${this.error}</wui-text>`;
    }
    return null;
  }
  onEmailInputChange(event) {
    this.email = event.detail.trim();
    this.error = "";
  }
  async onSubmitEmail(event) {
    const availableChains = [ConstantsUtil.CHAIN.EVM, ConstantsUtil.CHAIN.SOLANA];
    const isAvailableChain = availableChains.find((chain) => chain === ChainController.state.activeChain);
    if (!isAvailableChain) {
      RouterController.push("SwitchActiveChain", {
        switchToChain: ConstantsUtil.CHAIN.EVM
      });
      return;
    }
    try {
      if (this.loading) {
        return;
      }
      this.loading = true;
      event.preventDefault();
      const authConnector = ConnectorController.getAuthConnector();
      if (!authConnector) {
        throw new Error("w3m-email-login-widget: Auth connector not found");
      }
      const { action } = await authConnector.provider.connectEmail({ email: this.email });
      EventsController.sendEvent({ type: "track", event: "EMAIL_SUBMITTED" });
      if (action === "VERIFY_OTP") {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
        RouterController.push("EmailVerifyOtp", { email: this.email });
      } else if (action === "VERIFY_DEVICE") {
        RouterController.push("EmailVerifyDevice", { email: this.email });
      }
    } catch (error) {
      const parsedError = CoreHelperUtil.parseError(error);
      if (parsedError == null ? void 0 : parsedError.includes("Invalid email")) {
        this.error = "Invalid email. Try again.";
      } else {
        SnackController.showError(error);
      }
    } finally {
      this.loading = false;
    }
  }
  onFocusEvent() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_LOGIN_SELECTED" });
  }
};
W3mEmailLoginWidget.styles = styles_default55;
__decorate81([
  property()
], W3mEmailLoginWidget.prototype, "tabIdx", void 0);
__decorate81([
  state()
], W3mEmailLoginWidget.prototype, "connectors", void 0);
__decorate81([
  state()
], W3mEmailLoginWidget.prototype, "authConnector", void 0);
__decorate81([
  state()
], W3mEmailLoginWidget.prototype, "email", void 0);
__decorate81([
  state()
], W3mEmailLoginWidget.prototype, "loading", void 0);
__decorate81([
  state()
], W3mEmailLoginWidget.prototype, "error", void 0);
__decorate81([
  property()
], W3mEmailLoginWidget.prototype, "walletGuide", void 0);
W3mEmailLoginWidget = __decorate81([
  customElement("w3m-email-login-widget")
], W3mEmailLoginWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-default-widget/styles.js
var styles_default56 = css`
  wui-flex {
    width: 100%;
  }

  :host > wui-flex:first-child {
    transform: translateY(calc(var(--wui-spacing-xxs) * -1));
  }

  wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }

  wui-notice-card {
    margin-bottom: var(--wui-spacing-3xs);
  }

  wui-list-item > wui-text {
    flex: 1;
  }

  w3m-transactions-view {
    max-height: 200px;
  }

  .tab-content-container {
    height: 300px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  .tab-content-container::-webkit-scrollbar {
    display: none;
  }

  .account-button {
    width: auto;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-s);
    height: 48px;
    padding: var(--wui-spacing-xs);
    padding-right: var(--wui-spacing-s);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: 24px;
    transition: background-color 0.2s linear;
  }

  .account-button:hover {
    background-color: var(--wui-color-gray-glass-005);
  }

  .avatar-container {
    position: relative;
  }

  wui-avatar.avatar {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }

  wui-avatar.network-avatar {
    width: 16px;
    height: 16px;
    position: absolute;
    left: 100%;
    top: 100%;
    transform: translate(-75%, -75%);
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }

  .account-links {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .account-links wui-flex {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    background: red;
    align-items: center;
    justify-content: center;
    height: 48px;
    padding: 10px;
    flex: 1 0 0;
    border-radius: var(--XS, 16px);
    border: 1px solid var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    background: var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    transition:
      background-color var(--wui-ease-out-power-1) var(--wui-duration-md),
      opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color, opacity;
  }

  .account-links wui-flex:hover {
    background: var(--dark-accent-glass-015, rgba(71, 161, 255, 0.15));
  }

  .account-links wui-flex wui-icon {
    width: var(--S, 20px);
    height: var(--S, 20px);
  }

  .account-links wui-flex wui-icon svg path {
    stroke: #667dff;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-default-widget/index.js
var __decorate82 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAccountDefaultWidget = class W3mAccountDefaultWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.caipAddress = AccountController.state.caipAddress;
    this.address = CoreHelperUtil.getPlainAddress(AccountController.state.caipAddress);
    this.allAccounts = AccountController.state.allAccounts;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.disconnecting = false;
    this.balance = AccountController.state.balance;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.features = OptionsController.state.features;
    this.unsubscribe.push(...[
      AccountController.subscribeKey("caipAddress", (val) => {
        this.address = CoreHelperUtil.getPlainAddress(val);
        this.caipAddress = val;
      }),
      AccountController.subscribeKey("balance", (val) => this.balance = val),
      AccountController.subscribeKey("balanceSymbol", (val) => this.balanceSymbol = val),
      AccountController.subscribeKey("profileName", (val) => this.profileName = val),
      AccountController.subscribeKey("profileImage", (val) => this.profileImage = val),
      OptionsController.subscribeKey("features", (val) => this.features = val),
      AccountController.subscribeKey("allAccounts", (allAccounts) => {
        this.allAccounts = allAccounts;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!this.caipAddress) {
      return null;
    }
    const shouldShowMultiAccount = ChainController.state.activeChain === ConstantsUtil.CHAIN.EVM && this.allAccounts.length > 1;
    return html`<wui-flex
        flexDirection="column"
        .padding=${["0", "xl", "m", "xl"]}
        alignItems="center"
        gap="l"
      >
        ${shouldShowMultiAccount ? this.multiAccountTemplate() : this.singleAccountTemplate()}
        <wui-flex flexDirection="column" alignItems="center">
          <wui-text variant="paragraph-500" color="fg-200">
            ${CoreHelperUtil.formatBalance(this.balance, this.balanceSymbol)}
          </wui-text>
        </wui-flex>
        ${this.explorerBtnTemplate()}
      </wui-flex>

      <wui-flex flexDirection="column" gap="xs" .padding=${["0", "s", "s", "s"]}>
        ${this.authCardTemplate()} <w3m-account-auth-button></w3m-account-auth-button>
        ${this.onrampTemplate()} ${this.swapsTemplate()} ${this.activityTemplate()}
        <wui-list-item
          variant="icon"
          iconVariant="overlay"
          icon="disconnect"
          ?chevron=${false}
          .loading=${this.disconnecting}
          @click=${this.onDisconnect.bind(this)}
          data-testid="disconnect-button"
        >
          <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
        </wui-list-item>
      </wui-flex>`;
  }
  onrampTemplate() {
    var _a;
    const onramp = (_a = this.features) == null ? void 0 : _a.onramp;
    if (!onramp) {
      return null;
    }
    return html`
      <wui-list-item
        data-testid="w3m-account-default-onramp-button"
        iconVariant="blue"
        icon="card"
        ?chevron=${true}
        @click=${this.handleClickPay.bind(this)}
      >
        <wui-text variant="paragraph-500" color="fg-100">Buy crypto</wui-text>
      </wui-list-item>
    `;
  }
  activityTemplate() {
    const isSolana = ChainController.state.activeChain === ConstantsUtil.CHAIN.SOLANA;
    return html` <wui-list-item
      iconVariant="blue"
      icon="clock"
      iconSize="sm"
      ?chevron=${!isSolana}
      ?disabled=${isSolana}
      @click=${this.onTransactions.bind(this)}
    >
      <wui-text variant="paragraph-500" color="fg-100" ?disabled=${isSolana}> Activity </wui-text>
      ${isSolana ? html`<wui-tag variant="main">Coming soon</wui-tag>` : ""}
    </wui-list-item>`;
  }
  swapsTemplate() {
    var _a;
    const swaps = (_a = this.features) == null ? void 0 : _a.swaps;
    const isSolana = ChainController.state.activeChain === ConstantsUtil.CHAIN.SOLANA;
    if (!swaps || isSolana) {
      return null;
    }
    return html`
      <wui-list-item
        iconVariant="blue"
        icon="recycleHorizontal"
        ?chevron=${true}
        @click=${this.handleClickSwap.bind(this)}
      >
        <wui-text variant="paragraph-500" color="fg-100">Swap</wui-text>
      </wui-list-item>
    `;
  }
  authCardTemplate() {
    const type = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    const { origin } = location;
    if (!authConnector || type !== "ID_AUTH" || origin.includes(ConstantsUtil2.SECURE_SITE)) {
      return null;
    }
    return html`
      <wui-notice-card
        @click=${this.onGoToUpgradeView.bind(this)}
        label="Upgrade your wallet"
        description="Transition to a self-custodial wallet"
        icon="wallet"
        data-testid="w3m-wallet-upgrade-card"
      ></wui-notice-card>
    `;
  }
  handleSwitchAccountsView() {
    RouterController.push("SwitchAddress");
  }
  handleClickPay() {
    RouterController.push("OnRampProviders");
  }
  handleClickSwap() {
    RouterController.push("Swap");
  }
  explorerBtnTemplate() {
    const addressExplorerUrl = AccountController.state.addressExplorerUrl;
    if (!addressExplorerUrl) {
      return null;
    }
    return html`
      <wui-button size="md" variant="neutral" @click=${this.onExplorer.bind(this)}>
        <wui-icon size="sm" color="inherit" slot="iconLeft" name="compass"></wui-icon>
        Block Explorer
        <wui-icon size="sm" color="inherit" slot="iconRight" name="externalLink"></wui-icon>
      </wui-button>
    `;
  }
  singleAccountTemplate() {
    return html`
      <wui-avatar
        alt=${ifDefined(this.caipAddress)}
        address=${ifDefined(CoreHelperUtil.getPlainAddress(this.caipAddress))}
        imageSrc=${ifDefined(this.profileImage === null ? void 0 : this.profileImage)}
        data-testid="single-account-avatar"
      ></wui-avatar>
      <wui-flex flexDirection="column" alignItems="center">
        <wui-flex gap="3xs" alignItems="center" justifyContent="center">
          <wui-text variant="large-600" color="fg-100">
            ${this.profileName ? UiHelperUtil.getTruncateString({
      string: this.profileName,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : UiHelperUtil.getTruncateString({
      string: this.address || "",
      charsStart: 4,
      charsEnd: 4,
      truncate: "middle"
    })}
          </wui-text>
          <wui-icon-link
            size="md"
            icon="copy"
            iconColor="fg-200"
            @click=${this.onCopyAddress}
          ></wui-icon-link> </wui-flex
      ></wui-flex>
    `;
  }
  multiAccountTemplate() {
    if (!this.address) {
      throw new Error("w3m-account-view: No account provided");
    }
    const account = this.allAccounts.find((acc) => acc.address === this.address);
    const label = AccountController.state.addressLabels.get(this.address);
    return html`
      <wui-profile-button-v2
        .onProfileClick=${this.handleSwitchAccountsView.bind(this)}
        address=${ifDefined(this.address)}
        icon="${(account == null ? void 0 : account.type) === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT && ChainController.state.activeChain === ConstantsUtil.CHAIN.EVM ? "lightbulb" : "mail"}"
        avatarSrc=${ifDefined(this.profileImage ? this.profileImage : void 0)}
        profileName=${ifDefined(label ? label : this.profileName)}
        .onCopyClick=${this.onCopyAddress.bind(this)}
      ></wui-profile-button-v2>
    `;
  }
  onCopyAddress() {
    try {
      if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
  onTransactions() {
    EventsController.sendEvent({
      type: "track",
      event: "CLICK_TRANSACTIONS",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("Transactions");
  }
  async onDisconnect() {
    try {
      this.disconnecting = true;
      await ConnectionController.disconnect();
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_SUCCESS" });
      ModalController.close();
    } catch {
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_ERROR" });
      SnackController.showError("Failed to disconnect");
    } finally {
      this.disconnecting = false;
    }
  }
  onExplorer() {
    const addressExplorerUrl = AccountController.state.addressExplorerUrl;
    if (addressExplorerUrl) {
      CoreHelperUtil.openHref(addressExplorerUrl, "_blank");
    }
  }
  onGoToUpgradeView() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_UPGRADE_FROM_MODAL" });
    RouterController.push("UpgradeEmailWallet");
  }
};
W3mAccountDefaultWidget.styles = styles_default56;
__decorate82([
  state()
], W3mAccountDefaultWidget.prototype, "caipAddress", void 0);
__decorate82([
  state()
], W3mAccountDefaultWidget.prototype, "address", void 0);
__decorate82([
  state()
], W3mAccountDefaultWidget.prototype, "allAccounts", void 0);
__decorate82([
  state()
], W3mAccountDefaultWidget.prototype, "profileImage", void 0);
__decorate82([
  state()
], W3mAccountDefaultWidget.prototype, "profileName", void 0);
__decorate82([
  state()
], W3mAccountDefaultWidget.prototype, "disconnecting", void 0);
__decorate82([
  state()
], W3mAccountDefaultWidget.prototype, "balance", void 0);
__decorate82([
  state()
], W3mAccountDefaultWidget.prototype, "balanceSymbol", void 0);
__decorate82([
  state()
], W3mAccountDefaultWidget.prototype, "features", void 0);
W3mAccountDefaultWidget = __decorate82([
  customElement("w3m-account-default-widget")
], W3mAccountDefaultWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-wallet-features-widget/styles.js
var styles_default57 = css`
  wui-flex {
    width: 100%;
  }

  wui-promo {
    position: absolute;
    top: -32px;
  }

  wui-profile-button {
    margin-top: calc(-1 * var(--wui-spacing-2l));
  }

  wui-promo + wui-profile-button {
    margin-top: var(--wui-spacing-2l);
  }

  wui-tabs {
    width: 100%;
  }

  .contentContainer {
    height: 280px;
  }

  .contentContainer > wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }

  .contentContainer > .textContent {
    width: 65%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-wallet-features-widget/index.js
var __decorate83 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var TABS = 3;
var TABS_PADDING = 48;
var MODAL_MOBILE_VIEW_PX = 430;
var W3mAccountWalletFeaturesWidget = class W3mAccountWalletFeaturesWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.smartAccountDeployed = AccountController.state.smartAccountDeployed;
    this.network = ChainController.state.activeCaipNetwork;
    this.currentTab = AccountController.state.currentTab;
    this.tokenBalance = AccountController.state.tokenBalance;
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.features = OptionsController.state.features;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileImage = val.profileImage;
          this.profileName = val.profileName;
          this.currentTab = val.currentTab;
          this.tokenBalance = val.tokenBalance;
          this.smartAccountDeployed = val.smartAccountDeployed;
          this.preferredAccountType = val.preferredAccountType;
        } else {
          ModalController.close();
        }
      })
    ], ChainController.subscribeKey("activeCaipNetwork", (val) => this.network = val), OptionsController.subscribeKey("features", (val) => this.features = val));
    this.watchSwapValues();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    clearInterval(this.watchTokenBalance);
  }
  firstUpdated() {
    AccountController.fetchTokenBalance();
  }
  render() {
    if (!this.address) {
      throw new Error("w3m-account-view: No account provided");
    }
    const networkImage = AssetUtil.getNetworkImage(this.network);
    return html`<wui-flex
      flexDirection="column"
      .padding=${["0", "xl", "m", "xl"]}
      alignItems="center"
      gap="m"
    >
      ${this.network && html`<wui-network-icon .network=${this.network}></wui-network-icon>`}
      ${this.activateAccountTemplate()}
      <wui-profile-button
        @click=${this.onProfileButtonClick.bind(this)}
        address=${ifDefined(this.address)}
        networkSrc=${ifDefined(networkImage)}
        icon="chevronBottom"
        avatarSrc=${ifDefined(this.profileImage ? this.profileImage : void 0)}
        profileName=${this.profileName}
        data-testid="w3m-profile-button"
      ></wui-profile-button>
      ${this.tokenBalanceTemplate()}
      <wui-flex gap="s">
        <w3m-tooltip-trigger text="Buy">
          <wui-icon-button
            data-testid="wallet-features-onramp-button"
            @click=${this.onBuyClick.bind(this)}
            icon="card"
          ></wui-icon-button>
        </w3m-tooltip-trigger>
        ${this.swapsTemplate()}
        <w3m-tooltip-trigger text="Receive">
          <wui-icon-button
            data-testid="wallet-features-receive-button"
            @click=${this.onReceiveClick.bind(this)}
            icon="arrowBottomCircle"
          >
          </wui-icon-button>
        </w3m-tooltip-trigger>
        <w3m-tooltip-trigger text="Send">
          <wui-icon-button
            data-testid="wallet-features-send-button"
            @click=${this.onSendClick.bind(this)}
            icon="send"
          ></wui-icon-button>
        </w3m-tooltip-trigger>
      </wui-flex>

      <wui-tabs
        .onTabChange=${this.onTabChange.bind(this)}
        .activeTab=${this.currentTab}
        localTabWidth=${CoreHelperUtil.isMobile() && window.innerWidth < MODAL_MOBILE_VIEW_PX ? `${(window.innerWidth - TABS_PADDING) / TABS}px` : "104px"}
        .tabs=${ConstantsUtil4.ACCOUNT_TABS}
      ></wui-tabs>
      ${this.listContentTemplate()}
    </wui-flex>`;
  }
  swapsTemplate() {
    var _a;
    const swaps = (_a = this.features) == null ? void 0 : _a.swaps;
    if (!swaps) {
      return null;
    }
    return html`
      <w3m-tooltip-trigger text="Swap">
        <wui-icon-button
          data-testid="wallet-features-swap-button"
          @click=${this.onSwapClick.bind(this)}
          icon="recycleHorizontal"
        >
        </wui-icon-button>
      </w3m-tooltip-trigger>
    `;
  }
  watchSwapValues() {
    this.watchTokenBalance = setInterval(() => AccountController.fetchTokenBalance(), 1e4);
  }
  listContentTemplate() {
    if (this.currentTab === 0) {
      return html`<w3m-account-tokens-widget></w3m-account-tokens-widget>`;
    }
    if (this.currentTab === 1) {
      return html`<w3m-account-nfts-widget></w3m-account-nfts-widget>`;
    }
    if (this.currentTab === 2) {
      return html`<w3m-account-activity-widget></w3m-account-activity-widget>`;
    }
    return html`<w3m-account-tokens-widget></w3m-account-tokens-widget>`;
  }
  tokenBalanceTemplate() {
    var _a;
    if (this.tokenBalance && ((_a = this.tokenBalance) == null ? void 0 : _a.length) >= 0) {
      const value = CoreHelperUtil.calculateBalance(this.tokenBalance);
      const { dollars = "0", pennies = "00" } = CoreHelperUtil.formatTokenBalance(value);
      return html`<wui-balance dollars=${dollars} pennies=${pennies}></wui-balance>`;
    }
    return html`<wui-balance dollars="0" pennies="00"></wui-balance>`;
  }
  activateAccountTemplate() {
    const smartAccountEnabled = ChainController.checkIfSmartAccountEnabled();
    if (!smartAccountEnabled || this.preferredAccountType !== W3mFrameRpcConstants.ACCOUNT_TYPES.EOA || this.smartAccountDeployed) {
      return null;
    }
    return html` <wui-promo
      text=${"Activate your account"}
      @click=${this.onUpdateToSmartAccount.bind(this)}
      data-testid="activate-smart-account-promo"
    ></wui-promo>`;
  }
  onTabChange(index2) {
    AccountController.setCurrentTab(index2);
  }
  onProfileButtonClick() {
    RouterController.push("Profile");
  }
  onBuyClick() {
    RouterController.push("OnRampProviders");
  }
  onSwapClick() {
    var _a, _b, _c;
    if (((_a = this.network) == null ? void 0 : _a.caipNetworkId) && !ConstantsUtil2.SWAP_SUPPORTED_NETWORKS.includes((_b = this.network) == null ? void 0 : _b.caipNetworkId)) {
      RouterController.push("UnsupportedChain", {
        swapUnsupportedChain: true
      });
    } else {
      EventsController.sendEvent({
        type: "track",
        event: "OPEN_SWAP",
        properties: {
          network: ((_c = this.network) == null ? void 0 : _c.caipNetworkId) || "",
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      RouterController.push("Swap");
    }
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
  onSendClick() {
    var _a;
    EventsController.sendEvent({
      type: "track",
      event: "OPEN_SEND",
      properties: {
        network: ((_a = this.network) == null ? void 0 : _a.caipNetworkId) || "",
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("WalletSend");
  }
  onUpdateToSmartAccount() {
    RouterController.push("UpgradeToSmartAccount");
  }
};
W3mAccountWalletFeaturesWidget.styles = styles_default57;
__decorate83([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "watchTokenBalance", void 0);
__decorate83([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "address", void 0);
__decorate83([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "profileImage", void 0);
__decorate83([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "profileName", void 0);
__decorate83([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "smartAccountDeployed", void 0);
__decorate83([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "network", void 0);
__decorate83([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "currentTab", void 0);
__decorate83([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "tokenBalance", void 0);
__decorate83([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "preferredAccountType", void 0);
__decorate83([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "features", void 0);
W3mAccountWalletFeaturesWidget = __decorate83([
  customElement("w3m-account-wallet-features-widget")
], W3mAccountWalletFeaturesWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-activity-widget/styles.js
var styles_default58 = css`
  :host {
    width: 100%;
    max-height: 280px;
    overflow: scroll;
    scrollbar-width: none;
  }

  :host::-webkit-scrollbar {
    display: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-activity-widget/index.js
var __decorate84 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAccountActivityWidget = class W3mAccountActivityWidget2 extends LitElement {
  render() {
    return html`<w3m-activity-list page="account"></w3m-activity-list>`;
  }
};
W3mAccountActivityWidget.styles = styles_default58;
W3mAccountActivityWidget = __decorate84([
  customElement("w3m-account-activity-widget")
], W3mAccountActivityWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-nfts-widget/styles.js
var styles_default59 = css`
  .contentContainer {
    height: 280px;
  }

  .contentContainer > wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }

  .contentContainer > .textContent {
    width: 65%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-nfts-widget/index.js
var __decorate85 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAccountNftsWidget = class W3mAccountNftsWidget2 extends LitElement {
  render() {
    return html`${this.nftTemplate()}`;
  }
  nftTemplate() {
    return html` <wui-flex
      class="contentContainer"
      alignItems="center"
      justifyContent="center"
      flexDirection="column"
      gap="l"
    >
      <wui-icon-box
        icon="wallet"
        size="inherit"
        iconColor="fg-200"
        backgroundColor="fg-200"
        iconSize="lg"
      ></wui-icon-box>
      <wui-flex
        class="textContent"
        gap="xs"
        flexDirection="column"
        justifyContent="center"
        flexDirection="column"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100">Coming soon</wui-text>
        <wui-text variant="small-400" align="center" color="fg-200"
          >Stay tuned for our upcoming NFT feature</wui-text
        >
      </wui-flex>
      <wui-link @click=${this.onReceiveClick.bind(this)}>Receive funds</wui-link>
    </wui-flex>`;
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
};
W3mAccountNftsWidget.styles = styles_default59;
W3mAccountNftsWidget = __decorate85([
  customElement("w3m-account-nfts-widget")
], W3mAccountNftsWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-tokens-widget/styles.js
var styles_default60 = css`
  :host {
    width: 100%;
  }

  wui-flex {
    width: 100%;
  }

  .contentContainer {
    max-height: 280px;
    overflow: scroll;
    scrollbar-width: none;
  }

  .contentContainer::-webkit-scrollbar {
    display: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-tokens-widget/index.js
var __decorate86 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAccountTokensWidget = class W3mAccountTokensWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tokenBalance = AccountController.state.tokenBalance;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        this.tokenBalance = val.tokenBalance;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`${this.tokenTemplate()}`;
  }
  tokenTemplate() {
    var _a;
    if (this.tokenBalance && ((_a = this.tokenBalance) == null ? void 0 : _a.length) > 0) {
      return html`<wui-flex class="contentContainer" flexDirection="column" gap="xs">
        ${this.tokenItemTemplate()}
      </wui-flex>`;
    }
    return html` <wui-flex flexDirection="column" gap="xs"
      ><wui-list-description
        @click=${this.onBuyClick.bind(this)}
        text="Buy Crypto"
        description="Easy with card or bank account"
        icon="card"
        iconColor="success-100"
        iconBackgroundColor="success-100"
        tag="popular"
      ></wui-list-description
      ><wui-list-description
        @click=${this.onReceiveClick.bind(this)}
        text="Receive funds"
        description="Transfer tokens on your wallet"
        icon="arrowBottomCircle"
        iconColor="fg-200"
        iconBackgroundColor="fg-200"
      ></wui-list-description
    ></wui-flex>`;
  }
  tokenItemTemplate() {
    var _a;
    return (_a = this.tokenBalance) == null ? void 0 : _a.map((token) => html`<wui-list-token
          tokenName=${token.name}
          tokenImageUrl=${token.iconUrl}
          tokenAmount=${token.quantity.numeric}
          tokenValue=${token.value}
          tokenCurrency=${token.symbol}
        ></wui-list-token>`);
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
  onBuyClick() {
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_BUY_CRYPTO",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("OnRampProviders");
  }
};
W3mAccountTokensWidget.styles = styles_default60;
__decorate86([
  state()
], W3mAccountTokensWidget.prototype, "tokenBalance", void 0);
W3mAccountTokensWidget = __decorate86([
  customElement("w3m-account-tokens-widget")
], W3mAccountTokensWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-activity-list/styles.js
var styles_default61 = css`
  :host {
    min-height: 100%;
  }

  .group-container[last-group='true'] {
    padding-bottom: var(--wui-spacing-m);
  }

  .contentContainer {
    height: 280px;
  }

  .contentContainer > wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }

  .contentContainer > .textContent {
    width: 65%;
  }

  .emptyContainer {
    height: 100%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-activity-list/index.js
var __decorate87 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var PAGINATOR_ID2 = "last-transaction";
var LOADING_ITEM_COUNT2 = 7;
var W3mActivityList = class W3mActivityList2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.paginationObserver = void 0;
    this.page = "activity";
    this.caipAddress = ChainController.state.activeCaipAddress;
    this.transactionsByYear = TransactionsController.state.transactionsByYear;
    this.loading = TransactionsController.state.loading;
    this.empty = TransactionsController.state.empty;
    this.next = TransactionsController.state.next;
    TransactionsController.clearCursor();
    this.unsubscribe.push(...[
      ChainController.subscribeKey("activeCaipAddress", (val) => {
        if (val) {
          if (this.caipAddress !== val) {
            TransactionsController.resetTransactions();
            TransactionsController.fetchTransactions(val);
          }
        }
        this.caipAddress = val;
      }),
      ChainController.subscribeKey("activeCaipNetwork", () => {
        this.updateTransactionView();
      }),
      TransactionsController.subscribe((val) => {
        this.transactionsByYear = val.transactionsByYear;
        this.loading = val.loading;
        this.empty = val.empty;
        this.next = val.next;
      })
    ]);
  }
  firstUpdated() {
    this.updateTransactionView();
    this.createPaginationObserver();
  }
  updated() {
    this.setPaginationObserver();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html` ${this.empty ? null : this.templateTransactionsByYear()}
    ${this.loading ? this.templateLoading() : null}
    ${!this.loading && this.empty ? this.templateEmpty() : null}`;
  }
  updateTransactionView() {
    var _a;
    const currentNetwork = (_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.caipNetworkId;
    const lastNetworkInView = TransactionsController.state.lastNetworkInView;
    if (lastNetworkInView !== currentNetwork) {
      TransactionsController.resetTransactions();
      if (this.caipAddress) {
        TransactionsController.fetchTransactions(CoreHelperUtil.getPlainAddress(this.caipAddress));
      }
    }
    TransactionsController.setLastNetworkInView(currentNetwork);
  }
  templateTransactionsByYear() {
    const sortedYearKeys = Object.keys(this.transactionsByYear).sort().reverse();
    return sortedYearKeys.map((year) => {
      const yearInt = parseInt(year, 10);
      const sortedMonthIndexes = new Array(12).fill(null).map((_3, idx) => {
        var _a;
        const groupTitle = TransactionUtil.getTransactionGroupTitle(yearInt, idx);
        const transactions = (_a = this.transactionsByYear[yearInt]) == null ? void 0 : _a[idx];
        return {
          groupTitle,
          transactions
        };
      }).filter(({ transactions }) => transactions).reverse();
      return sortedMonthIndexes.map(({ groupTitle, transactions }, index2) => {
        const isLastGroup = index2 === sortedMonthIndexes.length - 1;
        if (!transactions) {
          return null;
        }
        return html`
          <wui-flex
            flexDirection="column"
            class="group-container"
            last-group="${isLastGroup ? "true" : "false"}"
          >
            <wui-flex
              alignItems="center"
              flexDirection="row"
              .padding=${["xs", "s", "s", "s"]}
            >
              <wui-text variant="paragraph-500" color="fg-200">${groupTitle}</wui-text>
            </wui-flex>
            <wui-flex flexDirection="column" gap="xs">
              ${this.templateTransactions(transactions, isLastGroup)}
            </wui-flex>
          </wui-flex>
        `;
      });
    });
  }
  templateRenderTransaction(transaction, isLastTransaction) {
    const { date, descriptions, direction, isAllNFT, images, status, transfers, type } = this.getTransactionListItemProps(transaction);
    const haveMultipleTransfers = (transfers == null ? void 0 : transfers.length) > 1;
    const haveTwoTransfers = (transfers == null ? void 0 : transfers.length) === 2;
    if (haveTwoTransfers && !isAllNFT) {
      return html`
        <wui-transaction-list-item
          date=${date}
          .direction=${direction}
          id=${isLastTransaction && this.next ? PAGINATOR_ID2 : ""}
          status=${status}
          type=${type}
          .images=${images}
          .descriptions=${descriptions}
        ></wui-transaction-list-item>
      `;
    }
    if (haveMultipleTransfers) {
      return transfers.map((transfer, index2) => {
        const description = TransactionUtil.getTransferDescription(transfer);
        const isLastTransfer = isLastTransaction && index2 === transfers.length - 1;
        return html` <wui-transaction-list-item
          date=${date}
          direction=${transfer.direction}
          id=${isLastTransfer && this.next ? PAGINATOR_ID2 : ""}
          status=${status}
          type=${type}
          .onlyDirectionIcon=${true}
          .images=${[images[index2]]}
          .descriptions=${[description]}
        ></wui-transaction-list-item>`;
      });
    }
    return html`
      <wui-transaction-list-item
        date=${date}
        .direction=${direction}
        id=${isLastTransaction && this.next ? PAGINATOR_ID2 : ""}
        status=${status}
        type=${type}
        .images=${images}
        .descriptions=${descriptions}
      ></wui-transaction-list-item>
    `;
  }
  templateTransactions(transactions, isLastGroup) {
    return transactions.map((transaction, index2) => {
      const isLastTransaction = isLastGroup && index2 === transactions.length - 1;
      return html`${this.templateRenderTransaction(transaction, isLastTransaction)}`;
    });
  }
  emptyStateActivity() {
    return html`<wui-flex
      class="emptyContainer"
      flexGrow="1"
      flexDirection="column"
      justifyContent="center"
      alignItems="center"
      .padding=${["3xl", "xl", "3xl", "xl"]}
      gap="xl"
    >
      <wui-icon-box
        backgroundColor="gray-glass-005"
        background="gray"
        iconColor="fg-200"
        icon="wallet"
        size="lg"
        ?border=${true}
        borderColor="wui-color-bg-125"
      ></wui-icon-box>
      <wui-flex flexDirection="column" alignItems="center" gap="xs">
        <wui-text align="center" variant="paragraph-500" color="fg-100"
          >No Transactions yet</wui-text
        >
        <wui-text align="center" variant="small-500" color="fg-200"
          >Start trading on dApps <br />
          to grow your wallet!</wui-text
        >
      </wui-flex>
    </wui-flex>`;
  }
  emptyStateAccount() {
    return html`<wui-flex
      class="contentContainer"
      alignItems="center"
      justifyContent="center"
      flexDirection="column"
      gap="l"
    >
      <wui-icon-box
        icon="swapHorizontal"
        size="inherit"
        iconColor="fg-200"
        backgroundColor="fg-200"
        iconSize="lg"
      ></wui-icon-box>
      <wui-flex
        class="textContent"
        gap="xs"
        flexDirection="column"
        justifyContent="center"
        flexDirection="column"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100">No activity yet</wui-text>
        <wui-text variant="small-400" align="center" color="fg-200"
          >Your next transactions will appear here</wui-text
        >
      </wui-flex>
      <wui-link @click=${this.onReceiveClick.bind(this)}>Trade</wui-link>
    </wui-flex>`;
  }
  templateEmpty() {
    if (this.page === "account") {
      return html`${this.emptyStateAccount()}`;
    }
    return html`${this.emptyStateActivity()}`;
  }
  templateLoading() {
    if (this.page === "activity") {
      return Array(LOADING_ITEM_COUNT2).fill(html` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `).map((item) => item);
    }
    return null;
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
  createPaginationObserver() {
    const { projectId } = OptionsController.state;
    this.paginationObserver = new IntersectionObserver(([element]) => {
      if ((element == null ? void 0 : element.isIntersecting) && !this.loading) {
        TransactionsController.fetchTransactions(CoreHelperUtil.getPlainAddress(this.caipAddress));
        EventsController.sendEvent({
          type: "track",
          event: "LOAD_MORE_TRANSACTIONS",
          properties: {
            address: CoreHelperUtil.getPlainAddress(this.caipAddress),
            projectId,
            cursor: this.next,
            isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
          }
        });
      }
    }, {});
    this.setPaginationObserver();
  }
  setPaginationObserver() {
    var _a, _b, _c;
    (_a = this.paginationObserver) == null ? void 0 : _a.disconnect();
    const lastItem = (_b = this.shadowRoot) == null ? void 0 : _b.querySelector(`#${PAGINATOR_ID2}`);
    if (lastItem) {
      (_c = this.paginationObserver) == null ? void 0 : _c.observe(lastItem);
    }
  }
  getTransactionListItemProps(transaction) {
    var _a, _b, _c, _d, _e3;
    const date = DateUtil.formatDate((_a = transaction == null ? void 0 : transaction.metadata) == null ? void 0 : _a.minedAt);
    const descriptions = TransactionUtil.getTransactionDescriptions(transaction);
    const transfers = transaction == null ? void 0 : transaction.transfers;
    const transfer = (_b = transaction == null ? void 0 : transaction.transfers) == null ? void 0 : _b[0];
    const isAllNFT = Boolean(transfer) && ((_c = transaction == null ? void 0 : transaction.transfers) == null ? void 0 : _c.every((item) => Boolean(item.nft_info)));
    const images = TransactionUtil.getTransactionImages(transfers);
    return {
      date,
      direction: transfer == null ? void 0 : transfer.direction,
      descriptions,
      isAllNFT,
      images,
      status: (_d = transaction.metadata) == null ? void 0 : _d.status,
      transfers,
      type: (_e3 = transaction.metadata) == null ? void 0 : _e3.operationType
    };
  }
};
W3mActivityList.styles = styles_default61;
__decorate87([
  property()
], W3mActivityList.prototype, "page", void 0);
__decorate87([
  state()
], W3mActivityList.prototype, "caipAddress", void 0);
__decorate87([
  state()
], W3mActivityList.prototype, "transactionsByYear", void 0);
__decorate87([
  state()
], W3mActivityList.prototype, "loading", void 0);
__decorate87([
  state()
], W3mActivityList.prototype, "empty", void 0);
__decorate87([
  state()
], W3mActivityList.prototype, "next", void 0);
W3mActivityList = __decorate87([
  customElement("w3m-activity-list")
], W3mActivityList);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-input-token/styles.js
var styles_default62 = css`
  :host {
    width: 100%;
    height: 100px;
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-color-gray-glass-002);
    background-color: var(--wui-color-gray-glass-002);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
  }

  :host(:hover) {
    background-color: var(--wui-color-gray-glass-005);
  }

  wui-flex {
    width: 100%;
    height: fit-content;
  }

  wui-button {
    width: 100%;
    display: flex;
    justify-content: flex-end;
  }

  wui-input-amount {
    mask-image: linear-gradient(
      270deg,
      transparent 0px,
      transparent 8px,
      black 24px,
      black 25px,
      black 32px,
      black 100%
    );
  }

  .totalValue {
    width: 100%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-input-token/index.js
var __decorate88 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mInputToken = class W3mInputToken2 extends LitElement {
  render() {
    return html` <wui-flex
      flexDirection="column"
      gap="4xs"
      .padding=${["xl", "s", "l", "l"]}
    >
      <wui-flex alignItems="center">
        <wui-input-amount
          @inputChange=${this.onInputChange.bind(this)}
          ?disabled=${!this.token && true}
          .value=${this.sendTokenAmount ? String(this.sendTokenAmount) : ""}
        ></wui-input-amount>
        ${this.buttonTemplate()}
      </wui-flex>
      <wui-flex alignItems="center" justifyContent="space-between">
        ${this.sendValueTemplate()}
        <wui-flex alignItems="center" gap="4xs" justifyContent="flex-end">
          ${this.maxAmountTemplate()} ${this.actionTemplate()}
        </wui-flex>
      </wui-flex>
    </wui-flex>`;
  }
  buttonTemplate() {
    if (this.token) {
      return html`<wui-token-button
        text=${this.token.symbol}
        imageSrc=${this.token.iconUrl}
        @click=${this.handleSelectButtonClick.bind(this)}
      >
      </wui-token-button>`;
    }
    return html`<wui-button
      size="md"
      variant="accent"
      @click=${this.handleSelectButtonClick.bind(this)}
      >Select token</wui-button
    >`;
  }
  handleSelectButtonClick() {
    RouterController.push("WalletSendSelectToken");
  }
  sendValueTemplate() {
    if (this.token && this.sendTokenAmount) {
      const price = this.token.price;
      const totalValue = price * this.sendTokenAmount;
      return html`<wui-text class="totalValue" variant="small-400" color="fg-200"
        >${totalValue ? `$${UiHelperUtil.formatNumberToLocalString(totalValue, 2)}` : "Incorrect value"}</wui-text
      >`;
    }
    return null;
  }
  maxAmountTemplate() {
    if (this.token) {
      if (this.sendTokenAmount && this.sendTokenAmount > Number(this.token.quantity.numeric)) {
        return html` <wui-text variant="small-400" color="error-100">
          ${UiHelperUtil.roundNumber(Number(this.token.quantity.numeric), 6, 5)}
        </wui-text>`;
      }
      return html` <wui-text variant="small-400" color="fg-200">
        ${UiHelperUtil.roundNumber(Number(this.token.quantity.numeric), 6, 5)}
      </wui-text>`;
    }
    return null;
  }
  actionTemplate() {
    if (this.token) {
      if (this.sendTokenAmount && this.sendTokenAmount > Number(this.token.quantity.numeric)) {
        return html`<wui-link @click=${this.onBuyClick.bind(this)}>Buy</wui-link>`;
      }
      return html`<wui-link @click=${this.onMaxClick.bind(this)}>Max</wui-link>`;
    }
    return null;
  }
  onInputChange(event) {
    SendController.setTokenAmount(event.detail);
  }
  onMaxClick() {
    if (this.token && typeof this.gasPrice !== "undefined") {
      const isNetworkToken = this.token.address === void 0 || Object.values(ConstantsUtil2.NATIVE_TOKEN_ADDRESS).some((nativeAddress) => {
        var _a;
        return ((_a = this.token) == null ? void 0 : _a.address) === nativeAddress;
      });
      const numericGas = NumberUtil.bigNumber(this.gasPrice).shiftedBy(-this.token.quantity.decimals);
      const maxValue = isNetworkToken ? NumberUtil.bigNumber(this.token.quantity.numeric).minus(numericGas) : NumberUtil.bigNumber(this.token.quantity.numeric);
      SendController.setTokenAmount(Number(maxValue.toFixed(20)));
    }
  }
  onBuyClick() {
    RouterController.push("OnRampProviders");
  }
};
W3mInputToken.styles = styles_default62;
__decorate88([
  property({ type: Object })
], W3mInputToken.prototype, "token", void 0);
__decorate88([
  property({ type: Number })
], W3mInputToken.prototype, "sendTokenAmount", void 0);
__decorate88([
  property({ type: Number })
], W3mInputToken.prototype, "gasPriceInUSD", void 0);
__decorate88([
  property({ type: Number })
], W3mInputToken.prototype, "gasPrice", void 0);
W3mInputToken = __decorate88([
  customElement("w3m-input-token")
], W3mInputToken);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-input-address/styles.js
var styles_default63 = css`
  :host {
    width: 100%;
    height: 100px;
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-color-gray-glass-002);
    background-color: var(--wui-color-gray-glass-002);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
    position: relative;
  }

  :host(:hover) {
    background-color: var(--wui-color-gray-glass-005);
  }

  wui-flex {
    width: 100%;
    height: fit-content;
  }

  wui-button {
    display: ruby;
    color: var(--wui-color-fg-100);
    margin: 0 var(--wui-spacing-xs);
  }

  .instruction {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    z-index: 2;
  }

  .paste {
    display: inline-flex;
  }

  textarea {
    background: transparent;
    width: 100%;
    font-family: var(--w3m-font-family);
    font-size: var(--wui-font-size-medium);
    font-style: normal;
    font-weight: var(--wui-font-weight-light);
    line-height: 130%;
    letter-spacing: var(--wui-letter-spacing-medium);
    color: var(--wui-color-fg-100);
    caret-color: var(--wui-color-accent-100);
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
    border: none;
    outline: none;
    appearance: none;
    resize: none;
    overflow: hidden;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-input-address/index.js
var __decorate89 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mInputAddress = class W3mInputAddress2 extends LitElement {
  constructor() {
    super(...arguments);
    this.inputElementRef = createRef();
    this.instructionElementRef = createRef();
    this.instructionHidden = Boolean(this.value);
    this.pasting = false;
    this.onDebouncedSearch = CoreHelperUtil.debounce(async (value) => {
      const address = await ConnectionController.getEnsAddress(value);
      SendController.setLoading(false);
      if (address) {
        SendController.setReceiverProfileName(value);
        SendController.setReceiverAddress(address);
        const avatar = await ConnectionController.getEnsAvatar(value);
        SendController.setReceiverProfileImageUrl(avatar || void 0);
      } else {
        SendController.setReceiverAddress(value);
        SendController.setReceiverProfileName(void 0);
        SendController.setReceiverProfileImageUrl(void 0);
      }
    });
  }
  firstUpdated() {
    if (this.value) {
      this.instructionHidden = true;
    }
    this.checkHidden();
  }
  render() {
    return html` <wui-flex
      @click=${this.onBoxClick.bind(this)}
      flexDirection="column"
      justifyContent="center"
      gap="4xs"
      .padding=${["2xl", "l", "xl", "l"]}
    >
      <wui-text
        ${ref2(this.instructionElementRef)}
        class="instruction"
        color="fg-300"
        variant="medium-400"
      >
        Type or
        <wui-button
          class="paste"
          size="md"
          variant="neutral"
          iconLeft="copy"
          @click=${this.onPasteClick.bind(this)}
        >
          <wui-icon size="sm" color="inherit" slot="iconLeft" name="copy"></wui-icon>
          Paste
        </wui-button>
        address
      </wui-text>
      <textarea
        spellcheck="false"
        ?disabled=${!this.instructionHidden}
        ${ref2(this.inputElementRef)}
        @input=${this.onInputChange.bind(this)}
        @blur=${this.onBlur.bind(this)}
        .value=${this.value ?? ""}
        autocomplete="off"
      >
${this.value ?? ""}</textarea
      >
    </wui-flex>`;
  }
  async focusInput() {
    var _a;
    if (this.instructionElementRef.value) {
      this.instructionHidden = true;
      await this.toggleInstructionFocus(false);
      this.instructionElementRef.value.style.pointerEvents = "none";
      (_a = this.inputElementRef.value) == null ? void 0 : _a.focus();
      if (this.inputElementRef.value) {
        this.inputElementRef.value.selectionStart = this.inputElementRef.value.selectionEnd = this.inputElementRef.value.value.length;
      }
    }
  }
  async focusInstruction() {
    var _a;
    if (this.instructionElementRef.value) {
      this.instructionHidden = false;
      await this.toggleInstructionFocus(true);
      this.instructionElementRef.value.style.pointerEvents = "auto";
      (_a = this.inputElementRef.value) == null ? void 0 : _a.blur();
    }
  }
  async toggleInstructionFocus(focus) {
    if (this.instructionElementRef.value) {
      await this.instructionElementRef.value.animate([{ opacity: focus ? 0 : 1 }, { opacity: focus ? 1 : 0 }], {
        duration: 100,
        easing: "ease",
        fill: "forwards"
      }).finished;
    }
  }
  onBoxClick() {
    if (!this.value && !this.instructionHidden) {
      this.focusInput();
    }
  }
  onBlur() {
    if (!this.value && this.instructionHidden && !this.pasting) {
      this.focusInstruction();
    }
  }
  checkHidden() {
    if (this.instructionHidden) {
      this.focusInput();
    }
  }
  async onPasteClick() {
    this.pasting = true;
    const text = await navigator.clipboard.readText();
    SendController.setReceiverAddress(text);
    this.focusInput();
  }
  onInputChange(e2) {
    this.pasting = false;
    const element = e2.target;
    if (element.value && !this.instructionHidden) {
      this.focusInput();
    }
    SendController.setLoading(true);
    this.onDebouncedSearch(element.value);
  }
};
W3mInputAddress.styles = styles_default63;
__decorate89([
  property()
], W3mInputAddress.prototype, "value", void 0);
__decorate89([
  state()
], W3mInputAddress.prototype, "instructionHidden", void 0);
__decorate89([
  state()
], W3mInputAddress.prototype, "pasting", void 0);
W3mInputAddress = __decorate89([
  customElement("w3m-input-address")
], W3mInputAddress);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-wallet-send-details/styles.js
var styles_default64 = css`
  :host {
    display: flex;
    width: auto;
    flex-direction: column;
    gap: var(--wui-border-radius-1xs);
    border-radius: var(--wui-border-radius-s);
    background: var(--wui-color-gray-glass-002);
    padding: var(--wui-spacing-s) var(--wui-spacing-1xs) var(--wui-spacing-1xs)
      var(--wui-spacing-1xs);
  }

  wui-text {
    padding: 0 var(--wui-spacing-1xs);
  }

  wui-flex {
    margin-top: var(--wui-spacing-1xs);
  }

  .network {
    cursor: pointer;
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
  }

  .network:focus-visible {
    border: 1px solid var(--wui-color-accent-100);
    background-color: var(--wui-color-gray-glass-005);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  .network:hover {
    background-color: var(--wui-color-gray-glass-005);
  }

  .network:active {
    background-color: var(--wui-color-gray-glass-010);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-wallet-send-details/index.js
var __decorate90 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mWalletSendDetails = class W3mWalletSendDetails2 extends LitElement {
  render() {
    return html` <wui-text variant="small-400" color="fg-200">Details</wui-text>
      <wui-flex flexDirection="column" gap="xxs">
        <wui-list-content textTitle="Network cost" textValue="$${ifDefined(UiHelperUtil.formatNumberToLocalString(this.networkFee, 2))}"></wui-list-content></wui-list-content>
        <wui-list-content
          textTitle="Address"
          textValue=${UiHelperUtil.getTruncateString({
      string: this.receiverAddress ?? "",
      charsStart: 4,
      charsEnd: 4,
      truncate: "middle"
    })}
        >
        </wui-list-content>
        ${this.networkTemplate()}
      </wui-flex>`;
  }
  networkTemplate() {
    var _a;
    if ((_a = this.caipNetwork) == null ? void 0 : _a.name) {
      return html` <wui-list-content
        @click=${() => this.onNetworkClick(this.caipNetwork)}
        class="network"
        textTitle="Network"
        imageSrc=${ifDefined(AssetUtil.getNetworkImage(this.caipNetwork))}
      ></wui-list-content>`;
    }
    return null;
  }
  onNetworkClick(network) {
    if (network) {
      RouterController.push("Networks", { network });
    }
  }
};
W3mWalletSendDetails.styles = styles_default64;
__decorate90([
  property()
], W3mWalletSendDetails.prototype, "receiverAddress", void 0);
__decorate90([
  property({ type: Object })
], W3mWalletSendDetails.prototype, "caipNetwork", void 0);
__decorate90([
  property({ type: Number })
], W3mWalletSendDetails.prototype, "networkFee", void 0);
W3mWalletSendDetails = __decorate90([
  customElement("w3m-wallet-send-details")
], W3mWalletSendDetails);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-tooltip/styles.js
var styles_default65 = css`
  :host {
    pointer-events: none;
  }

  :host > wui-flex {
    display: var(--w3m-tooltip-display);
    opacity: var(--w3m-tooltip-opacity);
    padding: 9px var(--wui-spacing-s) 10px var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    color: var(--wui-color-bg-100);
    position: fixed;
    top: var(--w3m-tooltip-top);
    left: var(--w3m-tooltip-left);
    transform: translate(calc(-50% + var(--w3m-tooltip-parent-width)), calc(-100% - 8px));
    max-width: calc(var(--w3m-modal-width) - var(--wui-spacing-xl));
    transition: opacity 0.2s var(--wui-ease-out-power-2);
    will-change: opacity;
  }

  :host([data-variant='shade']) > wui-flex {
    background-color: var(--wui-color-bg-150);
    border: 1px solid var(--wui-color-gray-glass-005);
  }

  :host([data-variant='shade']) > wui-flex > wui-text {
    color: var(--wui-color-fg-150);
  }

  :host([data-variant='fill']) > wui-flex {
    background-color: var(--wui-color-fg-100);
    border: none;
  }

  wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
    color: var(--wui-color-bg-150);
  }

  wui-icon[data-placement='top'] {
    bottom: 0px;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-tooltip/index.js
var __decorate91 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mTooltip = class W3mTooltip2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.open = TooltipController.state.open;
    this.message = TooltipController.state.message;
    this.triggerRect = TooltipController.state.triggerRect;
    this.variant = TooltipController.state.variant;
    this.unsubscribe.push(...[
      TooltipController.subscribe((newState) => {
        this.open = newState.open;
        this.message = newState.message;
        this.triggerRect = newState.triggerRect;
        this.variant = newState.variant;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    this.dataset["variant"] = this.variant;
    const topValue = this.triggerRect.top;
    const leftValue = this.triggerRect.left;
    this.style.cssText = `
    --w3m-tooltip-top: ${topValue}px;
    --w3m-tooltip-left: ${leftValue}px;
    --w3m-tooltip-parent-width: ${this.triggerRect.width / 2}px;
    --w3m-tooltip-display: ${this.open ? "flex" : "none"};
    --w3m-tooltip-opacity: ${this.open ? 1 : 0};
    `;
    return html`<wui-flex>
      <wui-icon data-placement="top" color="fg-100" size="inherit" name="cursor"></wui-icon>
      <wui-text color="inherit" variant="small-500">${this.message}</wui-text>
    </wui-flex>`;
  }
};
W3mTooltip.styles = [styles_default65];
__decorate91([
  state()
], W3mTooltip.prototype, "open", void 0);
__decorate91([
  state()
], W3mTooltip.prototype, "message", void 0);
__decorate91([
  state()
], W3mTooltip.prototype, "triggerRect", void 0);
__decorate91([
  state()
], W3mTooltip.prototype, "variant", void 0);
W3mTooltip = __decorate91([
  customElement("w3m-tooltip")
], W3mTooltip);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-tooltip-trigger/styles.js
var styles_default66 = css`
  :host {
    width: 100%;
    display: block;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-tooltip-trigger/index.js
var __decorate92 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var WuiTooltipTrigger = class WuiTooltipTrigger2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.text = "";
    this.open = TooltipController.state.open;
    this.unsubscribe.push(RouterController.subscribeKey("view", () => {
      TooltipController.hide();
    }), ModalController.subscribeKey("open", (modalOpen) => {
      if (!modalOpen) {
        TooltipController.hide();
      }
    }), TooltipController.subscribeKey("open", (tooltipOpen) => {
      this.open = tooltipOpen;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    TooltipController.hide();
  }
  render() {
    return html`
      <div
        @pointermove=${this.onMouseEnter.bind(this)}
        @pointerleave=${this.onMouseLeave.bind(this)}
      >
        ${this.renderChildren()}
      </div>
    `;
  }
  renderChildren() {
    return html`<slot></slot> `;
  }
  onMouseEnter() {
    const rect = this.getBoundingClientRect();
    if (!this.open) {
      TooltipController.showTooltip({
        message: this.text,
        triggerRect: {
          width: rect.width,
          height: rect.height,
          left: rect.left,
          top: rect.top
        },
        variant: "shade"
      });
    }
  }
  onMouseLeave(event) {
    if (!this.contains(event.relatedTarget)) {
      TooltipController.hide();
    }
  }
};
WuiTooltipTrigger.styles = [styles_default66];
__decorate92([
  property()
], WuiTooltipTrigger.prototype, "text", void 0);
__decorate92([
  state()
], WuiTooltipTrigger.prototype, "open", void 0);
WuiTooltipTrigger = __decorate92([
  customElement("w3m-tooltip-trigger")
], WuiTooltipTrigger);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-social-login-widget/styles.js
var styles_default67 = css`
  :host > wui-flex:first-child {
    margin-top: var(--wui-spacing-s);
  }
  wui-separator {
    margin: var(--wui-spacing-m) calc(var(--wui-spacing-m) * -1) var(--wui-spacing-m)
      calc(var(--wui-spacing-m) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-social-login-widget/index.js
var __decorate93 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var MAX_TOP_VIEW = 2;
var MAXIMUM_LENGTH = 6;
var W3mSocialLoginWidget = class W3mSocialLoginWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.walletGuide = "get-started";
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.features = OptionsController.state.features;
    this.authConnector = this.connectors.find((c5) => c5.type === "AUTH");
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => {
      this.connectors = val;
      this.authConnector = this.connectors.find((c5) => c5.type === "AUTH");
    }), OptionsController.subscribeKey("features", (val) => this.features = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a;
    const socials = (_a = this.features) == null ? void 0 : _a.socials;
    if (!this.authConnector || !socials || !(socials == null ? void 0 : socials.length)) {
      return null;
    }
    return html`
      <wui-flex
        class="container"
        flexDirection="column"
        gap="xs"
        .padding=${["0", "0", "xs", "0"]}
        data-testid="w3m-social-login-widget"
      >
        ${this.topViewTemplate()}${this.bottomViewTemplate()}
      </wui-flex>
      ${this.separatorTemplate()}
    `;
  }
  topViewTemplate() {
    var _a;
    const socials = (_a = this.features) == null ? void 0 : _a.socials;
    if (!this.authConnector || !socials || !(socials == null ? void 0 : socials.length)) {
      return null;
    }
    if (socials.length === 2) {
      return html` <wui-flex gap="xs">
        ${socials.slice(0, MAX_TOP_VIEW).map((social) => html`<wui-logo-select
              data-testid=${`social-selector-${social}`}
              @click=${() => {
        this.onSocialClick(social);
      }}
              logo=${social}
              tabIdx=${ifDefined(this.tabIdx)}
            ></wui-logo-select>`)}
      </wui-flex>`;
    }
    return html` <wui-list-social
      data-testid=${`social-selector-${socials == null ? void 0 : socials[0]}`}
      @click=${() => {
      this.onSocialClick(socials == null ? void 0 : socials[0]);
    }}
      logo=${ifDefined(socials[0])}
      align="center"
      name=${`Continue with ${socials[0]}`}
      tabIdx=${ifDefined(this.tabIdx)}
    ></wui-list-social>`;
  }
  bottomViewTemplate() {
    var _a;
    const socials = (_a = this.features) == null ? void 0 : _a.socials;
    if (!this.authConnector || !socials || !(socials == null ? void 0 : socials.length)) {
      return null;
    }
    if (socials.length <= MAX_TOP_VIEW) {
      return null;
    }
    if (socials.length > MAXIMUM_LENGTH) {
      return html`<wui-flex gap="xs">
        ${socials.slice(1, MAXIMUM_LENGTH - 1).map((social) => html`<wui-logo-select
              data-testid=${`social-selector-${social}`}
              @click=${() => {
        this.onSocialClick(social);
      }}
              logo=${social}
              tabIdx=${ifDefined(this.tabIdx)}
            ></wui-logo-select>`)}
        <wui-logo-select
          logo="more"
          tabIdx=${ifDefined(this.tabIdx)}
          @click=${this.onMoreSocialsClick.bind(this)}
        ></wui-logo-select>
      </wui-flex>`;
    }
    return html`<wui-flex gap="xs">
      ${socials.slice(1, socials.length).map((social) => html`<wui-logo-select
            data-testid=${`social-selector-${social}`}
            @click=${() => {
      this.onSocialClick(social);
    }}
            logo=${social}
            tabIdx=${ifDefined(this.tabIdx)}
          ></wui-logo-select>`)}
    </wui-flex>`;
  }
  separatorTemplate() {
    const walletConnectConnector = this.connectors.find((c5) => c5.id === "walletConnect");
    const enableWallets = OptionsController.state.enableWallets;
    if (walletConnectConnector && enableWallets || this.walletGuide === "explore") {
      return html`<wui-separator text="or"></wui-separator>`;
    }
    return null;
  }
  onMoreSocialsClick() {
    RouterController.push("ConnectSocials");
  }
  async onSocialClick(socialProvider) {
    var _a, _b;
    if (socialProvider) {
      AccountController.setSocialProvider(socialProvider, ChainController.state.activeChain);
      EventsController.sendEvent({
        type: "track",
        event: "SOCIAL_LOGIN_STARTED",
        properties: { provider: socialProvider }
      });
    }
    if (socialProvider === SocialProviderEnum.Farcaster) {
      RouterController.push("ConnectingFarcaster");
      const authConnector = ConnectorController.getAuthConnector();
      if (authConnector) {
        if (!AccountController.state.farcasterUrl) {
          try {
            const { url } = await authConnector.provider.getFarcasterUri();
            AccountController.setFarcasterUrl(url, ChainController.state.activeChain);
          } catch (error) {
            RouterController.goBack();
            SnackController.showError(error);
          }
        }
      }
    } else {
      RouterController.push("ConnectingSocial");
      const authConnector = ConnectorController.getAuthConnector();
      this.popupWindow = CoreHelperUtil.returnOpenHref("", "popupWindow", "width=600,height=800,scrollbars=yes");
      try {
        if (authConnector && socialProvider) {
          const { uri } = await authConnector.provider.getSocialRedirectUri({
            provider: socialProvider
          });
          if (this.popupWindow && uri) {
            AccountController.setSocialWindow(this.popupWindow, ChainController.state.activeChain);
            this.popupWindow.location.href = uri;
          } else {
            (_a = this.popupWindow) == null ? void 0 : _a.close();
            throw new Error("Something went wrong");
          }
        }
      } catch (error) {
        (_b = this.popupWindow) == null ? void 0 : _b.close();
        SnackController.showError("Something went wrong");
      }
    }
  }
};
W3mSocialLoginWidget.styles = styles_default67;
__decorate93([
  property()
], W3mSocialLoginWidget.prototype, "walletGuide", void 0);
__decorate93([
  property()
], W3mSocialLoginWidget.prototype, "tabIdx", void 0);
__decorate93([
  state()
], W3mSocialLoginWidget.prototype, "connectors", void 0);
__decorate93([
  state()
], W3mSocialLoginWidget.prototype, "features", void 0);
__decorate93([
  state()
], W3mSocialLoginWidget.prototype, "authConnector", void 0);
W3mSocialLoginWidget = __decorate93([
  customElement("w3m-social-login-widget")
], W3mSocialLoginWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-wallet-login-list/index.js
var __decorate94 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mWalletLoginList = class W3mWalletLoginList2 extends LitElement {
  constructor() {
    super(...arguments);
    this.tabIdx = void 0;
  }
  render() {
    return html`
      <wui-flex flexDirection="column" gap="xs">
        <w3m-connector-list tabIdx=${ifDefined(this.tabIdx)}></w3m-connector-list>
        <w3m-all-wallets-widget tabIdx=${ifDefined(this.tabIdx)}></w3m-all-wallets-widget>
      </wui-flex>
    `;
  }
};
__decorate94([
  property()
], W3mWalletLoginList.prototype, "tabIdx", void 0);
W3mWalletLoginList = __decorate94([
  customElement("w3m-wallet-login-list")
], W3mWalletLoginList);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-social-login-list/styles.js
var styles_default68 = css`
  :host {
    margin-top: var(--wui-spacing-3xs);
  }
  wui-separator {
    margin: var(--wui-spacing-m) calc(var(--wui-spacing-m) * -1) var(--wui-spacing-xs)
      calc(var(--wui-spacing-m) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-social-login-list/index.js
var __decorate95 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSocialLoginList = class W3mSocialLoginList2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.authConnector = this.connectors.find((c5) => c5.type === "AUTH");
    this.features = OptionsController.state.features;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => {
      this.connectors = val;
      this.authConnector = this.connectors.find((c5) => c5.type === "AUTH");
    }), OptionsController.subscribeKey("features", (val) => this.features = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a;
    const socials = (_a = this.features) == null ? void 0 : _a.socials;
    if (!this.authConnector || !socials || !(socials == null ? void 0 : socials.length)) {
      return null;
    }
    return html` <wui-flex flexDirection="column" gap="xs">
      ${socials.map((social) => html`<wui-list-social
            @click=${() => {
      this.onSocialClick(social);
    }}
            name=${social}
            logo=${social}
            tabIdx=${ifDefined(this.tabIdx)}
          ></wui-list-social>`)}
    </wui-flex>`;
  }
  async onSocialClick(socialProvider) {
    var _a, _b;
    if (socialProvider) {
      AccountController.setSocialProvider(socialProvider, ChainController.state.activeChain);
      EventsController.sendEvent({
        type: "track",
        event: "SOCIAL_LOGIN_STARTED",
        properties: { provider: socialProvider }
      });
    }
    if (socialProvider === SocialProviderEnum.Farcaster) {
      RouterController.push("ConnectingFarcaster");
      const authConnector = ConnectorController.getAuthConnector();
      if (authConnector) {
        if (!AccountController.state.farcasterUrl) {
          try {
            const { url } = await authConnector.provider.getFarcasterUri();
            AccountController.setFarcasterUrl(url, ChainController.state.activeChain);
          } catch (error) {
            RouterController.goBack();
            SnackController.showError(error);
          }
        }
      }
    } else {
      RouterController.push("ConnectingSocial");
      const authConnector = ConnectorController.getAuthConnector();
      this.popupWindow = CoreHelperUtil.returnOpenHref("", "popupWindow", "width=600,height=800,scrollbars=yes");
      try {
        if (authConnector && socialProvider) {
          const { uri } = await authConnector.provider.getSocialRedirectUri({
            provider: socialProvider
          });
          if (this.popupWindow && uri) {
            AccountController.setSocialWindow(this.popupWindow, ChainController.state.activeChain);
            this.popupWindow.location.href = uri;
          } else {
            (_a = this.popupWindow) == null ? void 0 : _a.close();
            throw new Error("Something went wrong");
          }
        }
      } catch (error) {
        (_b = this.popupWindow) == null ? void 0 : _b.close();
        SnackController.showError("Something went wrong");
      }
    }
  }
};
W3mSocialLoginList.styles = styles_default68;
__decorate95([
  property()
], W3mSocialLoginList.prototype, "tabIdx", void 0);
__decorate95([
  state()
], W3mSocialLoginList.prototype, "connectors", void 0);
__decorate95([
  state()
], W3mSocialLoginList.prototype, "authConnector", void 0);
__decorate95([
  state()
], W3mSocialLoginList.prototype, "features", void 0);
W3mSocialLoginList = __decorate95([
  customElement("w3m-social-login-list")
], W3mSocialLoginList);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-announced-widget/index.js
var __decorate96 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectAnnouncedWidget = class W3mConnectAnnouncedWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const announcedConnectors = this.connectors.filter((connector) => connector.type === "ANNOUNCED");
    if (!(announcedConnectors == null ? void 0 : announcedConnectors.length)) {
      this.style.cssText = `display: none`;
      return null;
    }
    return html`
      <wui-flex flexDirection="column" gap="xs">
        ${announcedConnectors.map((connector) => {
      var _a, _b;
      if (((_a = connector.info) == null ? void 0 : _a.rdns) && ApiController.state.excludedRDNS) {
        if (ApiController.state.excludedRDNS.includes((_b = connector == null ? void 0 : connector.info) == null ? void 0 : _b.rdns)) {
          return null;
        }
      }
      return html`
            <wui-list-wallet
              imageSrc=${ifDefined(AssetUtil.getConnectorImage(connector))}
              name=${connector.name ?? "Unknown"}
              @click=${() => this.onConnector(connector)}
              tagVariant="success"
              tagLabel="installed"
              data-testid=${`wallet-selector-${connector.id}`}
              .installed=${true}
              tabIdx=${ifDefined(this.tabIdx)}
            >
            </wui-list-wallet>
          `;
    })}
      </wui-flex>
    `;
  }
  onConnector(connector) {
    if (connector.id === "walletConnect") {
      if (CoreHelperUtil.isMobile()) {
        RouterController.push("AllWallets");
      } else {
        RouterController.push("ConnectingWalletConnect");
      }
    } else {
      RouterController.push("ConnectingExternal", { connector });
    }
  }
};
__decorate96([
  property()
], W3mConnectAnnouncedWidget.prototype, "tabIdx", void 0);
__decorate96([
  state()
], W3mConnectAnnouncedWidget.prototype, "connectors", void 0);
W3mConnectAnnouncedWidget = __decorate96([
  customElement("w3m-connect-announced-widget")
], W3mConnectAnnouncedWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-custom-widget/index.js
var __decorate97 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectCustomWidget = class W3mConnectCustomWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { customWallets } = OptionsController.state;
    if (!(customWallets == null ? void 0 : customWallets.length)) {
      this.style.cssText = `display: none`;
      return null;
    }
    const wallets = this.filterOutDuplicateWallets(customWallets);
    return html`<wui-flex flexDirection="column" gap="xs">
      ${wallets.map((wallet) => html`
          <wui-list-wallet
            imageSrc=${ifDefined(AssetUtil.getWalletImage(wallet))}
            name=${wallet.name ?? "Unknown"}
            @click=${() => this.onConnectWallet(wallet)}
            data-testid=${`wallet-selector-${wallet.id}`}
            tabIdx=${ifDefined(this.tabIdx)}
          >
          </wui-list-wallet>
        `)}
    </wui-flex>`;
  }
  filterOutDuplicateWallets(wallets) {
    const recent = StorageUtil.getRecentWallets();
    const connectorRDNSs = this.connectors.map((connector) => {
      var _a;
      return (_a = connector.info) == null ? void 0 : _a.rdns;
    }).filter(Boolean);
    const recentRDNSs = recent.map((wallet) => wallet.rdns).filter(Boolean);
    const allRDNSs = connectorRDNSs.concat(recentRDNSs);
    if (allRDNSs.includes("io.metamask.mobile") && CoreHelperUtil.isMobile()) {
      const index2 = allRDNSs.indexOf("io.metamask.mobile");
      allRDNSs[index2] = "io.metamask";
    }
    const filtered = wallets.filter((wallet) => !allRDNSs.includes(String(wallet == null ? void 0 : wallet.rdns)));
    return filtered;
  }
  onConnectWallet(wallet) {
    RouterController.push("ConnectingWalletConnect", { wallet });
  }
};
__decorate97([
  property()
], W3mConnectCustomWidget.prototype, "tabIdx", void 0);
__decorate97([
  state()
], W3mConnectCustomWidget.prototype, "connectors", void 0);
W3mConnectCustomWidget = __decorate97([
  customElement("w3m-connect-custom-widget")
], W3mConnectCustomWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-featured-widget/index.js
var __decorate98 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectFeaturedWidget = class W3mConnectFeaturedWidget2 extends LitElement {
  constructor() {
    super(...arguments);
    this.unsubscribe = [];
    this.tabIdx = void 0;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { featured } = ApiController.state;
    if (!featured.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    const wallets = WalletUtil.filterOutDuplicateWallets(featured);
    return html`
      <wui-flex flexDirection="column" gap="xs">
        ${wallets.map((wallet) => html`
            <wui-list-wallet
              imageSrc=${ifDefined(AssetUtil.getWalletImage(wallet))}
              name=${wallet.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(wallet)}
              tabIdx=${ifDefined(this.tabIdx)}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  onConnectWallet(wallet) {
    const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
__decorate98([
  property()
], W3mConnectFeaturedWidget.prototype, "tabIdx", void 0);
W3mConnectFeaturedWidget = __decorate98([
  customElement("w3m-connect-featured-widget")
], W3mConnectFeaturedWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-injected-widget/index.js
var __decorate99 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectInjectedWidget = class W3mConnectInjectedWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a;
    const injectedConnectors = this.connectors.filter((connector) => connector.type === "INJECTED");
    if (!(injectedConnectors == null ? void 0 : injectedConnectors.length) || injectedConnectors.length === 1 && ((_a = injectedConnectors[0]) == null ? void 0 : _a.name) === "Browser Wallet" && !CoreHelperUtil.isMobile()) {
      this.style.cssText = `display: none`;
      return null;
    }
    return html`
      <wui-flex flexDirection="column" gap="xs">
        ${injectedConnectors.map((connector) => {
      var _a2;
      if (!CoreHelperUtil.isMobile() && connector.name === "Browser Wallet") {
        return null;
      }
      const walletRDNS = (_a2 = connector.info) == null ? void 0 : _a2.rdns;
      if (!walletRDNS && !ConnectionController.checkInstalled(void 0)) {
        this.style.cssText = `display: none`;
        return null;
      }
      if (walletRDNS && ApiController.state.excludedRDNS) {
        if (ApiController.state.excludedRDNS.includes(walletRDNS)) {
          return null;
        }
      }
      return html`
            <wui-list-wallet
              imageSrc=${ifDefined(AssetUtil.getConnectorImage(connector))}
              .installed=${true}
              name=${connector.name ?? "Unknown"}
              tagVariant="success"
              tagLabel="installed"
              data-testid=${`wallet-selector-${connector.id}`}
              @click=${() => this.onConnector(connector)}
              tabIdx=${ifDefined(this.tabIdx)}
            >
            </wui-list-wallet>
          `;
    })}
      </wui-flex>
    `;
  }
  onConnector(connector) {
    ChainController.setActiveConnector(connector);
    RouterController.push("ConnectingExternal", { connector });
  }
};
__decorate99([
  property()
], W3mConnectInjectedWidget.prototype, "tabIdx", void 0);
__decorate99([
  state()
], W3mConnectInjectedWidget.prototype, "connectors", void 0);
W3mConnectInjectedWidget = __decorate99([
  customElement("w3m-connect-injected-widget")
], W3mConnectInjectedWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-multi-chain-widget/index.js
var __decorate100 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectMultiChainWidget = class W3mConnectMultiChainWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const multiChainConnectors = this.connectors.filter((connector) => connector.type === "MULTI_CHAIN" && connector.name !== "WalletConnect");
    if (!(multiChainConnectors == null ? void 0 : multiChainConnectors.length)) {
      this.style.cssText = `display: none`;
      return null;
    }
    return html`
      <wui-flex flexDirection="column" gap="xs">
        ${multiChainConnectors.map((connector) => html`
            <wui-list-wallet
              imageSrc=${ifDefined(AssetUtil.getConnectorImage(connector))}
              .installed=${true}
              name=${connector.name ?? "Unknown"}
              tagVariant="shade"
              tagLabel="multichain"
              data-testid=${`wallet-selector-${connector.id}`}
              @click=${() => this.onConnector(connector)}
              tabIdx=${ifDefined(this.tabIdx)}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  onConnector(connector) {
    ChainController.setActiveConnector(connector);
    RouterController.push("ConnectingMultiChain");
  }
};
__decorate100([
  property()
], W3mConnectMultiChainWidget.prototype, "tabIdx", void 0);
__decorate100([
  state()
], W3mConnectMultiChainWidget.prototype, "connectors", void 0);
W3mConnectMultiChainWidget = __decorate100([
  customElement("w3m-connect-multi-chain-widget")
], W3mConnectMultiChainWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-external-widget/index.js
var __decorate101 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectExternalWidget = class W3mConnectExternalWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const externalConnectors = this.connectors.filter((connector) => connector.type === "EXTERNAL");
    if (!(externalConnectors == null ? void 0 : externalConnectors.length)) {
      this.style.cssText = `display: none`;
      return null;
    }
    return html`
      <wui-flex flexDirection="column" gap="xs">
        ${externalConnectors.map((connector) => html`
            <wui-list-wallet
              imageSrc=${ifDefined(AssetUtil.getConnectorImage(connector))}
              .installed=${true}
              name=${connector.name ?? "Unknown"}
              data-testid=${`wallet-selector-external-${connector.id}`}
              @click=${() => this.onConnector(connector)}
              tabIdx=${ifDefined(this.tabIdx)}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  onConnector(connector) {
    RouterController.push("ConnectingExternal", { connector });
  }
};
__decorate101([
  property()
], W3mConnectExternalWidget.prototype, "tabIdx", void 0);
__decorate101([
  state()
], W3mConnectExternalWidget.prototype, "connectors", void 0);
W3mConnectExternalWidget = __decorate101([
  customElement("w3m-connect-external-widget")
], W3mConnectExternalWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-recent-widget/index.js
var __decorate102 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectRecentWidget = class W3mConnectRecentWidget2 extends LitElement {
  constructor() {
    super(...arguments);
    this.tabIdx = void 0;
  }
  render() {
    const recent = StorageUtil.getRecentWallets();
    if (!(recent == null ? void 0 : recent.length)) {
      this.style.cssText = `display: none`;
      return null;
    }
    return html`
      <wui-flex flexDirection="column" gap="xs">
        ${recent.map((wallet) => html`
            <wui-list-wallet
              imageSrc=${ifDefined(AssetUtil.getWalletImage(wallet))}
              name=${wallet.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(wallet)}
              tagLabel="recent"
              tagVariant="shade"
              tabIdx=${ifDefined(this.tabIdx)}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  onConnectWallet(wallet) {
    RouterController.push("ConnectingWalletConnect", { wallet });
  }
};
__decorate102([
  property()
], W3mConnectRecentWidget.prototype, "tabIdx", void 0);
W3mConnectRecentWidget = __decorate102([
  customElement("w3m-connect-recent-widget")
], W3mConnectRecentWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-recommended-widget/index.js
var __decorate103 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectRecommendedWidget = class W3mConnectRecommendedWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const connector = this.connectors.find((c5) => c5.id === "walletConnect");
    if (!connector) {
      return null;
    }
    const { recommended } = ApiController.state;
    const { customWallets, featuredWalletIds } = OptionsController.state;
    const { connectors } = ConnectorController.state;
    const recent = StorageUtil.getRecentWallets();
    const injected = connectors.filter((c5) => c5.type === "INJECTED" || c5.type === "ANNOUNCED" || c5.type === "MULTI_CHAIN");
    const injectedWallets = injected.filter((i3) => i3.name !== "Browser Wallet");
    if (featuredWalletIds || customWallets || !recommended.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    const overrideLength = injectedWallets.length + recent.length;
    const maxRecommended = Math.max(0, 2 - overrideLength);
    const wallets = WalletUtil.filterOutDuplicateWallets(recommended).slice(0, maxRecommended);
    if (!wallets.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    return html`
      <wui-flex flexDirection="column" gap="xs">
        ${wallets.map((wallet) => html`
            <wui-list-wallet
              imageSrc=${ifDefined(AssetUtil.getWalletImage(wallet))}
              name=${(wallet == null ? void 0 : wallet.name) ?? "Unknown"}
              @click=${() => this.onConnectWallet(wallet)}
              tabIdx=${ifDefined(this.tabIdx)}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  onConnectWallet(wallet) {
    const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
__decorate103([
  property()
], W3mConnectRecommendedWidget.prototype, "tabIdx", void 0);
__decorate103([
  state()
], W3mConnectRecommendedWidget.prototype, "connectors", void 0);
W3mConnectRecommendedWidget = __decorate103([
  customElement("w3m-connect-recommended-widget")
], W3mConnectRecommendedWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-walletconnect-widget/index.js
var __decorate104 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectWalletConnectWidget = class W3mConnectWalletConnectWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (CoreHelperUtil.isMobile()) {
      this.style.cssText = `display: none`;
      return null;
    }
    const connector = this.connectors.find((c5) => c5.id === "walletConnect");
    if (!connector) {
      this.style.cssText = `display: none`;
      return null;
    }
    return html`
      <wui-list-wallet
        imageSrc=${ifDefined(AssetUtil.getConnectorImage(connector))}
        name=${connector.name ?? "Unknown"}
        @click=${() => this.onConnector(connector)}
        tagLabel="qr code"
        tagVariant="main"
        tabIdx=${ifDefined(this.tabIdx)}
        data-testid="wallet-selector-walletconnect"
      >
      </wui-list-wallet>
    `;
  }
  onConnector(connector) {
    ChainController.setActiveConnector(connector);
    RouterController.push("ConnectingWalletConnect");
  }
};
__decorate104([
  property()
], W3mConnectWalletConnectWidget.prototype, "tabIdx", void 0);
__decorate104([
  state()
], W3mConnectWalletConnectWidget.prototype, "connectors", void 0);
W3mConnectWalletConnectWidget = __decorate104([
  customElement("w3m-connect-walletconnect-widget")
], W3mConnectWalletConnectWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connector-list/styles.js
var styles_default69 = css`
  :host {
    margin-top: var(--wui-spacing-3xs);
  }
  wui-separator {
    margin: var(--wui-spacing-m) calc(var(--wui-spacing-m) * -1) var(--wui-spacing-xs)
      calc(var(--wui-spacing-m) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connector-list/index.js
var __decorate105 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectorList = class W3mConnectorList2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { custom: custom2, recent, announced, injected, multiChain, recommended, featured, external } = this.getConnectorsByType();
    const enableWalletConnect = OptionsController.state.enableWalletConnect;
    return html`
      <wui-flex flexDirection="column" gap="xs">
        ${enableWalletConnect ? html`<w3m-connect-walletconnect-widget
              tabIdx=${ifDefined(this.tabIdx)}
            ></w3m-connect-walletconnect-widget>` : null}
        ${recent.length ? html`<w3m-connect-recent-widget
              tabIdx=${ifDefined(this.tabIdx)}
            ></w3m-connect-recent-widget>` : null}
        ${multiChain.length ? html`<w3m-connect-multi-chain-widget
              tabIdx=${ifDefined(this.tabIdx)}
            ></w3m-connect-multi-chain-widget>` : null}
        ${announced.length ? html`<w3m-connect-announced-widget
              tabIdx=${ifDefined(this.tabIdx)}
            ></w3m-connect-announced-widget>` : null}
        ${injected.length ? html`<w3m-connect-injected-widget
              tabIdx=${ifDefined(this.tabIdx)}
            ></w3m-connect-injected-widget>` : null}
        ${featured.length ? html`<w3m-connect-featured-widget
              tabIdx=${ifDefined(this.tabIdx)}
            ></w3m-connect-featured-widget>` : null}
        ${(custom2 == null ? void 0 : custom2.length) ? html`<w3m-connect-custom-widget
              tabIdx=${ifDefined(this.tabIdx)}
            ></w3m-connect-custom-widget>` : null}
        ${external.length ? html`<w3m-connect-external-widget
              tabIdx=${ifDefined(this.tabIdx)}
            ></w3m-connect-external-widget>` : null}
        ${recommended.length ? html`<w3m-connect-recommended-widget
              tabIdx=${ifDefined(this.tabIdx)}
            ></w3m-connect-recommended-widget>` : null}
      </wui-flex>
    `;
  }
  getConnectorsByType() {
    const { featured, recommended } = ApiController.state;
    const { customWallets: custom2 } = OptionsController.state;
    const recent = StorageUtil.getRecentWallets();
    const filteredRecommended = WalletUtil.filterOutDuplicateWallets(recommended);
    const filteredFeatured = WalletUtil.filterOutDuplicateWallets(featured);
    const multiChain = this.connectors.filter((connector) => connector.type === "MULTI_CHAIN");
    const announced = this.connectors.filter((connector) => connector.type === "ANNOUNCED");
    const injected = this.connectors.filter((connector) => connector.type === "INJECTED");
    const external = this.connectors.filter((connector) => connector.type === "EXTERNAL");
    return {
      custom: custom2,
      recent,
      external,
      multiChain,
      announced,
      injected,
      recommended: filteredRecommended,
      featured: filteredFeatured
    };
  }
};
W3mConnectorList.styles = styles_default69;
__decorate105([
  property()
], W3mConnectorList.prototype, "tabIdx", void 0);
__decorate105([
  state()
], W3mConnectorList.prototype, "connectors", void 0);
W3mConnectorList = __decorate105([
  customElement("w3m-connector-list")
], W3mConnectorList);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-widget/index.js
var __decorate106 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAllWalletsWidget = class W3mAllWalletsWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.count = ApiController.state.count;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val), ApiController.subscribeKey("count", (val) => this.count = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const wcConnector = this.connectors.find((c5) => c5.id === "walletConnect");
    const { allWallets } = OptionsController.state;
    if (!wcConnector || allWallets === "HIDE") {
      return null;
    }
    if (allWallets === "ONLY_MOBILE" && !CoreHelperUtil.isMobile()) {
      return null;
    }
    const featuredCount = ApiController.state.featured.length;
    const rawCount = this.count + featuredCount;
    const roundedCount = rawCount < 10 ? rawCount : Math.floor(rawCount / 10) * 10;
    const tagLabel = roundedCount < rawCount ? `${roundedCount}+` : `${roundedCount}`;
    return html`
      <wui-list-wallet
        name="All Wallets"
        walletIcon="allWallets"
        showAllWallets
        @click=${this.onAllWallets.bind(this)}
        tagLabel=${tagLabel}
        tagVariant="shade"
        data-testid="all-wallets"
        tabIdx=${ifDefined(this.tabIdx)}
      ></wui-list-wallet>
    `;
  }
  onAllWallets() {
    EventsController.sendEvent({ type: "track", event: "CLICK_ALL_WALLETS" });
    RouterController.push("AllWallets");
  }
};
__decorate106([
  property()
], W3mAllWalletsWidget.prototype, "tabIdx", void 0);
__decorate106([
  state()
], W3mAllWalletsWidget.prototype, "connectors", void 0);
__decorate106([
  state()
], W3mAllWalletsWidget.prototype, "count", void 0);
W3mAllWalletsWidget = __decorate106([
  customElement("w3m-all-wallets-widget")
], W3mAllWalletsWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-auth-button/index.js
var __decorate107 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAccountAuthButton = class W3mAccountAuthButton2 extends LitElement {
  constructor() {
    super(...arguments);
    this.socialProvider = StorageUtil.getConnectedSocialProvider();
    this.socialUsername = StorageUtil.getConnectedSocialUsername();
  }
  render() {
    const type = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector || type !== "ID_AUTH") {
      this.style.cssText = `display: none`;
      return null;
    }
    const email = authConnector.provider.getEmail() ?? "";
    return html`
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon=${this.socialProvider ?? "mail"}
        iconSize=${this.socialProvider ? "xxl" : "sm"}
        data-testid="w3m-account-email-update"
        ?chevron=${!this.socialProvider}
        @click=${() => {
      this.onGoToUpdateEmail(email, this.socialProvider);
    }}
      >
        <wui-text variant="paragraph-500" color="fg-100">${this.getAuthName(email)}</wui-text>
      </wui-list-item>
    `;
  }
  onGoToUpdateEmail(email, socialProvider) {
    if (!socialProvider) {
      RouterController.push("UpdateEmailWallet", { email });
    }
  }
  getAuthName(email) {
    if (this.socialUsername) {
      if (this.socialProvider === "discord" && this.socialUsername.endsWith("0")) {
        return this.socialUsername.slice(0, -1);
      }
      return this.socialUsername;
    }
    return email.length > 30 ? `${email.slice(0, -3)}...` : email;
  }
};
W3mAccountAuthButton = __decorate107([
  customElement("w3m-account-auth-button")
], W3mAccountAuthButton);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-wallet-guide/styles.js
var styles_default70 = css`
  wui-flex {
    width: 100%;
  }

  .wallet-guide {
    width: 100%;
  }

  .chip-box {
    width: fit-content;
    background-color: var(--wui-color-gray-glass-005);
    border-radius: var(--wui-border-radius-3xl);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-wallet-guide/index.js
var __decorate108 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mWalletGuide = class W3mWalletGuide2 extends LitElement {
  constructor() {
    super(...arguments);
    this.walletGuide = "get-started";
  }
  render() {
    return this.walletGuide === "explore" ? html`<wui-flex
          class="wallet-guide"
          flexDirection="column"
          alignItems="center"
          justifyContent="center"
          rowGap="xs"
          data-testid="w3m-wallet-guide-explore"
        >
          <wui-text variant="small-400" color="fg-200" align="center">
            Looking for a self-custody wallet?
          </wui-text>

          <wui-flex class="chip-box">
            <wui-chip
              imageIcon="walletConnectLightBrown"
              icon="externalLink"
              variant="transparent"
              href="https://explorer.walletconnect.com"
              title="Visit our Explorer"
            ></wui-chip>
          </wui-flex>
        </wui-flex>` : html`<wui-flex
          columnGap="4xs"
          flexDirection="row"
          alignItems="center"
          justifyContent="center"
        >
          <wui-text variant="small-400" class="title" color="fg-200"
            >Haven't got a wallet?</wui-text
          >
          <wui-link
            data-testid="w3m-wallet-guide-get-started"
            color="blue-100"
            class="get-started-link"
            @click=${this.onGetStarted}
            tabIdx=${ifDefined(this.tabIdx)}
          >
            Get started
          </wui-link>
        </wui-flex>`;
  }
  onGetStarted() {
    RouterController.push("Create");
  }
};
W3mWalletGuide.styles = styles_default70;
__decorate108([
  property()
], W3mWalletGuide.prototype, "tabIdx", void 0);
__decorate108([
  property()
], W3mWalletGuide.prototype, "walletGuide", void 0);
W3mWalletGuide = __decorate108([
  customElement("w3m-wallet-guide")
], W3mWalletGuide);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-siwx-sign-message-thumbnails/styles.js
var styles_default71 = css`
  :host {
    display: flex;
    justify-content: center;
    gap: var(--wui-spacing-2xl);
  }

  wui-visual-thumbnail:nth-child(1) {
    z-index: 1;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-siwx-sign-message-thumbnails/index.js
var __decorate109 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSIWXSignMessageThumbnails = class W3mSIWXSignMessageThumbnails2 extends LitElement {
  constructor() {
    var _a, _b;
    super(...arguments);
    this.dappImageUrl = (_a = OptionsController.state.metadata) == null ? void 0 : _a.icons;
    this.walletImageUrl = (_b = AccountController.state.connectedWalletInfo) == null ? void 0 : _b.icon;
  }
  firstUpdated() {
    var _a;
    const visuals = (_a = this.shadowRoot) == null ? void 0 : _a.querySelectorAll("wui-visual-thumbnail");
    if (visuals == null ? void 0 : visuals[0]) {
      this.createAnimation(visuals[0], "translate(18px)");
    }
    if (visuals == null ? void 0 : visuals[1]) {
      this.createAnimation(visuals[1], "translate(-18px)");
    }
  }
  render() {
    var _a;
    return html`
      <wui-visual-thumbnail
        ?borderRadiusFull=${true}
        .imageSrc=${(_a = this.dappImageUrl) == null ? void 0 : _a[0]}
      ></wui-visual-thumbnail>
      <wui-visual-thumbnail .imageSrc=${this.walletImageUrl}></wui-visual-thumbnail>
    `;
  }
  createAnimation(element, translation) {
    element.animate([{ transform: "translateX(0px)" }, { transform: translation }], {
      duration: 1600,
      easing: "cubic-bezier(0.56, 0, 0.48, 1)",
      direction: "alternate",
      iterations: Infinity
    });
  }
};
W3mSIWXSignMessageThumbnails.styles = styles_default71;
W3mSIWXSignMessageThumbnails = __decorate109([
  customElement("w3m-siwx-sign-message-thumbnails")
], W3mSIWXSignMessageThumbnails);

export {
  ConstantsUtil3 as ConstantsUtil,
  PresetsUtil,
  useSnapshot,
  AdapterBlueprint,
  WcConstantsUtil,
  WcHelpersUtil,
  ProviderUtil,
  require_events,
  AppKit,
  PACKAGE_VERSION,
  W3mAccountButton,
  AppKitAccountButton,
  W3mButton,
  AppKitButton,
  W3mConnectButton,
  AppKitConnectButton,
  W3mNetworkButton,
  AppKitNetworkButton,
  W3mRouter,
  W3mOnrampWidget,
  W3mAccountSettingsView,
  W3mAccountView,
  W3mAllWalletsView,
  W3mBuyInProgressView,
  W3mConnectView,
  W3mConnectingExternalView,
  W3mConnectingMultiChainView,
  W3mConnectingWcView,
  W3mChooseAccountNameView,
  W3mDownloadsView,
  W3mGetWalletView,
  W3mRegisterAccountNameView,
  W3mRegisterAccountNameSuccess,
  W3mNetworkSwitchView,
  W3mNetworksView,
  W3mOnRampActivityView,
  W3mOnrampFiatSelectView,
  W3mOnRampProvidersView,
  W3mOnrampTokensView,
  W3mSwapView,
  W3mSwitchActiveChainView,
  W3mSwapPreviewView,
  W3mSwapSelectTokenView,
  W3mTransactionsView,
  W3mWhatIsANetworkView,
  W3mWhatIsAWalletView,
  W3mWhatIsABuyView,
  W3mEmailVerifyOtpView,
  W3mEmailVerifyDeviceView,
  W3mApproveTransactionView,
  W3mUpgradeWalletView,
  W3mUpgradeToSmartAccountView,
  W3mUpdateEmailWalletView,
  W3mUpdateEmailPrimaryOtpView,
  W3mUpdateEmailSecondaryOtpView,
  W3mUnsupportedChainView,
  W3mWalletReceiveView,
  W3mWalletCompatibleNetworksView,
  W3mWalletSendView,
  W3mSendSelectTokenView,
  W3mWalletSendPreviewView,
  W3mConnectWalletsView,
  W3mConnectSocialsView,
  W3mConnectingSocialView,
  W3mProfileView,
  W3mSwitchAddressView,
  W3mConnectingFarcasterView,
  W3mSIWXSignMessageView,
  W3mAllWalletsList,
  W3mAllWalletsListItem,
  W3mAllWalletsSearch,
  W3mConnectingHeader,
  W3mConnectingWcBrowser,
  W3mConnectingWcDesktop,
  W3mConnectingWcMobile,
  W3mConnectingWcQrcode,
  W3mConnectingWcUnsupported,
  W3mConnectingWcWeb,
  WuiSwapDetails,
  W3mSwapInput,
  W3mSwapInputSkeleton,
  W3mHeader,
  W3mHelpWidget,
  W3mOnRampActivityItem,
  W3mInputCurrency,
  W3mOnRampProviderItem,
  W3mLegalFooter,
  W3mLegalCheckbox,
  W3mMobileDownloadLinks,
  W3mOnRampProvidersFooter,
  W3mSnackBar,
  W3mAlertBar,
  W3mEmailLoginWidget,
  W3mAccountDefaultWidget,
  W3mAccountWalletFeaturesWidget,
  W3mAccountActivityWidget,
  W3mAccountNftsWidget,
  W3mAccountTokensWidget,
  W3mActivityList,
  W3mInputToken,
  W3mInputAddress,
  W3mWalletSendDetails,
  W3mTooltip,
  WuiTooltipTrigger,
  W3mSocialLoginWidget,
  W3mWalletLoginList,
  W3mSocialLoginList,
  W3mConnectAnnouncedWidget,
  W3mConnectCustomWidget,
  W3mConnectFeaturedWidget,
  W3mConnectInjectedWidget,
  W3mConnectMultiChainWidget,
  W3mConnectExternalWidget,
  W3mConnectRecentWidget,
  W3mConnectRecommendedWidget,
  W3mConnectWalletConnectWidget,
  W3mConnectorList,
  W3mAllWalletsWidget,
  W3mAccountAuthButton,
  W3mWalletGuide,
  W3mSIWXSignMessageThumbnails
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@walletconnect/universal-provider/dist/index.es.js:
  (**
  * @license
  * Lodash <https://lodash.com/>
  * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
  * Released under MIT license <https://lodash.com/license>
  * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
  * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  *)
*/
//# sourceMappingURL=chunk-CKMTTUFJ.js.map
